Script started on 2022-01-01 16:47:10+09:00 [TERM="xterm-256color" TTY="/dev/tty2" COLUMNS="120" LINES="30"]
]0;t2000@DESKTOP-DC96FRC: ~/llvm-project/test[01;32mt2000@DESKTOP-DC96FRC[00m:[01;34m~/llvm-project/test[00m$ exitscripttypescript[5Pcleartypescript[4Pscript[2Pexitscripttypescript[5Pclear../build_miqs/bin/llc test_addarray.ll -mattr=experimental-v -riscv-v-vector-bits-min=256 -debug 
Args: ../build_miqs/bin/llc test_addarray.ll -mattr=experimental-v -riscv-v-vector-bits-min=256 -debug 

Features:+64bit,+a,+c,+m,+relax,-save-restore,+experimental-v
CPU:generic-rv64
TuneCPU:generic-rv64

LoopSimplify: Creating pre-header vector.body.preheader
LoopSimplify: Creating dedicated exit block for.body.preheader.loopexit
canonfr: PHI:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ %indvars.iv.ph, %for.body.preheader ]
FOUND USER:   %exitcond.not = icmp eq i64 %indvars.iv.next, 999, !dbg !34
   OF SCEV: {(1 + %indvars.iv.ph)<nuw><nsw>,+,1}<nuw><nsw><%for.body>
FOUND USER:   store i32 %add, i32* %arrayidx4, align 4, !dbg !24, !tbaa !13
   OF SCEV: {((4 * %indvars.iv.ph)<nuw><nsw> + %c)<nuw>,+,4}<nuw><%for.body>
FOUND USER:   %9 = load i32, i32* %arrayidx2, align 4, !dbg !20, !tbaa !13
   OF SCEV: {((4 * %indvars.iv.ph)<nuw><nsw> + %b)<nuw>,+,4}<nuw><%for.body>
FOUND USER:   %8 = load i32, i32* %arrayidx, align 4, !dbg !12, !tbaa !13
   OF SCEV: {((4 * %indvars.iv.ph)<nuw><nsw> + %a)<nuw>,+,4}<nuw><%for.body>

LSR on loop %for.body:
  Change loop exiting icmp to use postinc iv:   %exitcond.not = icmp eq i64 %indvars.iv.next, 999, !dbg !34
Collecting IV Chains.
IV Chain#0 Head: (  %8 = load i32, i32* %arrayidx, align 4, !dbg !12, !tbaa !13) IV={((4 * %indvars.iv.ph)<nuw><nsw> + %a)<nuw>,+,4}<nuw><%for.body>
IV Chain#1 Head: (  %9 = load i32, i32* %arrayidx2, align 4, !dbg !20, !tbaa !13) IV={((4 * %indvars.iv.ph)<nuw><nsw> + %b)<nuw>,+,4}<nuw><%for.body>
IV Chain#2 Head: (  store i32 %add, i32* %arrayidx4, align 4, !dbg !24, !tbaa !13) IV={((4 * %indvars.iv.ph)<nuw><nsw> + %c)<nuw>,+,4}<nuw><%for.body>
IV Chain#3 Head: (  %exitcond.not = icmp eq i64 %indvars.iv.next, 999, !dbg !34) IV={(1 + %indvars.iv.ph)<nuw><nsw>,+,1}<nuw><nsw><%for.body>
IV Chain#3  Inc: (  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ %indvars.iv.ph, %for.body.preheader ]) IV+0
Chain:   %exitcond.not = icmp eq i64 %indvars.iv.next, 999, !dbg !34 Cost: 1
LSR has identified the following interesting factors and types: *4
LSR is examining the following fixup sites:
  UserInst=%exitcond.not, OperandValToReplace=%indvars.iv.next, PostIncLoop=%for.body
  UserInst=store %add, OperandValToReplace=%arrayidx4
  UserInst=%9, OperandValToReplace=%arrayidx2
  UserInst=%8, OperandValToReplace=%arrayidx
LSR found 4 uses:
LSR is examining the following uses:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i64
    reg({(999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>,+,-1}<nw><%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: i32*
    reg({((4 * %indvars.iv.ph)<nuw><nsw> + %c)<nuw>,+,4}<nuw><%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: i32*
    reg({((4 * %indvars.iv.ph)<nuw><nsw> + %b)<nuw>,+,4}<nuw><%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: i32*
    reg({((4 * %indvars.iv.ph)<nuw><nsw> + %a)<nuw>,+,4}<nuw><%for.body>)
Generating cross-use offsets for {(-1 * %indvars.iv.ph)<nsw>,+,-1}<nw><%for.body>: 0 999
Skipping cross-use reuse for {(-1 * %indvars.iv.ph)<nsw>,+,-1}<nw><%for.body>
Skipping cross-use reuse for {(999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>,+,-1}<nw><%for.body>
Generating cross-use offsets for {0,+,-1}<nw><%for.body>: 0 999
Skipping cross-use reuse for {0,+,-1}<nw><%for.body>
Skipping cross-use reuse for {999,+,-1}<%for.body>
Generating cross-use offsets for (-1 * %indvars.iv.ph)<nsw>: 0 999
Skipping cross-use reuse for (-1 * %indvars.iv.ph)<nsw>
Skipping cross-use reuse for (999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>
Generating cross-use offsets for {%indvars.iv.ph,+,1}<nuw><nsw><%for.body>: -999 0
Skipping cross-use reuse for {(-999 + %indvars.iv.ph)<nuw><nsw>,+,1}<nw><%for.body>
Skipping cross-use reuse for {%indvars.iv.ph,+,1}<nuw><nsw><%for.body>
Generating cross-use offsets for {0,+,1}<nuw><%for.body>: -999 0
Skipping cross-use reuse for {-999,+,1}<%for.body>
Skipping cross-use reuse for {0,+,1}<nuw><%for.body>
Generating cross-use offsets for %indvars.iv.ph: -999 0
Skipping cross-use reuse for (-999 + %indvars.iv.ph)<nuw><nsw>
Skipping cross-use reuse for %indvars.iv.ph

After generating reuse formulae:
LSR is examining the following uses:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i64
    reg({(999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>,+,-1}<nw><%for.body>)
    reg((-1 * %indvars.iv.ph)<nsw>) + 1*reg({999,+,-1}<%for.body>)
    reg((-1 * %indvars.iv.ph)<nsw>) + 1*reg({0,+,-1}<nw><%for.body>) + imm(999)
    reg((999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>) + 1*reg({0,+,-1}<nw><%for.body>)
    999 + reg({(-1 * %indvars.iv.ph)<nsw>,+,-1}<nw><%for.body>)
    reg({(-999 + %indvars.iv.ph)<nuw><nsw>,+,1}<nw><%for.body>)
    reg(%indvars.iv.ph) + 1*reg({-999,+,1}<%for.body>)
    reg(%indvars.iv.ph) + 1*reg({0,+,1}<nuw><%for.body>) + imm(-999)
    reg((-999 + %indvars.iv.ph)<nuw><nsw>) + 1*reg({0,+,1}<nuw><%for.body>)
    -999 + reg({%indvars.iv.ph,+,1}<nuw><nsw><%for.body>)
    reg((-1 * %indvars.iv.ph)<nsw>) + -1*reg({-999,+,1}<%for.body>)
    reg((-1 * %indvars.iv.ph)<nsw>) + -1*reg({0,+,1}<nuw><%for.body>) + imm(999)
    reg((999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>) + -1*reg({0,+,1}<nuw><%for.body>)
    reg(%indvars.iv.ph) + -1*reg({999,+,-1}<%for.body>)
    reg(%indvars.iv.ph) + -1*reg({0,+,-1}<nw><%for.body>) + imm(-999)
    reg((-999 + %indvars.iv.ph)<nuw><nsw>) + -1*reg({0,+,-1}<nw><%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: i32*
    reg({((4 * %indvars.iv.ph)<nuw><nsw> + %c)<nuw>,+,4}<nuw><%for.body>)
    reg((4 * %indvars.iv.ph)<nuw><nsw>) + 1*reg({%c,+,4}<%for.body>)
    reg((4 * %indvars.iv.ph)<nuw><nsw>) + reg(%c) + 1*reg({0,+,4}<%for.body>)
    reg(%c) + 1*reg({(4 * %indvars.iv.ph)<nuw><nsw>,+,4}<nuw><nsw><%for.body>)
    reg(((4 * %indvars.iv.ph)<nuw><nsw> + %c)<nuw>) + 1*reg({0,+,4}<%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: i32*
    reg({((4 * %indvars.iv.ph)<nuw><nsw> + %b)<nuw>,+,4}<nuw><%for.body>)
    reg((4 * %indvars.iv.ph)<nuw><nsw>) + 1*reg({%b,+,4}<%for.body>)
    reg((4 * %indvars.iv.ph)<nuw><nsw>) + reg(%b) + 1*reg({0,+,4}<%for.body>)
    reg(%b) + 1*reg({(4 * %indvars.iv.ph)<nuw><nsw>,+,4}<nuw><nsw><%for.body>)
    reg(((4 * %indvars.iv.ph)<nuw><nsw> + %b)<nuw>) + 1*reg({0,+,4}<%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: i32*
    reg({((4 * %indvars.iv.ph)<nuw><nsw> + %a)<nuw>,+,4}<nuw><%for.body>)
    reg((4 * %indvars.iv.ph)<nuw><nsw>) + 1*reg({%a,+,4}<%for.body>)
    reg((4 * %indvars.iv.ph)<nuw><nsw>) + reg(%a) + 1*reg({0,+,4}<%for.body>)
    reg(%a) + 1*reg({(4 * %indvars.iv.ph)<nuw><nsw>,+,4}<nuw><nsw><%for.body>)
    reg(((4 * %indvars.iv.ph)<nuw><nsw> + %a)<nuw>) + 1*reg({0,+,4}<%for.body>)
Filtering for use LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i64
  Filtering out formula reg((-1 * %indvars.iv.ph)<nsw>) + 1*reg({999,+,-1}<%for.body>)
    in favor of formula reg({(999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>,+,-1}<nw><%for.body>)
  Filtering out formula reg((-999 + %indvars.iv.ph)<nuw><nsw>) + -1*reg({0,+,-1}<nw><%for.body>)
    in favor of formula reg({(999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>,+,-1}<nw><%for.body>)
  Filtering out formula reg(%indvars.iv.ph) + -1*reg({0,+,-1}<nw><%for.body>) + imm(-999)
    in favor of formula reg({(999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>,+,-1}<nw><%for.body>)
  Filtering out formula reg(%indvars.iv.ph) + -1*reg({999,+,-1}<%for.body>)
    in favor of formula reg({(999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>,+,-1}<nw><%for.body>)
  Filtering out formula reg((999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>) + -1*reg({0,+,1}<nuw><%for.body>)
    in favor of formula reg({(999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>,+,-1}<nw><%for.body>)
  Filtering out formula reg((-1 * %indvars.iv.ph)<nsw>) + -1*reg({0,+,1}<nuw><%for.body>) + imm(999)
    in favor of formula reg({(999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>,+,-1}<nw><%for.body>)
  Filtering out formula reg((-1 * %indvars.iv.ph)<nsw>) + -1*reg({-999,+,1}<%for.body>)
    in favor of formula reg({(999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>,+,-1}<nw><%for.body>)
  Filtering out formula -999 + reg({%indvars.iv.ph,+,1}<nuw><nsw><%for.body>)
    in favor of formula reg({(999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>,+,-1}<nw><%for.body>)
  Filtering out formula reg((-999 + %indvars.iv.ph)<nuw><nsw>) + 1*reg({0,+,1}<nuw><%for.body>)
    in favor of formula reg({(999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>,+,-1}<nw><%for.body>)
  Filtering out formula reg(%indvars.iv.ph) + 1*reg({0,+,1}<nuw><%for.body>) + imm(-999)
    in favor of formula reg({(999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>,+,-1}<nw><%for.body>)
  Filtering out formula reg(%indvars.iv.ph) + 1*reg({-999,+,1}<%for.body>)
    in favor of formula reg({(999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>,+,-1}<nw><%for.body>)
  Filtering out formula reg({(999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>,+,-1}<nw><%for.body>)
    in favor of formula reg({(-999 + %indvars.iv.ph)<nuw><nsw>,+,1}<nw><%for.body>)
  Filtering out formula 999 + reg({(-1 * %indvars.iv.ph)<nsw>,+,-1}<nw><%for.body>)
    in favor of formula reg({(-999 + %indvars.iv.ph)<nuw><nsw>,+,1}<nw><%for.body>)
  Filtering out formula reg((999 + (-1 * %indvars.iv.ph)<nsw>)<nsw>) + 1*reg({0,+,-1}<nw><%for.body>)
    in favor of formula reg({(-999 + %indvars.iv.ph)<nuw><nsw>,+,1}<nw><%for.body>)
  Filtering out formula reg((-1 * %indvars.iv.ph)<nsw>) + 1*reg({0,+,-1}<nw><%for.body>) + imm(999)
    in favor of formula reg({(-999 + %indvars.iv.ph)<nuw><nsw>,+,1}<nw><%for.body>)
Filtering for use LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: i32*
Filtering for use LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: i32*
Filtering for use LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: i32*

After filtering out undesirable candidates:
LSR is examining the following uses:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i64
    reg({(-999 + %indvars.iv.ph)<nuw><nsw>,+,1}<nw><%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: i32*
    reg({((4 * %indvars.iv.ph)<nuw><nsw> + %c)<nuw>,+,4}<nuw><%for.body>)
    reg((4 * %indvars.iv.ph)<nuw><nsw>) + 1*reg({%c,+,4}<%for.body>)
    reg((4 * %indvars.iv.ph)<nuw><nsw>) + reg(%c) + 1*reg({0,+,4}<%for.body>)
    reg(%c) + 1*reg({(4 * %indvars.iv.ph)<nuw><nsw>,+,4}<nuw><nsw><%for.body>)
    reg(((4 * %indvars.iv.ph)<nuw><nsw> + %c)<nuw>) + 1*reg({0,+,4}<%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: i32*
    reg({((4 * %indvars.iv.ph)<nuw><nsw> + %b)<nuw>,+,4}<nuw><%for.body>)
    reg((4 * %indvars.iv.ph)<nuw><nsw>) + 1*reg({%b,+,4}<%for.body>)
    reg((4 * %indvars.iv.ph)<nuw><nsw>) + reg(%b) + 1*reg({0,+,4}<%for.body>)
    reg(%b) + 1*reg({(4 * %indvars.iv.ph)<nuw><nsw>,+,4}<nuw><nsw><%for.body>)
    reg(((4 * %indvars.iv.ph)<nuw><nsw> + %b)<nuw>) + 1*reg({0,+,4}<%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: i32*
    reg({((4 * %indvars.iv.ph)<nuw><nsw> + %a)<nuw>,+,4}<nuw><%for.body>)
    reg((4 * %indvars.iv.ph)<nuw><nsw>) + 1*reg({%a,+,4}<%for.body>)
    reg((4 * %indvars.iv.ph)<nuw><nsw>) + reg(%a) + 1*reg({0,+,4}<%for.body>)
    reg(%a) + 1*reg({(4 * %indvars.iv.ph)<nuw><nsw>,+,4}<nuw><nsw><%for.body>)
    reg(((4 * %indvars.iv.ph)<nuw><nsw> + %a)<nuw>) + 1*reg({0,+,4}<%for.body>)
New best at 4 instructions 4 regs, with addrec cost 4, plus 11 setup cost.
Regs:
- {(-999 + %indvars.iv.ph)<nuw><nsw>,+,1}<nw><%for.body>
- {((4 * %indvars.iv.ph)<nuw><nsw> + %c)<nuw>,+,4}<nuw><%for.body>
- {((4 * %indvars.iv.ph)<nuw><nsw> + %b)<nuw>,+,4}<nuw><%for.body>
- {((4 * %indvars.iv.ph)<nuw><nsw> + %a)<nuw>,+,4}<nuw><%for.body>


The chosen solution requires 4 instructions 4 regs, with addrec cost 4, plus 11 setup cost:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i64
    reg({(-999 + %indvars.iv.ph)<nuw><nsw>,+,1}<nw><%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: i32*
    reg({((4 * %indvars.iv.ph)<nuw><nsw> + %c)<nuw>,+,4}<nuw><%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: i32*
    reg({((4 * %indvars.iv.ph)<nuw><nsw> + %b)<nuw>,+,4}<nuw><%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: i32*
    reg({((4 * %indvars.iv.ph)<nuw><nsw> + %a)<nuw>,+,4}<nuw><%for.body>)
canonfr: PHI:   %index = phi i64 [ %index.next, %vector.body ], [ 0, %vector.body.preheader ], !dbg !11
FOUND USER:   %8 = icmp eq i64 %index.next, 960, !dbg !11
   OF SCEV: {64,+,64}<nuw><%vector.body>
FOUND USER:   store <64 x i32> %5, <64 x i32>* %7, align 4, !dbg !24, !tbaa !13, !alias.scope !25, !noalias !27
   OF SCEV: {%c,+,256}<nuw><%vector.body>
FOUND USER:   %wide.load22 = load <64 x i32>, <64 x i32>* %4, align 4, !dbg !20, !tbaa !13, !alias.scope !21
   OF SCEV: {%b,+,256}<nuw><%vector.body>
FOUND USER:   %wide.load = load <64 x i32>, <64 x i32>* %2, align 4, !dbg !12, !tbaa !13, !alias.scope !17
   OF SCEV: {%a,+,256}<nuw><%vector.body>

LSR on loop %vector.body:
  Change loop exiting icmp to use postinc iv:   %8 = icmp eq i64 %index.next, 960, !dbg !11
Collecting IV Chains.
IV Chain#0 Head: (  %wide.load = load <64 x i32>, <64 x i32>* %2, align 4, !dbg !12, !tbaa !13, !alias.scope !17) IV={%a,+,256}<nuw><%vector.body>
IV Chain#1 Head: (  %wide.load22 = load <64 x i32>, <64 x i32>* %4, align 4, !dbg !20, !tbaa !13, !alias.scope !21) IV={%b,+,256}<nuw><%vector.body>
IV Chain#2 Head: (  store <64 x i32> %5, <64 x i32>* %7, align 4, !dbg !24, !tbaa !13, !alias.scope !25, !noalias !27) IV={%c,+,256}<nuw><%vector.body>
IV Chain#3 Head: (  %8 = icmp eq i64 %index.next, 960, !dbg !11) IV={64,+,64}<nuw><%vector.body>
IV Chain#3  Inc: (  %index = phi i64 [ %index.next, %vector.body ], [ 0, %vector.body.preheader ], !dbg !11) IV+0
Chain:   %8 = icmp eq i64 %index.next, 960, !dbg !11 Cost: 1
LSR has identified the following interesting factors and types: *4
LSR is examining the following fixup sites:
  UserInst=%8, OperandValToReplace=%index.next, PostIncLoop=%vector.body
  UserInst=store %5, OperandValToReplace=%7
  UserInst=%wide.load22, OperandValToReplace=%4
  UserInst=%wide.load, OperandValToReplace=%2
LSR found 4 uses:
LSR is examining the following uses:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i64
    reg({960,+,-64}<nw><%vector.body>)
  LSR Use: Kind=Address of <64 x i32> in addrspace(0), Offsets={0}, widest fixup type: <64 x i32>*
    reg({%c,+,256}<nuw><%vector.body>)
  LSR Use: Kind=Address of <64 x i32> in addrspace(0), Offsets={0}, widest fixup type: <64 x i32>*
    reg({%b,+,256}<nuw><%vector.body>)
  LSR Use: Kind=Address of <64 x i32> in addrspace(0), Offsets={0}, widest fixup type: <64 x i32>*
    reg({%a,+,256}<nuw><%vector.body>)
Generating cross-use offsets for {0,+,-64}<nw><%vector.body>: 0 960
Skipping cross-use reuse for {0,+,-64}<nw><%vector.body>
Skipping cross-use reuse for {960,+,-64}<nw><%vector.body>
Generating cross-use offsets for {0,+,256}<nuw><%vector.body>: -3840 0
Generating cross-use offsets for {0,+,64}<nuw><%vector.body>: -960 0
Skipping cross-use reuse for {-960,+,64}<nw><%vector.body>
Skipping cross-use reuse for {0,+,64}<nuw><%vector.body>

After generating reuse formulae:
LSR is examining the following uses:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i64
    reg({960,+,-64}<nw><%vector.body>)
    960 + reg({0,+,-64}<nw><%vector.body>)
    reg({3840,+,-256}<nsw><%vector.body>)
    reg({-3840,+,256}<nsw><%vector.body>)
    reg({-960,+,64}<nw><%vector.body>)
    -960 + reg({0,+,64}<nuw><%vector.body>)
  LSR Use: Kind=Address of <64 x i32> in addrspace(0), Offsets={0}, widest fixup type: <64 x i32>*
    reg({%c,+,256}<nuw><%vector.body>)
    reg(%c) + 1*reg({0,+,256}<nuw><%vector.body>)
  LSR Use: Kind=Address of <64 x i32> in addrspace(0), Offsets={0}, widest fixup type: <64 x i32>*
    reg({%b,+,256}<nuw><%vector.body>)
    reg(%b) + 1*reg({0,+,256}<nuw><%vector.body>)
  LSR Use: Kind=Address of <64 x i32> in addrspace(0), Offsets={0}, widest fixup type: <64 x i32>*
    reg({%a,+,256}<nuw><%vector.body>)
    reg(%a) + 1*reg({0,+,256}<nuw><%vector.body>)
Filtering for use LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i64
  Filtering out formula 960 + reg({0,+,-64}<nw><%vector.body>)
    in favor of formula reg({960,+,-64}<nw><%vector.body>)
  Filtering out formula -960 + reg({0,+,64}<nuw><%vector.body>)
    in favor of formula reg({960,+,-64}<nw><%vector.body>)
  Filtering out formula reg({-960,+,64}<nw><%vector.body>)
    in favor of formula reg({960,+,-64}<nw><%vector.body>)
  Filtering out formula reg({-3840,+,256}<nsw><%vector.body>)
    in favor of formula reg({960,+,-64}<nw><%vector.body>)
  Filtering out formula reg({3840,+,-256}<nsw><%vector.body>)
    in favor of formula reg({960,+,-64}<nw><%vector.body>)
Filtering for use LSR Use: Kind=Address of <64 x i32> in addrspace(0), Offsets={0}, widest fixup type: <64 x i32>*
Filtering for use LSR Use: Kind=Address of <64 x i32> in addrspace(0), Offsets={0}, widest fixup type: <64 x i32>*
Filtering for use LSR Use: Kind=Address of <64 x i32> in addrspace(0), Offsets={0}, widest fixup type: <64 x i32>*

After filtering out undesirable candidates:
LSR is examining the following uses:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i64
    reg({960,+,-64}<nw><%vector.body>)
  LSR Use: Kind=Address of <64 x i32> in addrspace(0), Offsets={0}, widest fixup type: <64 x i32>*
    reg({%c,+,256}<nuw><%vector.body>)
    reg(%c) + 1*reg({0,+,256}<nuw><%vector.body>)
  LSR Use: Kind=Address of <64 x i32> in addrspace(0), Offsets={0}, widest fixup type: <64 x i32>*
    reg({%b,+,256}<nuw><%vector.body>)
    reg(%b) + 1*reg({0,+,256}<nuw><%vector.body>)
  LSR Use: Kind=Address of <64 x i32> in addrspace(0), Offsets={0}, widest fixup type: <64 x i32>*
    reg({%a,+,256}<nuw><%vector.body>)
    reg(%a) + 1*reg({0,+,256}<nuw><%vector.body>)
New best at 4 instructions 4 regs, with addrec cost 4, plus 4 setup cost.
Regs:
- {960,+,-64}<nw><%vector.body>
- {%c,+,256}<nuw><%vector.body>
- {%b,+,256}<nuw><%vector.body>
- {%a,+,256}<nuw><%vector.body>


The chosen solution requires 4 instructions 4 regs, with addrec cost 4, plus 4 setup cost:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i64
    reg({960,+,-64}<nw><%vector.body>)
  LSR Use: Kind=Address of <64 x i32> in addrspace(0), Offsets={0}, widest fixup type: <64 x i32>*
    reg({%c,+,256}<nuw><%vector.body>)
  LSR Use: Kind=Address of <64 x i32> in addrspace(0), Offsets={0}, widest fixup type: <64 x i32>*
    reg({%b,+,256}<nuw><%vector.body>)
  LSR Use: Kind=Address of <64 x i32> in addrspace(0), Offsets={0}, widest fixup type: <64 x i32>*
    reg({%a,+,256}<nuw><%vector.body>)
MergeICmpsLegacyPass: add
		Looking for trivial roots
Found a new trivial root: %for.cond.cleanup
Last visited node: %vector.body.preheader
		Looking for non-trivial roots
Total: 7, Num: 8
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.cond.cleanup
3: %for.body
4: %for.body.preheader
5: %entry
6: %for.body.preheader.loopexit
7: %vector.body
8: %vector.body.preheader
Found roots: %for.cond.cleanup 
---- Branch Probability Info : add ----

Computing probabilities for for.cond.cleanup
Computing probabilities for for.body
eraseBlock for.body
set edge for.body -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge for.body -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for for.body.preheader
Computing probabilities for for.body.preheader.loopexit
Computing probabilities for vector.body
eraseBlock vector.body
set edge vector.body -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge vector.body -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for vector.body.preheader
Computing probabilities for entry

block-frequency: add
====================
reverse-post-order-traversal
 - 0: entry
 - 1: vector.body.preheader
 - 2: vector.body
 - 3: for.body.preheader.loopexit
 - 4: for.body.preheader
 - 5: for.body
 - 6: for.cond.cleanup
loop-detection
 - loop = for.body
 - loop = vector.body
compute-mass-in-loop: vector.body*
 - node: vector.body
  => [  exit  ] weight = 67108864, succ = for.body.preheader.loopexit
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to vector.body
  => assign 0800000000000000 (0000000000000000) [exit] to for.body.preheader.loopexit
compute-loop-scale: vector.body*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: vector.body*
 - node: vector.body
compute-mass-in-loop: for.body*
 - node: for.body
  => [  exit  ] weight = 67108864, succ = for.cond.cleanup
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body
  => assign 0800000000000000 (0000000000000000) [exit] to for.cond.cleanup
compute-loop-scale: for.body*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body*
 - node: for.body
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 1073741824, succ = for.body.preheader
  => [ local  ] weight = 1073741824, succ = vector.body.preheader
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to vector.body.preheader
  => assign 8000000000000000 (0000000000000000) to for.body.preheader
 - node: vector.body.preheader
  => [ local  ] weight = 2147483648, succ = vector.body
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to vector.body
 - node: vector.body
  => [ local  ] weight = 576460752303423488, succ = for.body.preheader.loopexit
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.body.preheader.loopexit
 - node: for.body.preheader.loopexit
  => [ local  ] weight = 2147483648, succ = for.body.preheader
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.body.preheader
 - node: for.body.preheader
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 576460752303423488, succ = for.cond.cleanup
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.cond.cleanup
 - node: for.cond.cleanup
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - for.body: 1.0 => 32.0
unwrap-loop-package: vector.body*: mass = 7fffffffffffffff, scale = 32.0
  => combined-scale = 16.0
 - vector.body: 1.0 => 16.0
float-to-int: min = 0.5, max = 32.0, factor = 16.0
 - entry: float = 1.0, scaled = 16.0, int = 16
 - vector.body.preheader: float = 0.5, scaled = 8.0, int = 8
 - vector.body: float = 16.0, scaled = 256.0, int = 255
 - for.body.preheader.loopexit: float = 0.5, scaled = 8.0, int = 8
 - for.body.preheader: float = 1.0, scaled = 16.0, int = 16
 - for.body: float = 32.0, scaled = 512.0, int = 511
 - for.cond.cleanup: float = 1.0, scaled = 16.0, int = 16
block-frequency-info: add
 - entry: float = 1.0, int = 16
 - vector.body.preheader: float = 0.5, int = 8
 - for.body.preheader.loopexit: float = 0.5, int = 8
 - for.body.preheader: float = 1.0, int = 16
 - vector.body: float = 16.0, int = 255
 - for.cond.cleanup: float = 1.0, int = 16
 - for.body: float = 32.0, int = 511

********** Begin Constant Hoisting **********
********** Function: add
********** End Constant Hoisting **********
---- Branch Probability Info : add ----

		Looking for trivial roots
Found a new trivial root: %for.cond.cleanup
Last visited node: %vector.body.preheader
		Looking for non-trivial roots
Total: 7, Num: 8
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.cond.cleanup
3: %for.body
4: %for.body.preheader
5: %entry
6: %for.body.preheader.loopexit
7: %vector.body
8: %vector.body.preheader
Found roots: %for.cond.cleanup 
Computing probabilities for for.cond.cleanup
Computing probabilities for for.body
eraseBlock for.body
set edge for.body -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge for.body -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for for.body.preheader
Computing probabilities for for.body.preheader.loopexit
Computing probabilities for vector.body
eraseBlock vector.body
set edge vector.body -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge vector.body -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for vector.body.preheader
Computing probabilities for entry

block-frequency: add
====================
reverse-post-order-traversal
 - 0: entry
 - 1: vector.body.preheader
 - 2: vector.body
 - 3: for.body.preheader.loopexit
 - 4: for.body.preheader
 - 5: for.body
 - 6: for.cond.cleanup
loop-detection
 - loop = for.body
 - loop = vector.body
compute-mass-in-loop: vector.body*
 - node: vector.body
  => [  exit  ] weight = 67108864, succ = for.body.preheader.loopexit
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to vector.body
  => assign 0800000000000000 (0000000000000000) [exit] to for.body.preheader.loopexit
compute-loop-scale: vector.body*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: vector.body*
 - node: vector.body
compute-mass-in-loop: for.body*
 - node: for.body
  => [  exit  ] weight = 67108864, succ = for.cond.cleanup
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body
  => assign 0800000000000000 (0000000000000000) [exit] to for.cond.cleanup
compute-loop-scale: for.body*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body*
 - node: for.body
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 1073741824, succ = for.body.preheader
  => [ local  ] weight = 1073741824, succ = vector.body.preheader
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to vector.body.preheader
  => assign 8000000000000000 (0000000000000000) to for.body.preheader
 - node: vector.body.preheader
  => [ local  ] weight = 2147483648, succ = vector.body
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to vector.body
 - node: vector.body
  => [ local  ] weight = 576460752303423488, succ = for.body.preheader.loopexit
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.body.preheader.loopexit
 - node: for.body.preheader.loopexit
  => [ local  ] weight = 2147483648, succ = for.body.preheader
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.body.preheader
 - node: for.body.preheader
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 576460752303423488, succ = for.cond.cleanup
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.cond.cleanup
 - node: for.cond.cleanup
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - for.body: 1.0 => 32.0
unwrap-loop-package: vector.body*: mass = 7fffffffffffffff, scale = 32.0
  => combined-scale = 16.0
 - vector.body: 1.0 => 16.0
float-to-int: min = 0.5, max = 32.0, factor = 16.0
 - entry: float = 1.0, scaled = 16.0, int = 16
 - vector.body.preheader: float = 0.5, scaled = 8.0, int = 8
 - vector.body: float = 16.0, scaled = 256.0, int = 255
 - for.body.preheader.loopexit: float = 0.5, scaled = 8.0, int = 8
 - for.body.preheader: float = 1.0, scaled = 16.0, int = 16
 - for.body: float = 32.0, scaled = 512.0, int = 511
 - for.cond.cleanup: float = 1.0, scaled = 16.0, int = 16
block-frequency-info: add
 - entry: float = 1.0, int = 16
 - vector.body.preheader: float = 0.5, int = 8
 - for.body.preheader.loopexit: float = 0.5, int = 8
 - for.body.preheader: float = 1.0, int = 16
 - vector.body: float = 16.0, int = 255
 - for.cond.cleanup: float = 1.0, int = 16
 - for.body: float = 32.0, int = 511

MERGING MOSTLY EMPTY BLOCKS - BEFORE:

for.body.preheader.loopexit:                      ; preds = %vector.body
  br label %for.body.preheader, !dbg !10

for.body.preheader:                               ; preds = %for.body.preheader.loopexit, %entry
  %indvars.iv.ph = phi i64 [ 0, %entry ], [ 960, %for.body.preheader.loopexit ]
  %0 = add nuw nsw i64 %indvars.iv.ph, -999, !dbg !10
  %scevgep1 = getelementptr i32, i32* %c, i64 %indvars.iv.ph, !dbg !10
  %scevgep4 = getelementptr i32, i32* %b, i64 %indvars.iv.ph, !dbg !10
  %scevgep7 = getelementptr i32, i32* %a, i64 %indvars.iv.ph, !dbg !10
  br label %for.body, !dbg !10
AFTER:

for.body.preheader:                               ; preds = %vector.body, %entry
  %indvars.iv.ph = phi i64 [ 0, %entry ], [ 960, %vector.body ]
  %0 = add nuw nsw i64 %indvars.iv.ph, -999, !dbg !10
  %scevgep1 = getelementptr i32, i32* %c, i64 %indvars.iv.ph, !dbg !10
  %scevgep4 = getelementptr i32, i32* %b, i64 %indvars.iv.ph, !dbg !10
  %scevgep7 = getelementptr i32, i32* %a, i64 %indvars.iv.ph, !dbg !10
  br label %for.body, !dbg !10



CGP: Found      local addrmode: [inbounds Base:%lsr.iv18]
CGP: Found      local addrmode: [inbounds Base:%lsr.iv15]
CGP: Found      local addrmode: [inbounds Base:%lsr.iv12]
CGP: Found      local addrmode: [inbounds Base:%lsr.iv18]
CGP: Found      local addrmode: [inbounds Base:%lsr.iv15]
CGP: Found      local addrmode: [inbounds Base:%lsr.iv12]
[SafeStack] Function: add
[SafeStack]     safestack is not requested for this function
		Looking for trivial roots
Found a new trivial root: %for.cond.cleanup
Last visited node: %vector.body.preheader
		Looking for non-trivial roots
Total: 6, Num: 7
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.cond.cleanup
3: %for.body
4: %for.body.preheader
5: %entry
6: %vector.body
7: %vector.body.preheader
Found roots: %for.cond.cleanup 
---- Branch Probability Info : add ----

Computing probabilities for for.cond.cleanup
Computing probabilities for for.body
eraseBlock for.body
set edge for.body -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge for.body -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for for.body.preheader
Computing probabilities for vector.body
eraseBlock vector.body
set edge vector.body -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge vector.body -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for vector.body.preheader
Computing probabilities for entry



=== add
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %21
Creating new node: t4: i64,ch = CopyFromReg t0, Register:i64 %22
Creating new node: t6: i64,ch = CopyFromReg t0, Register:i64 %23
Creating constant: t7: i64 = Constant<3996>
Creating new node: t8: i64 = add t6, Constant:i64<3996>, test_addarray.c:7:2
Creating new node: t9: i64 = add t2, Constant:i64<3996>, test_addarray.c:7:2
Creating new node: t10: i64 = add t4, Constant:i64<3996>, test_addarray.c:7:2
Creating new node: t12: i1 = setcc t9, t6, setugt:ch, test_addarray.c:7:2
Creating new node: t13: i1 = setcc t8, t2, setugt:ch, test_addarray.c:7:2
Creating new node: t14: i1 = and t12, t13, test_addarray.c:7:2
Creating new node: t15: i1 = setcc t10, t6, setugt:ch, test_addarray.c:7:2
Creating new node: t16: i1 = setcc t8, t4, setugt:ch, test_addarray.c:7:2
Creating new node: t17: i1 = and t15, t16, test_addarray.c:7:2
Creating new node: t18: i1 = or t14, t17, test_addarray.c:7:2
Creating constant: t19: i64 = Constant<0>
Creating new node: t21: ch = CopyToReg t0, Register:i64 %24, Constant:i64<0>
Creating new node: t23: ch = brcond t21, t18, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2
Creating new node: t25: ch = br t23, BasicBlock:ch<vector.body.preheader 0xe2a828>, test_addarray.c:7:2
Initial selection DAG: %bb.0 'add:entry'
SelectionDAG has 26 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %21
  t4: i64,ch = CopyFromReg t0, Register:i64 %22
  t6: i64,ch = CopyFromReg t0, Register:i64 %23
  t8: i64 = add t6, Constant:i64<3996>, test_addarray.c:7:2
      t21: ch = CopyToReg t0, Register:i64 %24, Constant:i64<0>
            t9: i64 = add t2, Constant:i64<3996>, test_addarray.c:7:2
          t12: i1 = setcc t9, t6, setugt:ch, test_addarray.c:7:2
          t13: i1 = setcc t8, t2, setugt:ch, test_addarray.c:7:2
        t14: i1 = and t12, t13, test_addarray.c:7:2
            t10: i64 = add t4, Constant:i64<3996>, test_addarray.c:7:2
          t15: i1 = setcc t10, t6, setugt:ch, test_addarray.c:7:2
          t16: i1 = setcc t8, t4, setugt:ch, test_addarray.c:7:2
        t17: i1 = and t15, t16, test_addarray.c:7:2
      t18: i1 = or t14, t17, test_addarray.c:7:2
    t23: ch = brcond t21, t18, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2
  t25: ch = br t23, BasicBlock:ch<vector.body.preheader 0xe2a828>, test_addarray.c:7:2



Combining: t25: ch = br t23, BasicBlock:ch<vector.body.preheader 0xe2a828>, test_addarray.c:7:2

Combining: t24: ch = BasicBlock<vector.body.preheader 0xe2a828>

Combining: t23: ch = brcond t21, t18, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2

Combining: t22: ch = BasicBlock<for.body.preheader 0xe2a908>

Combining: t21: ch = CopyToReg t0, Register:i64 %24, Constant:i64<0>

Combining: t20: i64 = Register %24

Combining: t19: i64 = Constant<0>

Combining: t18: i1 = or t14, t17, test_addarray.c:7:2

Combining: t17: i1 = and t15, t16, test_addarray.c:7:2

Combining: t16: i1 = setcc t8, t4, setugt:ch, test_addarray.c:7:2

Combining: t15: i1 = setcc t10, t6, setugt:ch, test_addarray.c:7:2

Combining: t14: i1 = and t12, t13, test_addarray.c:7:2

Combining: t13: i1 = setcc t8, t2, setugt:ch, test_addarray.c:7:2

Combining: t12: i1 = setcc t9, t6, setugt:ch, test_addarray.c:7:2

Combining: t11: ch = setugt

Combining: t10: i64 = add t4, Constant:i64<3996>, test_addarray.c:7:2

Combining: t9: i64 = add t2, Constant:i64<3996>, test_addarray.c:7:2

Combining: t8: i64 = add t6, Constant:i64<3996>, test_addarray.c:7:2

Combining: t7: i64 = Constant<3996>

Combining: t6: i64,ch = CopyFromReg t0, Register:i64 %23

Combining: t5: i64 = Register %23

Combining: t4: i64,ch = CopyFromReg t0, Register:i64 %22

Combining: t3: i64 = Register %22

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %21

Combining: t1: i64 = Register %21

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 'add:entry'
SelectionDAG has 26 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %21
  t4: i64,ch = CopyFromReg t0, Register:i64 %22
  t6: i64,ch = CopyFromReg t0, Register:i64 %23
  t8: i64 = add t6, Constant:i64<3996>, test_addarray.c:7:2
      t21: ch = CopyToReg t0, Register:i64 %24, Constant:i64<0>
            t9: i64 = add t2, Constant:i64<3996>, test_addarray.c:7:2
          t12: i1 = setcc t9, t6, setugt:ch, test_addarray.c:7:2
          t13: i1 = setcc t8, t2, setugt:ch, test_addarray.c:7:2
        t14: i1 = and t12, t13, test_addarray.c:7:2
            t10: i64 = add t4, Constant:i64<3996>, test_addarray.c:7:2
          t15: i1 = setcc t10, t6, setugt:ch, test_addarray.c:7:2
          t16: i1 = setcc t8, t4, setugt:ch, test_addarray.c:7:2
        t17: i1 = and t15, t16, test_addarray.c:7:2
      t18: i1 = or t14, t17, test_addarray.c:7:2
    t23: ch = brcond t21, t18, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2
  t25: ch = br t23, BasicBlock:ch<vector.body.preheader 0xe2a828>, test_addarray.c:7:2


Legalizing node: t24: ch = BasicBlock<vector.body.preheader 0xe2a828>
Analyzing result type: ch
Legal result type
Legally typed node: t24: ch = BasicBlock<vector.body.preheader 0xe2a828>

Legalizing node: t22: ch = BasicBlock<for.body.preheader 0xe2a908>
Analyzing result type: ch
Legal result type
Legally typed node: t22: ch = BasicBlock<for.body.preheader 0xe2a908>

Legalizing node: t20: i64 = Register %24
Ignoring node results
Legally typed node: t20: i64 = Register %24

Legalizing node: t19: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t19: i64 = Constant<0>

Legalizing node: t11: ch = setugt
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = setugt

Legalizing node: t7: i64 = Constant<3996>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = Constant<3996>

Legalizing node: t5: i64 = Register %23
Ignoring node results
Legally typed node: t5: i64 = Register %23

Legalizing node: t3: i64 = Register %22
Ignoring node results
Legally typed node: t3: i64 = Register %22

Legalizing node: t1: i64 = Register %21
Ignoring node results
Legally typed node: t1: i64 = Register %21

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %21
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %21

Legalizing node: t9: i64 = add t2, Constant:i64<3996>, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %21
Legal operand
Analyzing operand: t7: i64 = Constant<3996>
Legal operand
Legally typed node: t9: i64 = add t2, Constant:i64<3996>, test_addarray.c:7:2

Legalizing node: t4: i64,ch = CopyFromReg t0, Register:i64 %22
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t4: i64,ch = CopyFromReg t0, Register:i64 %22

Legalizing node: t10: i64 = add t4, Constant:i64<3996>, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t4: i64,ch = CopyFromReg t0, Register:i64 %22
Legal operand
Analyzing operand: t7: i64 = Constant<3996>
Legal operand
Legally typed node: t10: i64 = add t4, Constant:i64<3996>, test_addarray.c:7:2

Legalizing node: t6: i64,ch = CopyFromReg t0, Register:i64 %23
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t6: i64,ch = CopyFromReg t0, Register:i64 %23

Legalizing node: t8: i64 = add t6, Constant:i64<3996>, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t6: i64,ch = CopyFromReg t0, Register:i64 %23
Legal operand
Analyzing operand: t7: i64 = Constant<3996>
Legal operand
Legally typed node: t8: i64 = add t6, Constant:i64<3996>, test_addarray.c:7:2

Legalizing node: t13: i1 = setcc t8, t2, setugt:ch, test_addarray.c:7:2
Analyzing result type: i1
Promote integer result: t13: i1 = setcc t8, t2, setugt:ch, test_addarray.c:7:2

Creating new node: t26: i64 = setcc t8, t2, setugt:ch, test_addarray.c:7:2
Legalizing node: t26: i64 = setcc t8, t2, setugt:ch, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t8: i64 = add t6, Constant:i64<3996>, test_addarray.c:7:2
Legal operand
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %21
Legal operand
Analyzing operand: t11: ch = setugt
Legal operand
Legally typed node: t26: i64 = setcc t8, t2, setugt:ch, test_addarray.c:7:2

Legalizing node: t16: i1 = setcc t8, t4, setugt:ch, test_addarray.c:7:2
Analyzing result type: i1
Promote integer result: t16: i1 = setcc t8, t4, setugt:ch, test_addarray.c:7:2

Creating new node: t27: i64 = setcc t8, t4, setugt:ch, test_addarray.c:7:2
Legalizing node: t27: i64 = setcc t8, t4, setugt:ch, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t8: i64 = add t6, Constant:i64<3996>, test_addarray.c:7:2
Legal operand
Analyzing operand: t4: i64,ch = CopyFromReg t0, Register:i64 %22
Legal operand
Analyzing operand: t11: ch = setugt
Legal operand
Legally typed node: t27: i64 = setcc t8, t4, setugt:ch, test_addarray.c:7:2

Legalizing node: t12: i1 = setcc t9, t6, setugt:ch, test_addarray.c:7:2
Analyzing result type: i1
Promote integer result: t12: i1 = setcc t9, t6, setugt:ch, test_addarray.c:7:2

Creating new node: t28: i64 = setcc t9, t6, setugt:ch, test_addarray.c:7:2
Legalizing node: t14: i1 = and t12, t13, test_addarray.c:7:2
Analyzing result type: i1
Promote integer result: t14: i1 = and t12, t13, test_addarray.c:7:2

Creating new node: t29: i64 = and t28, t26, test_addarray.c:7:2
Legalizing node: t28: i64 = setcc t9, t6, setugt:ch, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64 = add t2, Constant:i64<3996>, test_addarray.c:7:2
Legal operand
Analyzing operand: t6: i64,ch = CopyFromReg t0, Register:i64 %23
Legal operand
Analyzing operand: t11: ch = setugt
Legal operand
Legally typed node: t28: i64 = setcc t9, t6, setugt:ch, test_addarray.c:7:2

Legalizing node: t29: i64 = and t28, t26, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t28: i64 = setcc t9, t6, setugt:ch, test_addarray.c:7:2
Legal operand
Analyzing operand: t26: i64 = setcc t8, t2, setugt:ch, test_addarray.c:7:2
Legal operand
Legally typed node: t29: i64 = and t28, t26, test_addarray.c:7:2

Legalizing node: t15: i1 = setcc t10, t6, setugt:ch, test_addarray.c:7:2
Analyzing result type: i1
Promote integer result: t15: i1 = setcc t10, t6, setugt:ch, test_addarray.c:7:2

Creating new node: t30: i64 = setcc t10, t6, setugt:ch, test_addarray.c:7:2
Legalizing node: t17: i1 = and t15, t16, test_addarray.c:7:2
Analyzing result type: i1
Promote integer result: t17: i1 = and t15, t16, test_addarray.c:7:2

Creating new node: t31: i64 = and t30, t27, test_addarray.c:7:2
Legalizing node: t18: i1 = or t14, t17, test_addarray.c:7:2
Analyzing result type: i1
Promote integer result: t18: i1 = or t14, t17, test_addarray.c:7:2

Creating new node: t32: i64 = or t29, t31, test_addarray.c:7:2
Legalizing node: t30: i64 = setcc t10, t6, setugt:ch, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t10: i64 = add t4, Constant:i64<3996>, test_addarray.c:7:2
Legal operand
Analyzing operand: t6: i64,ch = CopyFromReg t0, Register:i64 %23
Legal operand
Analyzing operand: t11: ch = setugt
Legal operand
Legally typed node: t30: i64 = setcc t10, t6, setugt:ch, test_addarray.c:7:2

Legalizing node: t31: i64 = and t30, t27, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t30: i64 = setcc t10, t6, setugt:ch, test_addarray.c:7:2
Legal operand
Analyzing operand: t27: i64 = setcc t8, t4, setugt:ch, test_addarray.c:7:2
Legal operand
Legally typed node: t31: i64 = and t30, t27, test_addarray.c:7:2

Legalizing node: t32: i64 = or t29, t31, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t29: i64 = and t28, t26, test_addarray.c:7:2
Legal operand
Analyzing operand: t31: i64 = and t30, t27, test_addarray.c:7:2
Legal operand
Legally typed node: t32: i64 = or t29, t31, test_addarray.c:7:2

Legalizing node: t21: ch = CopyToReg t0, Register:i64 %24, Constant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t19: i64 = Constant<0>
Legal operand
Legally typed node: t21: ch = CopyToReg t0, Register:i64 %24, Constant:i64<0>

Legalizing node: t23: ch = brcond t21, t18, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2
Analyzing result type: ch
Legal result type
Analyzing operand: t21: ch = CopyToReg t0, Register:i64 %24, Constant:i64<0>
Legal operand
Analyzing operand: t18: i1 = or t14, t17, test_addarray.c:7:2
Promote integer operand: t23: ch = brcond t21, t18, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2

Creating new node: t33: i64 = zero_extend t18, test_addarray.c:7:2
Legalizing node: t33: i64 = zero_extend t18, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t18: i1 = or t14, t17, test_addarray.c:7:2
Promote integer operand: t33: i64 = zero_extend t18, test_addarray.c:7:2

Creating constant: t34: i64 = Constant<1>
Creating new node: t35: i64 = and t32, Constant:i64<1>, test_addarray.c:7:2
Replacing: t33: i64 = zero_extend t18, test_addarray.c:7:2
     with: t35: i64 = and t32, Constant:i64<1>, test_addarray.c:7:2
Legalizing node: t34: i64 = Constant<1>
Analyzing result type: i64
Legal result type
Legally typed node: t34: i64 = Constant<1>

Legalizing node: t35: i64 = and t32, Constant:i64<1>, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t32: i64 = or t29, t31, test_addarray.c:7:2
Legal operand
Analyzing operand: t34: i64 = Constant<1>
Legal operand
Legally typed node: t35: i64 = and t32, Constant:i64<1>, test_addarray.c:7:2

Legalizing node: t23: ch = brcond t21, t35, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2
Analyzing result type: ch
Legal result type
Analyzing operand: t21: ch = CopyToReg t0, Register:i64 %24, Constant:i64<0>
Legal operand
Analyzing operand: t35: i64 = and t32, Constant:i64<1>, test_addarray.c:7:2
Legal operand
Analyzing operand: t22: ch = BasicBlock<for.body.preheader 0xe2a908>
Legal operand
Legally typed node: t23: ch = brcond t21, t35, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2

Legalizing node: t25: ch = br t23, BasicBlock:ch<vector.body.preheader 0xe2a828>, test_addarray.c:7:2
Analyzing result type: ch
Legal result type
Analyzing operand: t23: ch = brcond t21, t35, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2
Legal operand
Analyzing operand: t24: ch = BasicBlock<vector.body.preheader 0xe2a828>
Legal operand
Legally typed node: t25: ch = br t23, BasicBlock:ch<vector.body.preheader 0xe2a828>, test_addarray.c:7:2

Legalizing node: t65535: ch = handlenode t25
Analyzing result type: ch
Legal result type
Analyzing operand: t25: ch = br t23, BasicBlock:ch<vector.body.preheader 0xe2a828>, test_addarray.c:7:2
Legal operand
Legally typed node: t65535: ch = handlenode t25

Type-legalized selection DAG: %bb.0 'add:entry'
SelectionDAG has 28 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %21
  t4: i64,ch = CopyFromReg t0, Register:i64 %22
  t6: i64,ch = CopyFromReg t0, Register:i64 %23
  t8: i64 = add t6, Constant:i64<3996>, test_addarray.c:7:2
      t21: ch = CopyToReg t0, Register:i64 %24, Constant:i64<0>
              t9: i64 = add t2, Constant:i64<3996>, test_addarray.c:7:2
            t28: i64 = setcc t9, t6, setugt:ch, test_addarray.c:7:2
            t26: i64 = setcc t8, t2, setugt:ch, test_addarray.c:7:2
          t29: i64 = and t28, t26, test_addarray.c:7:2
              t10: i64 = add t4, Constant:i64<3996>, test_addarray.c:7:2
            t30: i64 = setcc t10, t6, setugt:ch, test_addarray.c:7:2
            t27: i64 = setcc t8, t4, setugt:ch, test_addarray.c:7:2
          t31: i64 = and t30, t27, test_addarray.c:7:2
        t32: i64 = or t29, t31, test_addarray.c:7:2
      t35: i64 = and t32, Constant:i64<1>, test_addarray.c:7:2
    t23: ch = brcond t21, t35, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2
  t25: ch = br t23, BasicBlock:ch<vector.body.preheader 0xe2a828>, test_addarray.c:7:2



Combining: t35: i64 = and t32, Constant:i64<1>, test_addarray.c:7:2

Replacing.2 t35: i64 = and t32, Constant:i64<1>, test_addarray.c:7:2

With: t32: i64 = or t29, t31, test_addarray.c:7:2


Combining: t32: i64 = or t29, t31, test_addarray.c:7:2

Combining: t31: i64 = and t30, t27, test_addarray.c:7:2

Combining: t30: i64 = setcc t10, t6, setugt:ch, test_addarray.c:7:2

Combining: t29: i64 = and t28, t26, test_addarray.c:7:2

Combining: t28: i64 = setcc t9, t6, setugt:ch, test_addarray.c:7:2

Combining: t27: i64 = setcc t8, t4, setugt:ch, test_addarray.c:7:2

Combining: t26: i64 = setcc t8, t2, setugt:ch, test_addarray.c:7:2

Combining: t25: ch = br t23, BasicBlock:ch<vector.body.preheader 0xe2a828>, test_addarray.c:7:2

Combining: t24: ch = BasicBlock<vector.body.preheader 0xe2a828>

Combining: t23: ch = brcond t21, t32, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2

Combining: t22: ch = BasicBlock<for.body.preheader 0xe2a908>

Combining: t21: ch = CopyToReg t0, Register:i64 %24, Constant:i64<0>

Combining: t20: i64 = Register %24

Combining: t19: i64 = Constant<0>

Combining: t11: ch = setugt

Combining: t10: i64 = add t4, Constant:i64<3996>, test_addarray.c:7:2

Combining: t9: i64 = add t2, Constant:i64<3996>, test_addarray.c:7:2

Combining: t8: i64 = add t6, Constant:i64<3996>, test_addarray.c:7:2

Combining: t7: i64 = Constant<3996>

Combining: t6: i64,ch = CopyFromReg t0, Register:i64 %23

Combining: t5: i64 = Register %23

Combining: t4: i64,ch = CopyFromReg t0, Register:i64 %22

Combining: t3: i64 = Register %22

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %21

Combining: t1: i64 = Register %21

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.0 'add:entry'
SelectionDAG has 26 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %21
  t4: i64,ch = CopyFromReg t0, Register:i64 %22
  t6: i64,ch = CopyFromReg t0, Register:i64 %23
  t8: i64 = add t6, Constant:i64<3996>, test_addarray.c:7:2
      t21: ch = CopyToReg t0, Register:i64 %24, Constant:i64<0>
            t9: i64 = add t2, Constant:i64<3996>, test_addarray.c:7:2
          t28: i64 = setcc t9, t6, setugt:ch, test_addarray.c:7:2
          t26: i64 = setcc t8, t2, setugt:ch, test_addarray.c:7:2
        t29: i64 = and t28, t26, test_addarray.c:7:2
            t10: i64 = add t4, Constant:i64<3996>, test_addarray.c:7:2
          t30: i64 = setcc t10, t6, setugt:ch, test_addarray.c:7:2
          t27: i64 = setcc t8, t4, setugt:ch, test_addarray.c:7:2
        t31: i64 = and t30, t27, test_addarray.c:7:2
      t32: i64 = or t29, t31, test_addarray.c:7:2
    t23: ch = brcond t21, t32, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2
  t25: ch = br t23, BasicBlock:ch<vector.body.preheader 0xe2a828>, test_addarray.c:7:2



Legalizing: t25: ch = br t23, BasicBlock:ch<vector.body.preheader 0xe2a828>, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t23: ch = brcond t21, t32, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2
Trying custom legalization
Creating new node: t37: ch = RISCVISD::BR_CC t21, t32, Constant:i64<0>, setne:ch, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2
Successfully custom legalized node
 ... replacing: t23: ch = brcond t21, t32, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2
     with:      t37: ch = RISCVISD::BR_CC t21, t32, Constant:i64<0>, setne:ch, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2

Legalizing: t32: i64 = or t29, t31, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t29: i64 = and t28, t26, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t31: i64 = and t30, t27, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t26: i64 = setcc t8, t2, setugt:ch, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t27: i64 = setcc t8, t4, setugt:ch, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t30: i64 = setcc t10, t6, setugt:ch, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t28: i64 = setcc t9, t6, setugt:ch, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t8: i64 = add t6, Constant:i64<3996>, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t10: i64 = add t4, Constant:i64<3996>, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t9: i64 = add t2, Constant:i64<3996>, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t21: ch = CopyToReg t0, Register:i64 %24, Constant:i64<0>
Legal node: nothing to do

Legalizing: t6: i64,ch = CopyFromReg t0, Register:i64 %23
Legal node: nothing to do

Legalizing: t4: i64,ch = CopyFromReg t0, Register:i64 %22
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %21
Legal node: nothing to do

Legalizing: t24: ch = BasicBlock<vector.body.preheader 0xe2a828>
Legal node: nothing to do

Legalizing: t22: ch = BasicBlock<for.body.preheader 0xe2a908>
Legal node: nothing to do

Legalizing: t20: i64 = Register %24

Legalizing: t19: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t11: ch = setugt
Legal node: nothing to do

Legalizing: t7: i64 = Constant<3996>
Legal node: nothing to do

Legalizing: t5: i64 = Register %23

Legalizing: t3: i64 = Register %22

Legalizing: t1: i64 = Register %21

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t37: ch = RISCVISD::BR_CC t21, t32, Constant:i64<0>, setne:ch, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t36: ch = setne
Legal node: nothing to do
Legalized selection DAG: %bb.0 'add:entry'
SelectionDAG has 27 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %21
  t4: i64,ch = CopyFromReg t0, Register:i64 %22
  t6: i64,ch = CopyFromReg t0, Register:i64 %23
  t8: i64 = add t6, Constant:i64<3996>, test_addarray.c:7:2
      t21: ch = CopyToReg t0, Register:i64 %24, Constant:i64<0>
            t9: i64 = add t2, Constant:i64<3996>, test_addarray.c:7:2
          t28: i64 = setcc t9, t6, setugt:ch, test_addarray.c:7:2
          t26: i64 = setcc t8, t2, setugt:ch, test_addarray.c:7:2
        t29: i64 = and t28, t26, test_addarray.c:7:2
            t10: i64 = add t4, Constant:i64<3996>, test_addarray.c:7:2
          t30: i64 = setcc t10, t6, setugt:ch, test_addarray.c:7:2
          t27: i64 = setcc t8, t4, setugt:ch, test_addarray.c:7:2
        t31: i64 = and t30, t27, test_addarray.c:7:2
      t32: i64 = or t29, t31, test_addarray.c:7:2
    t37: ch = RISCVISD::BR_CC t21, t32, Constant:i64<0>, setne:ch, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2
  t25: ch = br t37, BasicBlock:ch<vector.body.preheader 0xe2a828>, test_addarray.c:7:2



Legalizing: t37: ch = RISCVISD::BR_CC t21, t32, Constant:i64<0>, setne:ch, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2
Legal node: nothing to do

Combining: t37: ch = RISCVISD::BR_CC t21, t32, Constant:i64<0>, setne:ch, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2

Legalizing: t36: ch = setne
Legal node: nothing to do

Combining: t36: ch = setne

Legalizing: t25: ch = br t37, BasicBlock:ch<vector.body.preheader 0xe2a828>, test_addarray.c:7:2
Legal node: nothing to do

Combining: t25: ch = br t37, BasicBlock:ch<vector.body.preheader 0xe2a828>, test_addarray.c:7:2

Legalizing: t32: i64 = or t29, t31, test_addarray.c:7:2
Legal node: nothing to do

Combining: t32: i64 = or t29, t31, test_addarray.c:7:2

Legalizing: t29: i64 = and t28, t26, test_addarray.c:7:2
Legal node: nothing to do

Combining: t29: i64 = and t28, t26, test_addarray.c:7:2

Legalizing: t31: i64 = and t30, t27, test_addarray.c:7:2
Legal node: nothing to do

Combining: t31: i64 = and t30, t27, test_addarray.c:7:2

Legalizing: t26: i64 = setcc t8, t2, setugt:ch, test_addarray.c:7:2
Legal node: nothing to do

Combining: t26: i64 = setcc t8, t2, setugt:ch, test_addarray.c:7:2

Legalizing: t27: i64 = setcc t8, t4, setugt:ch, test_addarray.c:7:2
Legal node: nothing to do

Combining: t27: i64 = setcc t8, t4, setugt:ch, test_addarray.c:7:2

Legalizing: t30: i64 = setcc t10, t6, setugt:ch, test_addarray.c:7:2
Legal node: nothing to do

Combining: t30: i64 = setcc t10, t6, setugt:ch, test_addarray.c:7:2

Legalizing: t28: i64 = setcc t9, t6, setugt:ch, test_addarray.c:7:2
Legal node: nothing to do

Combining: t28: i64 = setcc t9, t6, setugt:ch, test_addarray.c:7:2

Legalizing: t8: i64 = add t6, Constant:i64<3996>, test_addarray.c:7:2
Legal node: nothing to do

Combining: t8: i64 = add t6, Constant:i64<3996>, test_addarray.c:7:2

Legalizing: t10: i64 = add t4, Constant:i64<3996>, test_addarray.c:7:2
Legal node: nothing to do

Combining: t10: i64 = add t4, Constant:i64<3996>, test_addarray.c:7:2

Legalizing: t9: i64 = add t2, Constant:i64<3996>, test_addarray.c:7:2
Legal node: nothing to do

Combining: t9: i64 = add t2, Constant:i64<3996>, test_addarray.c:7:2

Legalizing: t21: ch = CopyToReg t0, Register:i64 %24, Constant:i64<0>
Legal node: nothing to do

Combining: t21: ch = CopyToReg t0, Register:i64 %24, Constant:i64<0>

Legalizing: t6: i64,ch = CopyFromReg t0, Register:i64 %23
Legal node: nothing to do

Combining: t6: i64,ch = CopyFromReg t0, Register:i64 %23

Legalizing: t4: i64,ch = CopyFromReg t0, Register:i64 %22
Legal node: nothing to do

Combining: t4: i64,ch = CopyFromReg t0, Register:i64 %22

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %21
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %21

Legalizing: t24: ch = BasicBlock<vector.body.preheader 0xe2a828>
Legal node: nothing to do

Combining: t24: ch = BasicBlock<vector.body.preheader 0xe2a828>

Legalizing: t22: ch = BasicBlock<for.body.preheader 0xe2a908>
Legal node: nothing to do

Combining: t22: ch = BasicBlock<for.body.preheader 0xe2a908>

Legalizing: t20: i64 = Register %24

Combining: t20: i64 = Register %24

Legalizing: t19: i64 = Constant<0>
Legal node: nothing to do

Combining: t19: i64 = Constant<0>

Legalizing: t11: ch = setugt
Legal node: nothing to do

Combining: t11: ch = setugt

Legalizing: t7: i64 = Constant<3996>
Legal node: nothing to do

Combining: t7: i64 = Constant<3996>

Legalizing: t5: i64 = Register %23

Combining: t5: i64 = Register %23

Legalizing: t3: i64 = Register %22

Combining: t3: i64 = Register %22

Legalizing: t1: i64 = Register %21

Combining: t1: i64 = Register %21

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 'add:entry'
SelectionDAG has 27 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %21
  t4: i64,ch = CopyFromReg t0, Register:i64 %22
  t6: i64,ch = CopyFromReg t0, Register:i64 %23
  t8: i64 = add t6, Constant:i64<3996>, test_addarray.c:7:2
      t21: ch = CopyToReg t0, Register:i64 %24, Constant:i64<0>
            t9: i64 = add t2, Constant:i64<3996>, test_addarray.c:7:2
          t28: i64 = setcc t9, t6, setugt:ch, test_addarray.c:7:2
          t26: i64 = setcc t8, t2, setugt:ch, test_addarray.c:7:2
        t29: i64 = and t28, t26, test_addarray.c:7:2
            t10: i64 = add t4, Constant:i64<3996>, test_addarray.c:7:2
          t30: i64 = setcc t10, t6, setugt:ch, test_addarray.c:7:2
          t27: i64 = setcc t8, t4, setugt:ch, test_addarray.c:7:2
        t31: i64 = and t30, t27, test_addarray.c:7:2
      t32: i64 = or t29, t31, test_addarray.c:7:2
    t37: ch = RISCVISD::BR_CC t21, t32, Constant:i64<0>, setne:ch, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2
  t25: ch = br t37, BasicBlock:ch<vector.body.preheader 0xe2a828>, test_addarray.c:7:2


===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t25: ch = br t37, BasicBlock:ch<vector.body.preheader 0xe2a828>, test_addarray.c:7:2
ISEL: Starting pattern match
  Morphed node: t25: ch = PseudoBR BasicBlock:ch<vector.body.preheader 0xe2a828>, t37, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t37: ch = RISCVISD::BR_CC t21, t32, Constant:i64<0>, setne:ch, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 907160
  Skipped scope entry (due to false predicate) at index 907171, continuing at 907191
  Morphed node: t37: ch = BNE t32, Constant:i64<0>, BasicBlock:ch<for.body.preheader 0xe2a908>, t21, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t32: i64 = or t29, t31, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 5
  Skipped scope entry (due to false predicate) at index 11, continuing at 61
  Skipped scope entry (due to false predicate) at index 62, continuing at 112
  Skipped scope entry (due to false predicate) at index 113, continuing at 172
  Skipped scope entry (due to false predicate) at index 173, continuing at 226
  Skipped scope entry (due to false predicate) at index 227, continuing at 255
  Skipped scope entry (due to false predicate) at index 256, continuing at 286
  Skipped scope entry (due to false predicate) at index 287, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 353
  Skipped scope entry (due to false predicate) at index 354, continuing at 412
  Skipped scope entry (due to false predicate) at index 413, continuing at 478
  Match failed at index 486
  Continuing at 567
  Match failed at index 573
  Continuing at 653
  Match failed at index 664
  Continuing at 702
  Match failed at index 705
  Continuing at 742
  Match failed at index 744
  Continuing at 782
  Match failed at index 785
  Continuing at 822
  Continuing at 823
  Continuing at 824
  Continuing at 825
  Continuing at 826
  Match failed at index 830
  Continuing at 874
  Match failed at index 876
  Continuing at 924
  Match failed at index 927
  Continuing at 1008
  Match failed at index 1010
  Continuing at 1044
  Match failed at index 1055
  Continuing at 1266
  Morphed node: t32: i64 = OR t29, t31, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t29: i64 = and t28, t26, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 8069
  Match failed at index 8072
  Continuing at 8130
  Match failed at index 8133
  Continuing at 8189
  Match failed at index 8190
  Continuing at 8259
  Match failed at index 8261
  Continuing at 8359
  Match failed at index 8362
  Continuing at 8395
  Match failed at index 8397
  Continuing at 8475
  Match failed at index 8478
  Continuing at 8518
  Match failed at index 8519
  Continuing at 8548
  Match failed at index 8549
  Continuing at 8599
  Match failed at index 8610
  Continuing at 8821
  Morphed node: t29: i64 = AND t28, t26, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t31: i64 = and t30, t27, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 8069
  Match failed at index 8072
  Continuing at 8130
  Match failed at index 8133
  Continuing at 8189
  Match failed at index 8190
  Continuing at 8259
  Match failed at index 8261
  Continuing at 8359
  Match failed at index 8362
  Continuing at 8395
  Match failed at index 8397
  Continuing at 8475
  Match failed at index 8478
  Continuing at 8518
  Match failed at index 8519
  Continuing at 8548
  Match failed at index 8549
  Continuing at 8599
  Match failed at index 8610
  Continuing at 8821
  Morphed node: t31: i64 = AND t30, t27, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t26: i64 = setcc t8, t2, setugt:ch, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 841145
  Skipped scope entry (due to false predicate) at index 841157, continuing at 841195
  Match failed at index 841201
  Continuing at 841310
  Match failed at index 841311
  Continuing at 841325
  Match failed at index 841326
  Continuing at 841340
  Morphed node: t26: i64 = SLTU t2, t8, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t27: i64 = setcc t8, t4, setugt:ch, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 841145
  Skipped scope entry (due to false predicate) at index 841157, continuing at 841195
  Match failed at index 841201
  Continuing at 841310
  Match failed at index 841311
  Continuing at 841325
  Match failed at index 841326
  Continuing at 841340
  Morphed node: t27: i64 = SLTU t4, t8, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t30: i64 = setcc t10, t6, setugt:ch, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 841145
  Skipped scope entry (due to false predicate) at index 841157, continuing at 841195
  Match failed at index 841201
  Continuing at 841310
  Match failed at index 841311
  Continuing at 841325
  Match failed at index 841326
  Continuing at 841340
  Morphed node: t30: i64 = SLTU t6, t10, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t28: i64 = setcc t9, t6, setugt:ch, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 841145
  Skipped scope entry (due to false predicate) at index 841157, continuing at 841195
  Match failed at index 841201
  Continuing at 841310
  Match failed at index 841311
  Continuing at 841325
  Match failed at index 841326
  Continuing at 841340
  Morphed node: t28: i64 = SLTU t6, t9, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t8: i64 = add t6, Constant:i64<3996>, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 16032
  Skipped scope entry (due to false predicate) at index 16038, continuing at 16121
  Skipped scope entry (due to false predicate) at index 16122, continuing at 16156
  Skipped scope entry (due to false predicate) at index 16157, continuing at 16191
  Skipped scope entry (due to false predicate) at index 16192, continuing at 16226
  Match failed at index 16036
  Continuing at 16227
  Skipped scope entry (due to false predicate) at index 16240, continuing at 16308
  Skipped scope entry (due to false predicate) at index 16309, continuing at 16338
  Skipped scope entry (due to false predicate) at index 16339, continuing at 16368
  Skipped scope entry (due to false predicate) at index 16369, continuing at 16398
  Match failed at index 16238
  Continuing at 16399
  Match failed at index 16405
  Continuing at 16444
  Continuing at 16445
  Skipped scope entry (due to false predicate) at index 16451, continuing at 16598
  Skipped scope entry (due to false predicate) at index 16599, continuing at 16624
  Match failed at index 16448
  Continuing at 16625
  Skipped scope entry (due to false predicate) at index 16635, continuing at 16752
  Skipped scope entry (due to false predicate) at index 16753, continuing at 16773
  Match failed at index 16633
  Continuing at 16774
  Match failed at index 16777
  Continuing at 17225
  Match failed at index 17232
  Continuing at 17671
  Skipped scope entry (due to false predicate) at index 17682, continuing at 17715
  Skipped scope entry (due to false predicate) at index 17716, continuing at 17777
  Match failed at index 17680
  Continuing at 17778
  Morphed node: t8: i64 = ADD t6, Constant:i64<3996>, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t10: i64 = add t4, Constant:i64<3996>, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 16032
  Skipped scope entry (due to false predicate) at index 16038, continuing at 16121
  Skipped scope entry (due to false predicate) at index 16122, continuing at 16156
  Skipped scope entry (due to false predicate) at index 16157, continuing at 16191
  Skipped scope entry (due to false predicate) at index 16192, continuing at 16226
  Match failed at index 16036
  Continuing at 16227
  Skipped scope entry (due to false predicate) at index 16240, continuing at 16308
  Skipped scope entry (due to false predicate) at index 16309, continuing at 16338
  Skipped scope entry (due to false predicate) at index 16339, continuing at 16368
  Skipped scope entry (due to false predicate) at index 16369, continuing at 16398
  Match failed at index 16238
  Continuing at 16399
  Match failed at index 16405
  Continuing at 16444
  Continuing at 16445
  Skipped scope entry (due to false predicate) at index 16451, continuing at 16598
  Skipped scope entry (due to false predicate) at index 16599, continuing at 16624
  Match failed at index 16448
  Continuing at 16625
  Skipped scope entry (due to false predicate) at index 16635, continuing at 16752
  Skipped scope entry (due to false predicate) at index 16753, continuing at 16773
  Match failed at index 16633
  Continuing at 16774
  Match failed at index 16777
  Continuing at 17225
  Match failed at index 17232
  Continuing at 17671
  Skipped scope entry (due to false predicate) at index 17682, continuing at 17715
  Skipped scope entry (due to false predicate) at index 17716, continuing at 17777
  Match failed at index 17680
  Continuing at 17778
  Morphed node: t10: i64 = ADD t4, Constant:i64<3996>, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t9: i64 = add t2, Constant:i64<3996>, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 16032
  Skipped scope entry (due to false predicate) at index 16038, continuing at 16121
  Skipped scope entry (due to false predicate) at index 16122, continuing at 16156
  Skipped scope entry (due to false predicate) at index 16157, continuing at 16191
  Skipped scope entry (due to false predicate) at index 16192, continuing at 16226
  Match failed at index 16036
  Continuing at 16227
  Skipped scope entry (due to false predicate) at index 16240, continuing at 16308
  Skipped scope entry (due to false predicate) at index 16309, continuing at 16338
  Skipped scope entry (due to false predicate) at index 16339, continuing at 16368
  Skipped scope entry (due to false predicate) at index 16369, continuing at 16398
  Match failed at index 16238
  Continuing at 16399
  Match failed at index 16405
  Continuing at 16444
  Continuing at 16445
  Skipped scope entry (due to false predicate) at index 16451, continuing at 16598
  Skipped scope entry (due to false predicate) at index 16599, continuing at 16624
  Match failed at index 16448
  Continuing at 16625
  Skipped scope entry (due to false predicate) at index 16635, continuing at 16752
  Skipped scope entry (due to false predicate) at index 16753, continuing at 16773
  Match failed at index 16633
  Continuing at 16774
  Match failed at index 16777
  Continuing at 17225
  Match failed at index 17232
  Continuing at 17671
  Skipped scope entry (due to false predicate) at index 17682, continuing at 17715
  Skipped scope entry (due to false predicate) at index 17716, continuing at 17777
  Match failed at index 17680
  Continuing at 17778
  Morphed node: t9: i64 = ADD t2, Constant:i64<3996>, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch = CopyToReg t0, Register:i64 %24, Constant:i64<0>

ISEL: Starting selection on root node: t6: i64,ch = CopyFromReg t0, Register:i64 %23

ISEL: Starting selection on root node: t4: i64,ch = CopyFromReg t0, Register:i64 %22

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %21

ISEL: Starting selection on root node: t24: ch = BasicBlock<vector.body.preheader 0xe2a828>

ISEL: Starting selection on root node: t22: ch = BasicBlock<for.body.preheader 0xe2a908>

ISEL: Starting selection on root node: t20: i64 = Register %24

ISEL: Starting selection on root node: t19: i64 = Constant<0>
Creating new node: t39: i64,ch = CopyFromReg t0, Register:i64 $x0

ISEL: Starting selection on root node: t7: i64 = Constant<3996>
Creating constant: t40: i64 = TargetConstant<1>
Creating new machine node: t41: i64 = LUI TargetConstant:i64<1>
Creating constant: t42: i64 = TargetConstant<-100>
Creating new machine node: t43: i64 = ADDIW t41, TargetConstant:i64<-100>

ISEL: Starting selection on root node: t5: i64 = Register %23

ISEL: Starting selection on root node: t3: i64 = Register %22

ISEL: Starting selection on root node: t1: i64 = Register %21

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 'add:entry'
SelectionDAG has 29 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %21
  t4: i64,ch = CopyFromReg t0, Register:i64 %22
  t6: i64,ch = CopyFromReg t0, Register:i64 %23
  t8: i64 = ADD t6, t43, test_addarray.c:7:2
  t39: i64,ch = CopyFromReg t0, Register:i64 $x0
    t41: i64 = LUI TargetConstant:i64<1>
  t43: i64 = ADDIW t41, TargetConstant:i64<-100>
            t9: i64 = ADD t2, t43, test_addarray.c:7:2
          t28: i64 = SLTU t6, t9, test_addarray.c:7:2
          t26: i64 = SLTU t2, t8, test_addarray.c:7:2
        t29: i64 = AND t28, t26, test_addarray.c:7:2
            t10: i64 = ADD t4, t43, test_addarray.c:7:2
          t30: i64 = SLTU t6, t10, test_addarray.c:7:2
          t27: i64 = SLTU t4, t8, test_addarray.c:7:2
        t31: i64 = AND t30, t27, test_addarray.c:7:2
      t32: i64 = OR t29, t31, test_addarray.c:7:2
      t21: ch = CopyToReg t0, Register:i64 %24, t39
    t37: ch = BNE t32, t39, BasicBlock:ch<for.body.preheader 0xe2a908>, t21, test_addarray.c:7:2
  t25: ch = PseudoBR BasicBlock:ch<vector.body.preheader 0xe2a828>, t37, test_addarray.c:7:2


********** List Scheduling %bb.0 'entry' **********
SU(0): t25: ch = PseudoBR BasicBlock:ch<vector.body.preheader 0xe2a828>, t37, test_addarray.c:7:2

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 7
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t37: ch = BNE t32, t39, BasicBlock:ch<for.body.preheader 0xe2a908>, t21, test_addarray.c:7:2

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 1
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t21: ch = CopyToReg t0, Register:i64 %24, t39

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(3): t39: i64,ch = CopyFromReg t0, Register:i64 $x0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(1): Data Latency=1
    SU(2): Data Latency=1
SU(4): t32: i64 = OR t29, t31, test_addarray.c:7:2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 2
  Predecessors:
    SU(14): Data Latency=1
    SU(5): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(5): t31: i64 = AND t30, t27, test_addarray.c:7:2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 3
  Predecessors:
    SU(12): Data Latency=1
    SU(6): Data Latency=1
  Successors:
    SU(4): Data Latency=1
SU(6): t27: i64 = SLTU t4, t8, test_addarray.c:7:2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 4
  Predecessors:
    SU(11): Data Latency=1
    SU(7): Data Latency=1
  Successors:
    SU(5): Data Latency=1
SU(7): t8: i64 = ADD t6, t43, test_addarray.c:7:2

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 5
  Predecessors:
    SU(10): Data Latency=1
    SU(8): Data Latency=1
  Successors:
    SU(6): Data Latency=1
    SU(15): Data Latency=1
SU(8): t43: i64 = ADDIW t41, TargetConstant:i64<-100>

  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 6
  Predecessors:
    SU(9): Data Latency=1
  Successors:
    SU(7): Data Latency=1
    SU(13): Data Latency=1
    SU(18): Data Latency=1
SU(9): t41: i64 = LUI TargetConstant:i64<1>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(8): Data Latency=1
SU(10): t6: i64,ch = CopyFromReg t0, Register:i64 %23

  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(7): Data Latency=1
    SU(12): Data Latency=1
    SU(17): Data Latency=1
SU(11): t4: i64,ch = CopyFromReg t0, Register:i64 %22

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(6): Data Latency=1
    SU(13): Data Latency=1
SU(12): t30: i64 = SLTU t6, t10, test_addarray.c:7:2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 4
  Predecessors:
    SU(10): Data Latency=1
    SU(13): Data Latency=1
  Successors:
    SU(5): Data Latency=1
SU(13): t10: i64 = ADD t4, t43, test_addarray.c:7:2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 5
  Predecessors:
    SU(11): Data Latency=1
    SU(8): Data Latency=1
  Successors:
    SU(12): Data Latency=1
SU(14): t29: i64 = AND t28, t26, test_addarray.c:7:2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 3
  Predecessors:
    SU(17): Data Latency=1
    SU(15): Data Latency=1
  Successors:
    SU(4): Data Latency=1
SU(15): t26: i64 = SLTU t2, t8, test_addarray.c:7:2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 4
  Predecessors:
    SU(16): Data Latency=1
    SU(7): Data Latency=1
  Successors:
    SU(14): Data Latency=1
SU(16): t2: i64,ch = CopyFromReg t0, Register:i64 %21

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(15): Data Latency=1
    SU(18): Data Latency=1
SU(17): t28: i64 = SLTU t6, t9, test_addarray.c:7:2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 4
  Predecessors:
    SU(10): Data Latency=1
    SU(18): Data Latency=1
  Successors:
    SU(14): Data Latency=1
SU(18): t9: i64 = ADD t2, t43, test_addarray.c:7:2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 5
  Predecessors:
    SU(16): Data Latency=1
    SU(8): Data Latency=1
  Successors:
    SU(17): Data Latency=1

Examining Available:
Height 0: SU(0): t25: ch = PseudoBR BasicBlock:ch<vector.body.preheader 0xe2a828>, t37, test_addarray.c:7:2


*** Scheduling [0]: SU(0): t25: ch = PseudoBR BasicBlock:ch<vector.body.preheader 0xe2a828>, t37, test_addarray.c:7:2


Examining Available:
Height 1: SU(1): t37: ch = BNE t32, t39, BasicBlock:ch<for.body.preheader 0xe2a908>, t21, test_addarray.c:7:2


*** Scheduling [1]: SU(1): t37: ch = BNE t32, t39, BasicBlock:ch<for.body.preheader 0xe2a908>, t21, test_addarray.c:7:2


Examining Available:
Height 2: SU(2): t21: ch = CopyToReg t0, Register:i64 %24, t39

Height 2: SU(4): t32: i64 = OR t29, t31, test_addarray.c:7:2


*** Scheduling [2]: SU(2): t21: ch = CopyToReg t0, Register:i64 %24, t39


Examining Available:
Height 3: SU(3): t39: i64,ch = CopyFromReg t0, Register:i64 $x0

Height 2: SU(4): t32: i64 = OR t29, t31, test_addarray.c:7:2


*** Scheduling [3]: SU(3): t39: i64,ch = CopyFromReg t0, Register:i64 $x0


Examining Available:
Height 2: SU(4): t32: i64 = OR t29, t31, test_addarray.c:7:2


*** Scheduling [4]: SU(4): t32: i64 = OR t29, t31, test_addarray.c:7:2


Examining Available:
Height 5: SU(5): t31: i64 = AND t30, t27, test_addarray.c:7:2

Height 5: SU(14): t29: i64 = AND t28, t26, test_addarray.c:7:2


*** Scheduling [5]: SU(5): t31: i64 = AND t30, t27, test_addarray.c:7:2


Examining Available:
Height 6: SU(6): t27: i64 = SLTU t4, t8, test_addarray.c:7:2

Height 6: SU(12): t30: i64 = SLTU t6, t10, test_addarray.c:7:2

Height 5: SU(14): t29: i64 = AND t28, t26, test_addarray.c:7:2


*** Scheduling [6]: SU(6): t27: i64 = SLTU t4, t8, test_addarray.c:7:2


Examining Available:
Height 6: SU(12): t30: i64 = SLTU t6, t10, test_addarray.c:7:2

Height 5: SU(14): t29: i64 = AND t28, t26, test_addarray.c:7:2


*** Scheduling [7]: SU(12): t30: i64 = SLTU t6, t10, test_addarray.c:7:2


Examining Available:
Height 5: SU(14): t29: i64 = AND t28, t26, test_addarray.c:7:2

Height 8: SU(13): t10: i64 = ADD t4, t43, test_addarray.c:7:2


*** Scheduling [8]: SU(14): t29: i64 = AND t28, t26, test_addarray.c:7:2


Examining Available:
Height 9: SU(15): t26: i64 = SLTU t2, t8, test_addarray.c:7:2

Height 9: SU(17): t28: i64 = SLTU t6, t9, test_addarray.c:7:2

Height 8: SU(13): t10: i64 = ADD t4, t43, test_addarray.c:7:2


*** Scheduling [9]: SU(15): t26: i64 = SLTU t2, t8, test_addarray.c:7:2


Examining Available:
Height 9: SU(17): t28: i64 = SLTU t6, t9, test_addarray.c:7:2

Height 8: SU(13): t10: i64 = ADD t4, t43, test_addarray.c:7:2

Height 10: SU(7): t8: i64 = ADD t6, t43, test_addarray.c:7:2


*** Scheduling [10]: SU(17): t28: i64 = SLTU t6, t9, test_addarray.c:7:2


Examining Available:
Height 8: SU(13): t10: i64 = ADD t4, t43, test_addarray.c:7:2

Height 11: SU(18): t9: i64 = ADD t2, t43, test_addarray.c:7:2

Height 10: SU(7): t8: i64 = ADD t6, t43, test_addarray.c:7:2


*** Scheduling [11]: SU(13): t10: i64 = ADD t4, t43, test_addarray.c:7:2


Examining Available:
Height 11: SU(18): t9: i64 = ADD t2, t43, test_addarray.c:7:2

Height 10: SU(7): t8: i64 = ADD t6, t43, test_addarray.c:7:2

Height 12: SU(11): t4: i64,ch = CopyFromReg t0, Register:i64 %22


*** Scheduling [12]: SU(18): t9: i64 = ADD t2, t43, test_addarray.c:7:2


Examining Available:
Height 10: SU(7): t8: i64 = ADD t6, t43, test_addarray.c:7:2

Height 13: SU(16): t2: i64,ch = CopyFromReg t0, Register:i64 %21

Height 12: SU(11): t4: i64,ch = CopyFromReg t0, Register:i64 %22


*** Scheduling [13]: SU(7): t8: i64 = ADD t6, t43, test_addarray.c:7:2


Examining Available:
Height 14: SU(8): t43: i64 = ADDIW t41, TargetConstant:i64<-100>

Height 14: SU(10): t6: i64,ch = CopyFromReg t0, Register:i64 %23

Height 13: SU(16): t2: i64,ch = CopyFromReg t0, Register:i64 %21

Height 12: SU(11): t4: i64,ch = CopyFromReg t0, Register:i64 %22


*** Scheduling [14]: SU(8): t43: i64 = ADDIW t41, TargetConstant:i64<-100>


Examining Available:
Height 15: SU(9): t41: i64 = LUI TargetConstant:i64<1>

Height 14: SU(10): t6: i64,ch = CopyFromReg t0, Register:i64 %23

Height 13: SU(16): t2: i64,ch = CopyFromReg t0, Register:i64 %21

Height 12: SU(11): t4: i64,ch = CopyFromReg t0, Register:i64 %22


*** Scheduling [15]: SU(9): t41: i64 = LUI TargetConstant:i64<1>


Examining Available:
Height 14: SU(10): t6: i64,ch = CopyFromReg t0, Register:i64 %23

Height 13: SU(16): t2: i64,ch = CopyFromReg t0, Register:i64 %21

Height 12: SU(11): t4: i64,ch = CopyFromReg t0, Register:i64 %22


*** Scheduling [16]: SU(10): t6: i64,ch = CopyFromReg t0, Register:i64 %23


Examining Available:
Height 13: SU(16): t2: i64,ch = CopyFromReg t0, Register:i64 %21

Height 12: SU(11): t4: i64,ch = CopyFromReg t0, Register:i64 %22


*** Scheduling [17]: SU(16): t2: i64,ch = CopyFromReg t0, Register:i64 %21


Examining Available:
Height 12: SU(11): t4: i64,ch = CopyFromReg t0, Register:i64 %22


*** Scheduling [18]: SU(11): t4: i64,ch = CopyFromReg t0, Register:i64 %22

*** Final schedule ***
SU(11): t4: i64,ch = CopyFromReg t0, Register:i64 %22

SU(16): t2: i64,ch = CopyFromReg t0, Register:i64 %21

SU(10): t6: i64,ch = CopyFromReg t0, Register:i64 %23

SU(9): t41: i64 = LUI TargetConstant:i64<1>

SU(8): t43: i64 = ADDIW t41, TargetConstant:i64<-100>

SU(7): t8: i64 = ADD t6, t43, test_addarray.c:7:2

SU(18): t9: i64 = ADD t2, t43, test_addarray.c:7:2

SU(13): t10: i64 = ADD t4, t43, test_addarray.c:7:2

SU(17): t28: i64 = SLTU t6, t9, test_addarray.c:7:2

SU(15): t26: i64 = SLTU t2, t8, test_addarray.c:7:2

SU(14): t29: i64 = AND t28, t26, test_addarray.c:7:2

SU(12): t30: i64 = SLTU t6, t10, test_addarray.c:7:2

SU(6): t27: i64 = SLTU t4, t8, test_addarray.c:7:2

SU(5): t31: i64 = AND t30, t27, test_addarray.c:7:2

SU(4): t32: i64 = OR t29, t31, test_addarray.c:7:2

SU(3): t39: i64,ch = CopyFromReg t0, Register:i64 $x0

SU(2): t21: ch = CopyToReg t0, Register:i64 %24, t39

SU(1): t37: ch = BNE t32, t39, BasicBlock:ch<for.body.preheader 0xe2a908>, t21, test_addarray.c:7:2

SU(0): t25: ch = PseudoBR BasicBlock:ch<vector.body.preheader 0xe2a828>, t37, test_addarray.c:7:2


Total amount of phi nodes to update: 1
Node 0 : (0xe2a9e8, 2147483672)
Creating constant: t1: i64 = Constant<960>
Creating new node: t3: ch = CopyToReg t0, Register:i64 %38, Constant:i64<960>
Creating new node: t5: ch = br t3, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:2
Initial selection DAG: %bb.1 'add:vector.body.preheader'
SelectionDAG has 6 nodes:
      t0: ch = EntryToken
    t3: ch = CopyToReg t0, Register:i64 %38, Constant:i64<960>
  t5: ch = br t3, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:2



Combining: t5: ch = br t3, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:2

Combining: t4: ch = BasicBlock<vector.body 0xe2aa50>

Combining: t3: ch = CopyToReg t0, Register:i64 %38, Constant:i64<960>

Combining: t2: i64 = Register %38

Combining: t1: i64 = Constant<960>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.1 'add:vector.body.preheader'
SelectionDAG has 6 nodes:
      t0: ch = EntryToken
    t3: ch = CopyToReg t0, Register:i64 %38, Constant:i64<960>
  t5: ch = br t3, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:2


Legalizing node: t4: ch = BasicBlock<vector.body 0xe2aa50>
Analyzing result type: ch
Legal result type
Legally typed node: t4: ch = BasicBlock<vector.body 0xe2aa50>

Legalizing node: t2: i64 = Register %38
Ignoring node results
Legally typed node: t2: i64 = Register %38

Legalizing node: t1: i64 = Constant<960>
Analyzing result type: i64
Legal result type
Legally typed node: t1: i64 = Constant<960>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t3: ch = CopyToReg t0, Register:i64 %38, Constant:i64<960>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i64 = Constant<960>
Legal operand
Legally typed node: t3: ch = CopyToReg t0, Register:i64 %38, Constant:i64<960>

Legalizing node: t5: ch = br t3, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:2
Analyzing result type: ch
Legal result type
Analyzing operand: t3: ch = CopyToReg t0, Register:i64 %38, Constant:i64<960>
Legal operand
Analyzing operand: t4: ch = BasicBlock<vector.body 0xe2aa50>
Legal operand
Legally typed node: t5: ch = br t3, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:2

Legalizing node: t65535: ch = handlenode t5
Analyzing result type: ch
Legal result type
Analyzing operand: t5: ch = br t3, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:2
Legal operand
Legally typed node: t65535: ch = handlenode t5

Type-legalized selection DAG: %bb.1 'add:vector.body.preheader'
SelectionDAG has 6 nodes:
      t0: ch = EntryToken
    t3: ch = CopyToReg t0, Register:i64 %38, Constant:i64<960>
  t5: ch = br t3, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:2



Legalizing: t5: ch = br t3, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t3: ch = CopyToReg t0, Register:i64 %38, Constant:i64<960>
Legal node: nothing to do

Legalizing: t4: ch = BasicBlock<vector.body 0xe2aa50>
Legal node: nothing to do

Legalizing: t2: i64 = Register %38

Legalizing: t1: i64 = Constant<960>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.1 'add:vector.body.preheader'
SelectionDAG has 6 nodes:
      t0: ch = EntryToken
    t3: ch = CopyToReg t0, Register:i64 %38, Constant:i64<960>
  t5: ch = br t3, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:2



Legalizing: t5: ch = br t3, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:2
Legal node: nothing to do

Combining: t5: ch = br t3, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:2

Legalizing: t3: ch = CopyToReg t0, Register:i64 %38, Constant:i64<960>
Legal node: nothing to do

Combining: t3: ch = CopyToReg t0, Register:i64 %38, Constant:i64<960>

Legalizing: t4: ch = BasicBlock<vector.body 0xe2aa50>
Legal node: nothing to do

Combining: t4: ch = BasicBlock<vector.body 0xe2aa50>

Legalizing: t2: i64 = Register %38

Combining: t2: i64 = Register %38

Legalizing: t1: i64 = Constant<960>
Legal node: nothing to do

Combining: t1: i64 = Constant<960>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.1 'add:vector.body.preheader'
SelectionDAG has 6 nodes:
      t0: ch = EntryToken
    t3: ch = CopyToReg t0, Register:i64 %38, Constant:i64<960>
  t5: ch = br t3, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:2


===== Instruction selection begins: %bb.1 'vector.body.preheader'

ISEL: Starting selection on root node: t5: ch = br t3, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 895177
  Morphed node: t5: ch = PseudoBR BasicBlock:ch<vector.body 0xe2aa50>, t3, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t3: ch = CopyToReg t0, Register:i64 %38, Constant:i64<960>

ISEL: Starting selection on root node: t4: ch = BasicBlock<vector.body 0xe2aa50>

ISEL: Starting selection on root node: t2: i64 = Register %38

ISEL: Starting selection on root node: t1: i64 = Constant<960>
Creating constant: t7: i64 = TargetConstant<960>
Creating new machine node: t8: i64 = ADDI Register:i64 $x0, TargetConstant:i64<960>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.1 'add:vector.body.preheader'
SelectionDAG has 8 nodes:
      t0: ch = EntryToken
      t8: i64 = ADDI Register:i64 $x0, TargetConstant:i64<960>
    t3: ch = CopyToReg t0, Register:i64 %38, t8
  t5: ch = PseudoBR BasicBlock:ch<vector.body 0xe2aa50>, t3, test_addarray.c:7:2


********** List Scheduling %bb.1 'vector.body.preheader' **********
SU(0): t5: ch = PseudoBR BasicBlock:ch<vector.body 0xe2aa50>, t3, test_addarray.c:7:2

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t3: ch = CopyToReg t0, Register:i64 %38, t8

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t8: i64 = ADDI Register:i64 $x0, TargetConstant:i64<960>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t5: ch = PseudoBR BasicBlock:ch<vector.body 0xe2aa50>, t3, test_addarray.c:7:2


*** Scheduling [0]: SU(0): t5: ch = PseudoBR BasicBlock:ch<vector.body 0xe2aa50>, t3, test_addarray.c:7:2


Examining Available:
Height 1: SU(1): t3: ch = CopyToReg t0, Register:i64 %38, t8


*** Scheduling [1]: SU(1): t3: ch = CopyToReg t0, Register:i64 %38, t8


Examining Available:
Height 2: SU(2): t8: i64 = ADDI Register:i64 $x0, TargetConstant:i64<960>


*** Scheduling [2]: SU(2): t8: i64 = ADDI Register:i64 $x0, TargetConstant:i64<960>

*** Final schedule ***
SU(2): t8: i64 = ADDI Register:i64 $x0, TargetConstant:i64<960>

SU(1): t3: ch = CopyToReg t0, Register:i64 %38, t8

SU(0): t5: ch = PseudoBR BasicBlock:ch<vector.body 0xe2aa50>, t3, test_addarray.c:7:2


Total amount of phi nodes to update: 4
Node 0 : (0xe2ab30, 2147483669)
Node 1 : (0xe2ab98, 2147483670)
Node 2 : (0xe2ac00, 2147483671)
Node 3 : (0xe2ac68, 2147483686)
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
Creating new node: t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
Creating new node: t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
Creating constant: t7: i64 = Constant<0>
Creating new node: t8: i64 = undef
Creating new node: t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10
Creating new node: t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17
Creating new node: t11: v64i32 = add nsw t10, t9, test_addarray.c:9:15
Creating new node: t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8
Creating new node: t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t11, t2, undef:i64, test_addarray.c:9:8
Creating new node: t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20
Creating constant: t16: i64 = Constant<-64>
Creating new node: t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
Creating new node: t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20
Creating constant: t20: i64 = Constant<256>
Creating new node: t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20
Creating new node: t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20
Creating new node: t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20
Creating new node: t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20
Creating new node: t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20
Creating new node: t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20
Creating new node: t31: i1 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20
Creating constant: t32: i64 = Constant<960>
Creating new node: t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>
Creating new node: t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20
Creating new node: t37: ch = brcond t35, t31, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
Creating new node: t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20
Initial selection DAG: %bb.3 'add:vector.body'
SelectionDAG has 40 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
  t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
  t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
  t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10
  t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17
    t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20
  t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
        t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20
          t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20
        t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20
          t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20
        t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20
          t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20
        t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20
        t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>
          t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8
          t11: v64i32 = add nsw t10, t9, test_addarray.c:9:15
        t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t11, t2, undef:i64, test_addarray.c:9:8
      t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20
      t31: i1 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20
    t37: ch = brcond t35, t31, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
  t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20



Combining: t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20

Combining: t38: ch = BasicBlock<vector.body 0xe2aa50>

Combining: t37: ch = brcond t35, t31, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20

Combining: t36: ch = BasicBlock<for.body.preheader 0xe2a908>

Combining: t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20

Combining: t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>

Combining: t33: i64 = Register %39

Combining: t32: i64 = Constant<960>

Combining: t31: i1 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20

Combining: t30: ch = seteq

Combining: t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20

Combining: t28: i64 = Register %12

Combining: t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20

Combining: t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20

Combining: t25: i64 = Register %11

Combining: t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20

Combining: t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20

Combining: t22: i64 = Register %10

Combining: t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20

Combining: t20: i64 = Constant<256>

Combining: t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

Combining: t18: i64 = Register %9

Combining: t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20

Combining: t16: i64 = Constant<-64>

Combining: t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20

Combining: t14: i64 = Register %8

Combining: t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t11, t2, undef:i64, test_addarray.c:9:8

Combining: t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8

Combining: t11: v64i32 = add nsw t10, t9, test_addarray.c:9:15

Combining: t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17

Combining: t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10

Combining: t8: i64 = undef

Combining: t7: i64 = Constant<0>

Combining: t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20

Combining: t5: i64 = Register %5

Combining: t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20

Combining: t3: i64 = Register %6

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20

Combining: t1: i64 = Register %7

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.3 'add:vector.body'
SelectionDAG has 40 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
  t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
  t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
  t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10
  t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17
    t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20
  t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
        t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20
          t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20
        t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20
          t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20
        t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20
          t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20
        t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20
        t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>
          t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8
          t11: v64i32 = add nsw t10, t9, test_addarray.c:9:15
        t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t11, t2, undef:i64, test_addarray.c:9:8
      t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20
      t31: i1 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20
    t37: ch = brcond t35, t31, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
  t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20


Legalizing node: t38: ch = BasicBlock<vector.body 0xe2aa50>
Analyzing result type: ch
Legal result type
Legally typed node: t38: ch = BasicBlock<vector.body 0xe2aa50>

Legalizing node: t36: ch = BasicBlock<for.body.preheader 0xe2a908>
Analyzing result type: ch
Legal result type
Legally typed node: t36: ch = BasicBlock<for.body.preheader 0xe2a908>

Legalizing node: t33: i64 = Register %39
Ignoring node results
Legally typed node: t33: i64 = Register %39

Legalizing node: t32: i64 = Constant<960>
Analyzing result type: i64
Legal result type
Legally typed node: t32: i64 = Constant<960>

Legalizing node: t30: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t30: ch = seteq

Legalizing node: t28: i64 = Register %12
Ignoring node results
Legally typed node: t28: i64 = Register %12

Legalizing node: t25: i64 = Register %11
Ignoring node results
Legally typed node: t25: i64 = Register %11

Legalizing node: t22: i64 = Register %10
Ignoring node results
Legally typed node: t22: i64 = Register %10

Legalizing node: t20: i64 = Constant<256>
Analyzing result type: i64
Legal result type
Legally typed node: t20: i64 = Constant<256>

Legalizing node: t18: i64 = Register %9
Ignoring node results
Legally typed node: t18: i64 = Register %9

Legalizing node: t16: i64 = Constant<-64>
Analyzing result type: i64
Legal result type
Legally typed node: t16: i64 = Constant<-64>

Legalizing node: t14: i64 = Register %8
Ignoring node results
Legally typed node: t14: i64 = Register %8

Legalizing node: t8: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t8: i64 = undef

Legalizing node: t7: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = Constant<0>

Legalizing node: t5: i64 = Register %5
Ignoring node results
Legally typed node: t5: i64 = Register %5

Legalizing node: t3: i64 = Register %6
Ignoring node results
Legally typed node: t3: i64 = Register %6

Legalizing node: t1: i64 = Register %7
Ignoring node results
Legally typed node: t1: i64 = Register %7

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20

Legalizing node: t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
Legal operand
Analyzing operand: t20: i64 = Constant<256>
Legal operand
Legally typed node: t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20

Legalizing node: t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20
Legal operand
Legally typed node: t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20

Legalizing node: t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20

Legalizing node: t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17
Analyzing result type: v64i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
Legal operand
Analyzing operand: t8: i64 = undef
Legal operand
Legally typed node: t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17

Legalizing node: t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing operand: t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
Legal operand
Analyzing operand: t20: i64 = Constant<256>
Legal operand
Legally typed node: t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20

Legalizing node: t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20
Legal operand
Legally typed node: t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20

Legalizing node: t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20

Legalizing node: t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10
Analyzing result type: v64i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
Legal operand
Analyzing operand: t8: i64 = undef
Legal operand
Legally typed node: t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10

Legalizing node: t11: v64i32 = add nsw t10, t9, test_addarray.c:9:15
Analyzing result type: v64i32
Legal result type
Analyzing operand: t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17
Legal operand
Analyzing operand: t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10
Legal operand
Legally typed node: t11: v64i32 = add nsw t10, t9, test_addarray.c:9:15

Legalizing node: t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8
Analyzing result type: ch
Legal result type
Analyzing operand: t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10
Legal operand
Analyzing operand: t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17
Legal operand
Legally typed node: t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8

Legalizing node: t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t11, t2, undef:i64, test_addarray.c:9:8
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8
Legal operand
Analyzing operand: t11: v64i32 = add nsw t10, t9, test_addarray.c:9:15
Legal operand
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
Legal operand
Analyzing operand: t8: i64 = undef
Legal operand
Legally typed node: t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t11, t2, undef:i64, test_addarray.c:9:8

Legalizing node: t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing operand: t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
Legal operand
Analyzing operand: t20: i64 = Constant<256>
Legal operand
Legally typed node: t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20

Legalizing node: t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20
Legal operand
Legally typed node: t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20

Legalizing node: t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20

Legalizing node: t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing operand: t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20
Legal operand
Analyzing operand: t16: i64 = Constant<-64>
Legal operand
Legally typed node: t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20

Legalizing node: t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
Legal operand
Legally typed node: t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

Legalizing node: t31: i1 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20
Analyzing result type: i1
Promote integer result: t31: i1 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20

Creating new node: t40: i64 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20
Legalizing node: t40: i64 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing operand: t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
Legal operand
Analyzing operand: t7: i64 = Constant<0>
Legal operand
Analyzing operand: t30: ch = seteq
Legal operand
Legally typed node: t40: i64 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20

Legalizing node: t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t32: i64 = Constant<960>
Legal operand
Legally typed node: t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>

Legalizing node: t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20
Analyzing result type: ch
Legal result type
Analyzing operand: t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20
Legal operand
Analyzing operand: t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20
Legal operand
Analyzing operand: t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20
Legal operand
Analyzing operand: t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20
Legal operand
Analyzing operand: t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>
Legal operand
Analyzing operand: t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t11, t2, undef:i64, test_addarray.c:9:8
Legal operand
Legally typed node: t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20

Legalizing node: t37: ch = brcond t35, t31, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
Analyzing result type: ch
Legal result type
Analyzing operand: t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20
Legal operand
Analyzing operand: t31: i1 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20
Promote integer operand: t37: ch = brcond t35, t31, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20

Creating new node: t41: i64 = zero_extend t31, test_addarray.c:7:20
Legalizing node: t41: i64 = zero_extend t31, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing operand: t31: i1 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20
Promote integer operand: t41: i64 = zero_extend t31, test_addarray.c:7:20

Creating constant: t42: i64 = Constant<1>
Creating new node: t43: i64 = and t40, Constant:i64<1>, test_addarray.c:7:20
Replacing: t41: i64 = zero_extend t31, test_addarray.c:7:20
     with: t43: i64 = and t40, Constant:i64<1>, test_addarray.c:7:20
Legalizing node: t42: i64 = Constant<1>
Analyzing result type: i64
Legal result type
Legally typed node: t42: i64 = Constant<1>

Legalizing node: t43: i64 = and t40, Constant:i64<1>, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing operand: t40: i64 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20
Legal operand
Analyzing operand: t42: i64 = Constant<1>
Legal operand
Legally typed node: t43: i64 = and t40, Constant:i64<1>, test_addarray.c:7:20

Legalizing node: t37: ch = brcond t35, t43, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
Analyzing result type: ch
Legal result type
Analyzing operand: t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20
Legal operand
Analyzing operand: t43: i64 = and t40, Constant:i64<1>, test_addarray.c:7:20
Legal operand
Analyzing operand: t36: ch = BasicBlock<for.body.preheader 0xe2a908>
Legal operand
Legally typed node: t37: ch = brcond t35, t43, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20

Legalizing node: t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20
Analyzing result type: ch
Legal result type
Analyzing operand: t37: ch = brcond t35, t43, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
Legal operand
Analyzing operand: t38: ch = BasicBlock<vector.body 0xe2aa50>
Legal operand
Legally typed node: t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20

Legalizing node: t65535: ch = handlenode t39
Analyzing result type: ch
Legal result type
Analyzing operand: t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20
Legal operand
Legally typed node: t65535: ch = handlenode t39

Type-legalized selection DAG: %bb.3 'add:vector.body'
SelectionDAG has 42 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
  t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
  t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
  t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10
  t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17
    t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20
  t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
        t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20
          t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20
        t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20
          t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20
        t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20
          t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20
        t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20
        t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>
          t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8
          t11: v64i32 = add nsw t10, t9, test_addarray.c:9:15
        t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t11, t2, undef:i64, test_addarray.c:9:8
      t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20
        t40: i64 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20
      t43: i64 = and t40, Constant:i64<1>, test_addarray.c:7:20
    t37: ch = brcond t35, t43, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
  t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20



Combining: t43: i64 = and t40, Constant:i64<1>, test_addarray.c:7:20

Replacing.2 t43: i64 = and t40, Constant:i64<1>, test_addarray.c:7:20

With: t40: i64 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20


Combining: t40: i64 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20

Combining: t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20

Combining: t38: ch = BasicBlock<vector.body 0xe2aa50>

Combining: t37: ch = brcond t35, t40, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20

Combining: t36: ch = BasicBlock<for.body.preheader 0xe2a908>

Combining: t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20

Combining: t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>

Combining: t33: i64 = Register %39

Combining: t32: i64 = Constant<960>

Combining: t30: ch = seteq

Combining: t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20

Combining: t28: i64 = Register %12

Combining: t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20

Combining: t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20

Combining: t25: i64 = Register %11

Combining: t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20

Combining: t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20

Combining: t22: i64 = Register %10

Combining: t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20

Combining: t20: i64 = Constant<256>

Combining: t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

Combining: t18: i64 = Register %9

Combining: t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20

Combining: t16: i64 = Constant<-64>

Combining: t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20

Combining: t14: i64 = Register %8

Combining: t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t11, t2, undef:i64, test_addarray.c:9:8

Combining: t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8

Combining: t11: v64i32 = add nsw t10, t9, test_addarray.c:9:15

Combining: t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17

Combining: t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10

Combining: t8: i64 = undef

Combining: t7: i64 = Constant<0>

Combining: t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20

Combining: t5: i64 = Register %5

Combining: t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20

Combining: t3: i64 = Register %6

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20

Combining: t1: i64 = Register %7

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.3 'add:vector.body'
SelectionDAG has 40 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
  t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
  t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
  t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10
  t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17
    t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20
  t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
        t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20
          t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20
        t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20
          t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20
        t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20
          t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20
        t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20
        t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>
          t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8
          t11: v64i32 = add nsw t10, t9, test_addarray.c:9:15
        t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t11, t2, undef:i64, test_addarray.c:9:8
      t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20
      t40: i64 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20
    t37: ch = brcond t35, t40, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
  t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20



Legalizing vector op: t11: v64i32 = add nsw t10, t9, test_addarray.c:9:15
Trying custom legalization
Creating new node: t44: nxv16i32 = undef
Creating new node: t45: nxv16i32 = insert_subvector undef:nxv16i32, t10, Constant:i64<0>, test_addarray.c:9:17
Creating new node: t46: nxv16i32 = insert_subvector undef:nxv16i32, t9, Constant:i64<0>, test_addarray.c:9:10
Creating constant: t47: i64 = Constant<64>
Creating new node: t48: nxv16i1 = RISCVISD::VMSET_VL Constant:i64<64>, test_addarray.c:9:15
Creating new node: t49: nxv16i32 = RISCVISD::ADD_VL t45, t46, t48, Constant:i64<64>, test_addarray.c:9:15
Creating new node: t50: v64i32 = extract_subvector t49, Constant:i64<0>, test_addarray.c:9:15
Vector-legalized selection DAG: %bb.3 'add:vector.body'
SelectionDAG has 46 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
  t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
  t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
  t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17
  t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10
    t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20
  t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
        t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20
          t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20
        t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20
          t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20
        t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20
          t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20
        t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20
        t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>
          t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8
              t45: nxv16i32 = insert_subvector undef:nxv16i32, t10, Constant:i64<0>, test_addarray.c:9:17
              t46: nxv16i32 = insert_subvector undef:nxv16i32, t9, Constant:i64<0>, test_addarray.c:9:10
              t48: nxv16i1 = RISCVISD::VMSET_VL Constant:i64<64>, test_addarray.c:9:15
            t49: nxv16i32 = RISCVISD::ADD_VL t45, t46, t48, Constant:i64<64>, test_addarray.c:9:15
          t50: v64i32 = extract_subvector t49, Constant:i64<0>, test_addarray.c:9:15
        t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t50, t2, undef:i64, test_addarray.c:9:8
      t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20
      t40: i64 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20
    t37: ch = brcond t35, t40, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
  t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20


Legalizing node: t47: i64 = Constant<64>
Analyzing result type: i64
Legal result type
Legally typed node: t47: i64 = Constant<64>

Legalizing node: t48: nxv16i1 = RISCVISD::VMSET_VL Constant:i64<64>, test_addarray.c:9:15
Analyzing result type: nxv16i1
Legal result type
Analyzing operand: t47: i64 = Constant<64>
Legal operand
Legally typed node: t48: nxv16i1 = RISCVISD::VMSET_VL Constant:i64<64>, test_addarray.c:9:15

Legalizing node: t44: nxv16i32 = undef
Analyzing result type: nxv16i32
Legal result type
Legally typed node: t44: nxv16i32 = undef

Legalizing node: t38: ch = BasicBlock<vector.body 0xe2aa50>
Analyzing result type: ch
Legal result type
Legally typed node: t38: ch = BasicBlock<vector.body 0xe2aa50>

Legalizing node: t36: ch = BasicBlock<for.body.preheader 0xe2a908>
Analyzing result type: ch
Legal result type
Legally typed node: t36: ch = BasicBlock<for.body.preheader 0xe2a908>

Legalizing node: t33: i64 = Register %39
Ignoring node results
Legally typed node: t33: i64 = Register %39

Legalizing node: t32: i64 = Constant<960>
Analyzing result type: i64
Legal result type
Legally typed node: t32: i64 = Constant<960>

Legalizing node: t30: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t30: ch = seteq

Legalizing node: t28: i64 = Register %12
Ignoring node results
Legally typed node: t28: i64 = Register %12

Legalizing node: t25: i64 = Register %11
Ignoring node results
Legally typed node: t25: i64 = Register %11

Legalizing node: t22: i64 = Register %10
Ignoring node results
Legally typed node: t22: i64 = Register %10

Legalizing node: t20: i64 = Constant<256>
Analyzing result type: i64
Legal result type
Legally typed node: t20: i64 = Constant<256>

Legalizing node: t18: i64 = Register %9
Ignoring node results
Legally typed node: t18: i64 = Register %9

Legalizing node: t16: i64 = Constant<-64>
Analyzing result type: i64
Legal result type
Legally typed node: t16: i64 = Constant<-64>

Legalizing node: t14: i64 = Register %8
Ignoring node results
Legally typed node: t14: i64 = Register %8

Legalizing node: t8: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t8: i64 = undef

Legalizing node: t7: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = Constant<0>

Legalizing node: t5: i64 = Register %5
Ignoring node results
Legally typed node: t5: i64 = Register %5

Legalizing node: t3: i64 = Register %6
Ignoring node results
Legally typed node: t3: i64 = Register %6

Legalizing node: t1: i64 = Register %7
Ignoring node results
Legally typed node: t1: i64 = Register %7

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20

Legalizing node: t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
Legal operand
Analyzing operand: t20: i64 = Constant<256>
Legal operand
Legally typed node: t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20

Legalizing node: t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20
Legal operand
Legally typed node: t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20

Legalizing node: t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20

Legalizing node: t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17
Analyzing result type: v64i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
Legal operand
Analyzing operand: t8: i64 = undef
Legal operand
Legally typed node: t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17

Legalizing node: t45: nxv16i32 = insert_subvector undef:nxv16i32, t10, Constant:i64<0>, test_addarray.c:9:17
Analyzing result type: nxv16i32
Legal result type
Analyzing operand: t44: nxv16i32 = undef
Legal operand
Analyzing operand: t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17
Legal operand
Analyzing operand: t7: i64 = Constant<0>
Legal operand
Legally typed node: t45: nxv16i32 = insert_subvector undef:nxv16i32, t10, Constant:i64<0>, test_addarray.c:9:17

Legalizing node: t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing operand: t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
Legal operand
Analyzing operand: t20: i64 = Constant<256>
Legal operand
Legally typed node: t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20

Legalizing node: t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20
Legal operand
Legally typed node: t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20

Legalizing node: t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20

Legalizing node: t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10
Analyzing result type: v64i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
Legal operand
Analyzing operand: t8: i64 = undef
Legal operand
Legally typed node: t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10

Legalizing node: t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8
Analyzing result type: ch
Legal result type
Analyzing operand: t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10
Legal operand
Analyzing operand: t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17
Legal operand
Legally typed node: t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8

Legalizing node: t46: nxv16i32 = insert_subvector undef:nxv16i32, t9, Constant:i64<0>, test_addarray.c:9:10
Analyzing result type: nxv16i32
Legal result type
Analyzing operand: t44: nxv16i32 = undef
Legal operand
Analyzing operand: t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10
Legal operand
Analyzing operand: t7: i64 = Constant<0>
Legal operand
Legally typed node: t46: nxv16i32 = insert_subvector undef:nxv16i32, t9, Constant:i64<0>, test_addarray.c:9:10

Legalizing node: t49: nxv16i32 = RISCVISD::ADD_VL t45, t46, t48, Constant:i64<64>, test_addarray.c:9:15
Analyzing result type: nxv16i32
Legal result type
Analyzing operand: t45: nxv16i32 = insert_subvector undef:nxv16i32, t10, Constant:i64<0>, test_addarray.c:9:17
Legal operand
Analyzing operand: t46: nxv16i32 = insert_subvector undef:nxv16i32, t9, Constant:i64<0>, test_addarray.c:9:10
Legal operand
Analyzing operand: t48: nxv16i1 = RISCVISD::VMSET_VL Constant:i64<64>, test_addarray.c:9:15
Legal operand
Analyzing operand: t47: i64 = Constant<64>
Legal operand
Legally typed node: t49: nxv16i32 = RISCVISD::ADD_VL t45, t46, t48, Constant:i64<64>, test_addarray.c:9:15

Legalizing node: t50: v64i32 = extract_subvector t49, Constant:i64<0>, test_addarray.c:9:15
Analyzing result type: v64i32
Legal result type
Analyzing operand: t49: nxv16i32 = RISCVISD::ADD_VL t45, t46, t48, Constant:i64<64>, test_addarray.c:9:15
Legal operand
Analyzing operand: t7: i64 = Constant<0>
Legal operand
Legally typed node: t50: v64i32 = extract_subvector t49, Constant:i64<0>, test_addarray.c:9:15

Legalizing node: t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t50, t2, undef:i64, test_addarray.c:9:8
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8
Legal operand
Analyzing operand: t50: v64i32 = extract_subvector t49, Constant:i64<0>, test_addarray.c:9:15
Legal operand
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
Legal operand
Analyzing operand: t8: i64 = undef
Legal operand
Legally typed node: t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t50, t2, undef:i64, test_addarray.c:9:8

Legalizing node: t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing operand: t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
Legal operand
Analyzing operand: t20: i64 = Constant<256>
Legal operand
Legally typed node: t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20

Legalizing node: t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20
Legal operand
Legally typed node: t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20

Legalizing node: t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20

Legalizing node: t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing operand: t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20
Legal operand
Analyzing operand: t16: i64 = Constant<-64>
Legal operand
Legally typed node: t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20

Legalizing node: t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
Legal operand
Legally typed node: t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

Legalizing node: t40: i64 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20
Analyzing result type: i64
Legal result type
Analyzing operand: t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
Legal operand
Analyzing operand: t7: i64 = Constant<0>
Legal operand
Analyzing operand: t30: ch = seteq
Legal operand
Legally typed node: t40: i64 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20

Legalizing node: t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t32: i64 = Constant<960>
Legal operand
Legally typed node: t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>

Legalizing node: t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20
Analyzing result type: ch
Legal result type
Analyzing operand: t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20
Legal operand
Analyzing operand: t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20
Legal operand
Analyzing operand: t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20
Legal operand
Analyzing operand: t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20
Legal operand
Analyzing operand: t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>
Legal operand
Analyzing operand: t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t50, t2, undef:i64, test_addarray.c:9:8
Legal operand
Legally typed node: t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20

Legalizing node: t37: ch = brcond t35, t40, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
Analyzing result type: ch
Legal result type
Analyzing operand: t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20
Legal operand
Analyzing operand: t40: i64 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20
Legal operand
Analyzing operand: t36: ch = BasicBlock<for.body.preheader 0xe2a908>
Legal operand
Legally typed node: t37: ch = brcond t35, t40, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20

Legalizing node: t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20
Analyzing result type: ch
Legal result type
Analyzing operand: t37: ch = brcond t35, t40, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
Legal operand
Analyzing operand: t38: ch = BasicBlock<vector.body 0xe2aa50>
Legal operand
Legally typed node: t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20

Legalizing node: t65535: ch = handlenode t39
Analyzing result type: ch
Legal result type
Analyzing operand: t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20
Legal operand
Legally typed node: t65535: ch = handlenode t39

Vector/type-legalized selection DAG: %bb.3 'add:vector.body'
SelectionDAG has 46 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
  t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
  t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
  t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17
  t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10
    t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20
  t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
        t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20
          t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20
        t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20
          t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20
        t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20
          t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20
        t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20
        t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>
          t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8
              t45: nxv16i32 = insert_subvector undef:nxv16i32, t10, Constant:i64<0>, test_addarray.c:9:17
              t46: nxv16i32 = insert_subvector undef:nxv16i32, t9, Constant:i64<0>, test_addarray.c:9:10
              t48: nxv16i1 = RISCVISD::VMSET_VL Constant:i64<64>, test_addarray.c:9:15
            t49: nxv16i32 = RISCVISD::ADD_VL t45, t46, t48, Constant:i64<64>, test_addarray.c:9:15
          t50: v64i32 = extract_subvector t49, Constant:i64<0>, test_addarray.c:9:15
        t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t50, t2, undef:i64, test_addarray.c:9:8
      t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20
      t40: i64 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20
    t37: ch = brcond t35, t40, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
  t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20



Combining: t50: v64i32 = extract_subvector t49, Constant:i64<0>, test_addarray.c:9:15

Combining: t49: nxv16i32 = RISCVISD::ADD_VL t45, t46, t48, Constant:i64<64>, test_addarray.c:9:15

Combining: t48: nxv16i1 = RISCVISD::VMSET_VL Constant:i64<64>, test_addarray.c:9:15

Combining: t47: i64 = Constant<64>

Combining: t46: nxv16i32 = insert_subvector undef:nxv16i32, t9, Constant:i64<0>, test_addarray.c:9:10

Combining: t45: nxv16i32 = insert_subvector undef:nxv16i32, t10, Constant:i64<0>, test_addarray.c:9:17

Combining: t44: nxv16i32 = undef

Combining: t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20

Combining: t37: ch = brcond t35, t40, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20

Combining: t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20

Combining: t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t50, t2, undef:i64, test_addarray.c:9:8

Combining: t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

Combining: t40: i64 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20

Combining: t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8

Combining: t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20

Combining: t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20

Combining: t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20

Combining: t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20

Combining: t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10

Combining: t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20

Combining: t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17

Combining: t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20

Combining: t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20

Combining: t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>

Combining: t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20

Combining: t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20

Combining: t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20

Combining: t38: ch = BasicBlock<vector.body 0xe2aa50>

Combining: t36: ch = BasicBlock<for.body.preheader 0xe2a908>

Combining: t33: i64 = Register %39

Combining: t32: i64 = Constant<960>

Combining: t30: ch = seteq

Combining: t28: i64 = Register %12

Combining: t25: i64 = Register %11

Combining: t22: i64 = Register %10

Combining: t20: i64 = Constant<256>

Combining: t18: i64 = Register %9

Combining: t16: i64 = Constant<-64>

Combining: t14: i64 = Register %8

Combining: t8: i64 = undef

Combining: t7: i64 = Constant<0>

Combining: t5: i64 = Register %5

Combining: t3: i64 = Register %6

Combining: t1: i64 = Register %7

Combining: t0: ch = EntryToken
Optimized vector-legalized selection DAG: %bb.3 'add:vector.body'
SelectionDAG has 46 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
  t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
  t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
  t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17
  t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10
    t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20
  t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
        t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20
          t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20
        t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20
          t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20
        t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20
          t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20
        t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20
        t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>
          t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8
              t45: nxv16i32 = insert_subvector undef:nxv16i32, t10, Constant:i64<0>, test_addarray.c:9:17
              t46: nxv16i32 = insert_subvector undef:nxv16i32, t9, Constant:i64<0>, test_addarray.c:9:10
              t48: nxv16i1 = RISCVISD::VMSET_VL Constant:i64<64>, test_addarray.c:9:15
            t49: nxv16i32 = RISCVISD::ADD_VL t45, t46, t48, Constant:i64<64>, test_addarray.c:9:15
          t50: v64i32 = extract_subvector t49, Constant:i64<0>, test_addarray.c:9:15
        t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t50, t2, undef:i64, test_addarray.c:9:8
      t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20
      t40: i64 = setcc t17, Constant:i64<0>, seteq:ch, test_addarray.c:7:20
    t37: ch = brcond t35, t40, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
  t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20



Legalizing: t39: ch = br t37, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20
Legal node: nothing to do

Legalizing: t37: ch = brcond t35, t40, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
Trying custom legalization
Creating new node: t51: ch = RISCVISD::BR_CC t35, t17, Constant:i64<0>, seteq:ch, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
Successfully custom legalized node
 ... replacing: t37: ch = brcond t35, t40, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
     with:      t51: ch = RISCVISD::BR_CC t35, t17, Constant:i64<0>, seteq:ch, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20

Legalizing: t35: ch = TokenFactor t19, t23, t26, t29, t34, t13, test_addarray.c:7:20
Legal node: nothing to do

Legalizing: t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t50, t2, undef:i64, test_addarray.c:9:8
Legalizing store operation
Optimizing float store operations
Trying custom lowering
Creating new node: t52: ch = RISCVISD::VSE_VL<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t49, t2, Constant:i64<64>, test_addarray.c:9:8
 ... replacing: t13: ch = store<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t50, t2, undef:i64, test_addarray.c:9:8
     with:      t52: ch = RISCVISD::VSE_VL<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t49, t2, Constant:i64<64>, test_addarray.c:9:8

Legalizing: t49: nxv16i32 = RISCVISD::ADD_VL t45, t46, t48, Constant:i64<64>, test_addarray.c:9:15
Legal node: nothing to do

Legalizing: t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20
Legal node: nothing to do

Legalizing: t12: ch = TokenFactor t9:1, t10:1, test_addarray.c:9:8
Legal node: nothing to do

Legalizing: t46: nxv16i32 = insert_subvector undef:nxv16i32, t9, Constant:i64<0>, test_addarray.c:9:10
Trying custom legalization

Legalizing: t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20
Legal node: nothing to do

Legalizing: t45: nxv16i32 = insert_subvector undef:nxv16i32, t10, Constant:i64<0>, test_addarray.c:9:17
Trying custom legalization

Legalizing: t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20
Legal node: nothing to do

Legalizing: t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20
Legal node: nothing to do

Legalizing: t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
Legal node: nothing to do

Legalizing: t9: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, undef:i64, test_addarray.c:9:10
Legalizing non-extending load operation
Creating new node: t53: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, Constant:i64<64>, test_addarray.c:9:10
Creating new node: t54: v64i32 = extract_subvector t53, Constant:i64<0>, test_addarray.c:9:10
Creating new node: t55: v64i32,ch = merge_values t54, t0, test_addarray.c:9:10

Legalizing: t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20
Legal node: nothing to do

Legalizing: t10: v64i32,ch = load<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, undef:i64, test_addarray.c:9:17
Legalizing non-extending load operation
Creating new node: t56: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, Constant:i64<64>, test_addarray.c:9:17
Creating new node: t57: v64i32 = extract_subvector t56, Constant:i64<0>, test_addarray.c:9:17
Creating new node: t58: v64i32,ch = merge_values t57, t0, test_addarray.c:9:17

Legalizing: t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20
Legal node: nothing to do

Legalizing: t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20
Legal node: nothing to do

Legalizing: t48: nxv16i1 = RISCVISD::VMSET_VL Constant:i64<64>, test_addarray.c:9:15
Legal node: nothing to do

Legalizing: t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>
Legal node: nothing to do

Legalizing: t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20
Legal node: nothing to do

Legalizing: t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
Legal node: nothing to do

Legalizing: t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
Legal node: nothing to do

Legalizing: t47: i64 = Constant<64>
Legal node: nothing to do

Legalizing: t44: nxv16i32 = undef
Legal node: nothing to do

Legalizing: t38: ch = BasicBlock<vector.body 0xe2aa50>
Legal node: nothing to do

Legalizing: t36: ch = BasicBlock<for.body.preheader 0xe2a908>
Legal node: nothing to do

Legalizing: t33: i64 = Register %39

Legalizing: t32: i64 = Constant<960>
Legal node: nothing to do

Legalizing: t30: ch = seteq
Legal node: nothing to do

Legalizing: t28: i64 = Register %12

Legalizing: t25: i64 = Register %11

Legalizing: t22: i64 = Register %10

Legalizing: t20: i64 = Constant<256>
Legal node: nothing to do

Legalizing: t18: i64 = Register %9

Legalizing: t16: i64 = Constant<-64>
Legal node: nothing to do

Legalizing: t14: i64 = Register %8

Legalizing: t7: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t5: i64 = Register %5

Legalizing: t3: i64 = Register %6

Legalizing: t1: i64 = Register %7

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t58: v64i32,ch = merge_values t57, t0, test_addarray.c:9:17
Trying to expand node
Successfully expanded node
 ... replacing: t58: v64i32,ch = merge_values t57, t0, test_addarray.c:9:17
     with:      t57: v64i32 = extract_subvector t56, Constant:i64<0>, test_addarray.c:9:17
      and:      t0: ch = EntryToken

Legalizing: t57: v64i32 = extract_subvector t56, Constant:i64<0>, test_addarray.c:9:17
Trying custom legalization

Legalizing: t56: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, Constant:i64<64>, test_addarray.c:9:17
Legal node: nothing to do

Legalizing: t55: v64i32,ch = merge_values t54, t0, test_addarray.c:9:10
Trying to expand node
Successfully expanded node
 ... replacing: t55: v64i32,ch = merge_values t54, t0, test_addarray.c:9:10
     with:      t54: v64i32 = extract_subvector t53, Constant:i64<0>, test_addarray.c:9:10
      and:      t0: ch = EntryToken

Legalizing: t54: v64i32 = extract_subvector t53, Constant:i64<0>, test_addarray.c:9:10
Trying custom legalization

Legalizing: t53: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, Constant:i64<64>, test_addarray.c:9:10
Legal node: nothing to do

Legalizing: t52: ch = RISCVISD::VSE_VL<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t49, t2, Constant:i64<64>, test_addarray.c:9:8
Legal node: nothing to do

Legalizing: t51: ch = RISCVISD::BR_CC t35, t17, Constant:i64<0>, seteq:ch, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
Legal node: nothing to do
Legalized selection DAG: %bb.3 'add:vector.body'
SelectionDAG has 45 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
  t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
  t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
    t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20
  t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
        t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20
          t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20
        t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20
          t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20
        t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20
          t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20
        t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20
        t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>
          t12: ch = TokenFactor t0, t0, test_addarray.c:9:8
                t56: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, Constant:i64<64>, test_addarray.c:9:17
              t57: v64i32 = extract_subvector t56, Constant:i64<0>, test_addarray.c:9:17
            t45: nxv16i32 = insert_subvector undef:nxv16i32, t57, Constant:i64<0>, test_addarray.c:9:17
                t53: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, Constant:i64<64>, test_addarray.c:9:10
              t54: v64i32 = extract_subvector t53, Constant:i64<0>, test_addarray.c:9:10
            t46: nxv16i32 = insert_subvector undef:nxv16i32, t54, Constant:i64<0>, test_addarray.c:9:10
            t48: nxv16i1 = RISCVISD::VMSET_VL Constant:i64<64>, test_addarray.c:9:15
          t49: nxv16i32 = RISCVISD::ADD_VL t45, t46, t48, Constant:i64<64>, test_addarray.c:9:15
        t52: ch = RISCVISD::VSE_VL<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t49, t2, Constant:i64<64>, test_addarray.c:9:8
      t35: ch = TokenFactor t19, t23, t26, t29, t34, t52, test_addarray.c:7:20
    t51: ch = RISCVISD::BR_CC t35, t17, Constant:i64<0>, seteq:ch, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
  t39: ch = br t51, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20



Legalizing: t57: v64i32 = extract_subvector t56, Constant:i64<0>, test_addarray.c:9:17
Trying custom legalization

Combining: t57: v64i32 = extract_subvector t56, Constant:i64<0>, test_addarray.c:9:17

Legalizing: t56: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, Constant:i64<64>, test_addarray.c:9:17
Legal node: nothing to do

Combining: t56: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, Constant:i64<64>, test_addarray.c:9:17

Legalizing: t54: v64i32 = extract_subvector t53, Constant:i64<0>, test_addarray.c:9:10
Trying custom legalization

Combining: t54: v64i32 = extract_subvector t53, Constant:i64<0>, test_addarray.c:9:10

Legalizing: t53: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, Constant:i64<64>, test_addarray.c:9:10
Legal node: nothing to do

Combining: t53: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, Constant:i64<64>, test_addarray.c:9:10

Legalizing: t52: ch = RISCVISD::VSE_VL<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t49, t2, Constant:i64<64>, test_addarray.c:9:8
Legal node: nothing to do

Combining: t52: ch = RISCVISD::VSE_VL<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t12, t49, t2, Constant:i64<64>, test_addarray.c:9:8

Legalizing: t51: ch = RISCVISD::BR_CC t35, t17, Constant:i64<0>, seteq:ch, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
Legal node: nothing to do

Combining: t51: ch = RISCVISD::BR_CC t35, t17, Constant:i64<0>, seteq:ch, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20

Legalizing: t39: ch = br t51, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20
Legal node: nothing to do

Combining: t39: ch = br t51, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20

Legalizing: t35: ch = TokenFactor t19, t23, t26, t29, t34, t52, test_addarray.c:7:20
Legal node: nothing to do

Combining: t35: ch = TokenFactor t19, t23, t26, t29, t34, t52, test_addarray.c:7:20

Legalizing: t49: nxv16i32 = RISCVISD::ADD_VL t45, t46, t48, Constant:i64<64>, test_addarray.c:9:15
Legal node: nothing to do

Combining: t49: nxv16i32 = RISCVISD::ADD_VL t45, t46, t48, Constant:i64<64>, test_addarray.c:9:15

Legalizing: t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20
Legal node: nothing to do

Combining: t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

Legalizing: t12: ch = TokenFactor t0, t0, test_addarray.c:9:8
Legal node: nothing to do

Combining: t12: ch = TokenFactor t0, t0, test_addarray.c:9:8
 ... into: t0: ch = EntryToken

Legalizing: t46: nxv16i32 = insert_subvector undef:nxv16i32, t54, Constant:i64<0>, test_addarray.c:9:10
Trying custom legalization

Combining: t46: nxv16i32 = insert_subvector undef:nxv16i32, t54, Constant:i64<0>, test_addarray.c:9:10
 ... into: t53: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, Constant:i64<64>, test_addarray.c:9:10

Legalizing: t49: nxv16i32 = RISCVISD::ADD_VL t45, t53, t48, Constant:i64<64>, test_addarray.c:9:15
Legal node: nothing to do

Combining: t49: nxv16i32 = RISCVISD::ADD_VL t45, t53, t48, Constant:i64<64>, test_addarray.c:9:15

Legalizing: t53: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, Constant:i64<64>, test_addarray.c:9:10
Legal node: nothing to do

Combining: t53: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, Constant:i64<64>, test_addarray.c:9:10

Legalizing: t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20
Legal node: nothing to do

Combining: t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20

Legalizing: t45: nxv16i32 = insert_subvector undef:nxv16i32, t57, Constant:i64<0>, test_addarray.c:9:17
Trying custom legalization

Combining: t45: nxv16i32 = insert_subvector undef:nxv16i32, t57, Constant:i64<0>, test_addarray.c:9:17
 ... into: t56: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, Constant:i64<64>, test_addarray.c:9:17

Legalizing: t49: nxv16i32 = RISCVISD::ADD_VL t56, t53, t48, Constant:i64<64>, test_addarray.c:9:15
Legal node: nothing to do

Combining: t49: nxv16i32 = RISCVISD::ADD_VL t56, t53, t48, Constant:i64<64>, test_addarray.c:9:15

Legalizing: t56: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, Constant:i64<64>, test_addarray.c:9:17
Legal node: nothing to do

Combining: t56: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, Constant:i64<64>, test_addarray.c:9:17

Legalizing: t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20
Legal node: nothing to do

Combining: t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20

Legalizing: t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20
Legal node: nothing to do

Combining: t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20

Legalizing: t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
Legal node: nothing to do

Combining: t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20

Legalizing: t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20
Legal node: nothing to do

Combining: t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20

Legalizing: t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20
Legal node: nothing to do

Combining: t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20

Legalizing: t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20
Legal node: nothing to do

Combining: t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20

Legalizing: t48: nxv16i1 = RISCVISD::VMSET_VL Constant:i64<64>, test_addarray.c:9:15
Legal node: nothing to do

Combining: t48: nxv16i1 = RISCVISD::VMSET_VL Constant:i64<64>, test_addarray.c:9:15

Legalizing: t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>
Legal node: nothing to do

Combining: t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>

Legalizing: t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20
Legal node: nothing to do

Combining: t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20

Legalizing: t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
Legal node: nothing to do

Combining: t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20

Legalizing: t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
Legal node: nothing to do

Combining: t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20

Legalizing: t47: i64 = Constant<64>
Legal node: nothing to do

Combining: t47: i64 = Constant<64>

Legalizing: t38: ch = BasicBlock<vector.body 0xe2aa50>
Legal node: nothing to do

Combining: t38: ch = BasicBlock<vector.body 0xe2aa50>

Legalizing: t36: ch = BasicBlock<for.body.preheader 0xe2a908>
Legal node: nothing to do

Combining: t36: ch = BasicBlock<for.body.preheader 0xe2a908>

Legalizing: t33: i64 = Register %39

Combining: t33: i64 = Register %39

Legalizing: t32: i64 = Constant<960>
Legal node: nothing to do

Combining: t32: i64 = Constant<960>

Legalizing: t30: ch = seteq
Legal node: nothing to do

Combining: t30: ch = seteq

Legalizing: t28: i64 = Register %12

Combining: t28: i64 = Register %12

Legalizing: t25: i64 = Register %11

Combining: t25: i64 = Register %11

Legalizing: t22: i64 = Register %10

Combining: t22: i64 = Register %10

Legalizing: t20: i64 = Constant<256>
Legal node: nothing to do

Combining: t20: i64 = Constant<256>

Legalizing: t18: i64 = Register %9

Combining: t18: i64 = Register %9

Legalizing: t16: i64 = Constant<-64>
Legal node: nothing to do

Combining: t16: i64 = Constant<-64>

Legalizing: t14: i64 = Register %8

Combining: t14: i64 = Register %8

Legalizing: t7: i64 = Constant<0>
Legal node: nothing to do

Combining: t7: i64 = Constant<0>

Legalizing: t5: i64 = Register %5

Combining: t5: i64 = Register %5

Legalizing: t3: i64 = Register %6

Combining: t3: i64 = Register %6

Legalizing: t1: i64 = Register %7

Combining: t1: i64 = Register %7

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.3 'add:vector.body'
SelectionDAG has 39 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
  t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
  t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
    t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20
  t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
        t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20
          t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20
        t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20
          t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20
        t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20
          t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20
        t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20
        t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>
            t56: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, Constant:i64<64>, test_addarray.c:9:17
            t53: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, Constant:i64<64>, test_addarray.c:9:10
            t48: nxv16i1 = RISCVISD::VMSET_VL Constant:i64<64>, test_addarray.c:9:15
          t49: nxv16i32 = RISCVISD::ADD_VL t56, t53, t48, Constant:i64<64>, test_addarray.c:9:15
        t52: ch = RISCVISD::VSE_VL<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t0, t49, t2, Constant:i64<64>, test_addarray.c:9:8
      t35: ch = TokenFactor t19, t23, t26, t29, t34, t52, test_addarray.c:7:20
    t51: ch = RISCVISD::BR_CC t35, t17, Constant:i64<0>, seteq:ch, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
  t39: ch = br t51, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20


===== Instruction selection begins: %bb.3 'vector.body'

ISEL: Starting selection on root node: t39: ch = br t51, BasicBlock:ch<vector.body 0xe2aa50>, test_addarray.c:7:20
ISEL: Starting pattern match
  Initial Opcode index to 895177
  Morphed node: t39: ch = PseudoBR BasicBlock:ch<vector.body 0xe2aa50>, t51, test_addarray.c:7:20
ISEL: Match complete!

ISEL: Starting selection on root node: t51: ch = RISCVISD::BR_CC t35, t17, Constant:i64<0>, seteq:ch, BasicBlock:ch<for.body.preheader 0xe2a908>, test_addarray.c:7:20
ISEL: Starting pattern match
  Initial Opcode index to 907160
  Morphed node: t51: ch = BEQ t17, Constant:i64<0>, BasicBlock:ch<for.body.preheader 0xe2a908>, t35, test_addarray.c:7:20
ISEL: Match complete!

ISEL: Starting selection on root node: t35: ch = TokenFactor t19, t23, t26, t29, t34, t52, test_addarray.c:7:20

ISEL: Starting selection on root node: t52: ch = RISCVISD::VSE_VL<(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t0, t49, t2, Constant:i64<64>, test_addarray.c:9:8
ISEL: Starting pattern match
  Initial Opcode index to 40395
  Skipped scope entry (due to false predicate) at index 40400, continuing at 40454
  Skipped scope entry (due to false predicate) at index 40455, continuing at 40509
  Skipped scope entry (due to false predicate) at index 40510, continuing at 40564
  Skipped scope entry (due to false predicate) at index 40565, continuing at 40619
  Skipped scope entry (due to false predicate) at index 40620, continuing at 40674
  Skipped scope entry (due to false predicate) at index 40675, continuing at 40729
  Skipped scope entry (due to false predicate) at index 40730, continuing at 40784
  Skipped scope entry (due to false predicate) at index 40785, continuing at 40839
  Skipped scope entry (due to false predicate) at index 40840, continuing at 40894
  Skipped scope entry (due to false predicate) at index 40895, continuing at 40949
  Skipped scope entry (due to false predicate) at index 40950, continuing at 41004
  Skipped scope entry (due to false predicate) at index 41005, continuing at 41059
  Skipped scope entry (due to false predicate) at index 41060, continuing at 41114
  Skipped scope entry (due to false predicate) at index 41115, continuing at 41169
  Skipped scope entry (due to false predicate) at index 41170, continuing at 41224
  Skipped scope entry (due to false predicate) at index 41225, continuing at 41279
  Skipped scope entry (due to false predicate) at index 41280, continuing at 41334
  Skipped scope entry (due to false predicate) at index 41335, continuing at 41389
Creating constant: t59: i64 = TargetConstant<5>
  Morphed node: t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, Constant:i64<64>, TargetConstant:i64<5>, t0, test_addarray.c:9:8
ISEL: Match complete!

ISEL: Starting selection on root node: t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

ISEL: Starting selection on root node: t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20

ISEL: Starting selection on root node: t49: nxv16i32 = RISCVISD::ADD_VL t56, t53, t48, Constant:i64<64>, test_addarray.c:9:15
ISEL: Starting pattern match
  Initial Opcode index to 974106
  Match failed at index 974111
  Continuing at 978291
  Match failed at index 978294
  Continuing at 978445
  Match failed at index 978448
  Continuing at 978549
  Match failed at index 978552
  Continuing at 978703
  Match failed at index 978706
  Continuing at 978807
  Match failed at index 978810
  Continuing at 978961
  Match failed at index 978964
  Continuing at 979065
  Match failed at index 979068
  Continuing at 979219
  Match failed at index 979222
  Continuing at 979323
  Match failed at index 979326
  Continuing at 979477
  Match failed at index 979480
  Continuing at 979581
  Match failed at index 979584
  Continuing at 979735
  Match failed at index 979738
  Continuing at 979839
  Match failed at index 979842
  Continuing at 979993
  Match failed at index 979996
  Continuing at 980097
  Match failed at index 980100
  Continuing at 980251
  Match failed at index 980254
  Continuing at 980355
  Match failed at index 980358
  Continuing at 980509
  Match failed at index 980512
  Continuing at 980613
  Match failed at index 980616
  Continuing at 980767
  Match failed at index 980770
  Continuing at 980871
  Match failed at index 980874
  Continuing at 981025
  Match failed at index 981028
  Continuing at 981129
  Match failed at index 981132
  Continuing at 981283
  Match failed at index 981286
  Continuing at 981387
  Match failed at index 981390
  Continuing at 981541
  Match failed at index 981544
  Continuing at 981645
  Match failed at index 981648
  Continuing at 981799
  Match failed at index 981802
  Continuing at 981903
  Match failed at index 981906
  Continuing at 982057
  Match failed at index 982060
  Continuing at 982161
  Match failed at index 982164
  Continuing at 982315
  Match failed at index 982318
  Continuing at 982419
  Match failed at index 982422
  Continuing at 982573
  Match failed at index 982576
  Continuing at 982677
  Match failed at index 982680
  Continuing at 982831
  Match failed at index 982834
  Continuing at 982935
  Match failed at index 982938
  Continuing at 983089
  Match failed at index 983092
  Continuing at 983193
  Match failed at index 983196
  Continuing at 983347
  Match failed at index 983350
  Continuing at 983451
  Match failed at index 983454
  Continuing at 983605
  Match failed at index 983608
  Continuing at 983709
  Match failed at index 983712
  Continuing at 983863
  Match failed at index 983866
  Continuing at 983969
  Match failed at index 983972
  Continuing at 984125
  Match failed at index 984128
  Continuing at 984231
  Match failed at index 984234
  Continuing at 984387
  Match failed at index 984390
  Continuing at 984493
  Match failed at index 984496
  Continuing at 984649
  Match failed at index 984652
  Continuing at 984755
  Match failed at index 984758
  Continuing at 984911
  Match failed at index 984914
  Continuing at 985017
  Match failed at index 985020
  Continuing at 985173
  Match failed at index 985176
  Continuing at 985279
  Match failed at index 985282
  Continuing at 985435
  Match failed at index 985438
  Continuing at 985541
  Match failed at index 985544
  Continuing at 985697
  Match failed at index 985700
  Continuing at 985803
  Match failed at index 985806
  Continuing at 985959
  Match failed at index 985962
  Continuing at 986065
  Match failed at index 986068
  Continuing at 986221
  Match failed at index 986224
  Continuing at 986327
  Match failed at index 986330
  Continuing at 986483
  Match failed at index 986486
  Continuing at 986589
  Match failed at index 986592
  Continuing at 986745
  Match failed at index 986748
  Continuing at 986851
  Match failed at index 986854
  Continuing at 987007
  Match failed at index 987010
  Continuing at 987113
  Match failed at index 987116
  Continuing at 987269
  Match failed at index 987272
  Continuing at 987375
  Match failed at index 987378
  Continuing at 987531
  Match failed at index 987534
  Continuing at 987637
  Match failed at index 987640
  Continuing at 987793
  Match failed at index 987796
  Continuing at 987899
  Match failed at index 987902
  Continuing at 988055
  Match failed at index 988058
  Continuing at 988161
  Match failed at index 988164
  Continuing at 988317
  Match failed at index 988320
  Continuing at 988423
  Match failed at index 988426
  Continuing at 988579
  Match failed at index 988582
  Continuing at 988685
  Match failed at index 988688
  Continuing at 988841
  Match failed at index 988844
  Continuing at 988947
  Match failed at index 988950
  Continuing at 989103
  Match failed at index 989106
  Continuing at 989209
  Match failed at index 989212
  Continuing at 989365
  Match failed at index 989368
  Continuing at 989471
  Match failed at index 989474
  Continuing at 989627
  Match failed at index 989630
  Continuing at 989733
  Match failed at index 989736
  Continuing at 989889
  Match failed at index 989892
  Continuing at 989995
  Match failed at index 989998
  Continuing at 990151
  Match failed at index 990154
  Continuing at 990257
  Match failed at index 990260
  Continuing at 990413
  Match failed at index 990416
  Continuing at 990519
  Match failed at index 990522
  Continuing at 990675
  Match failed at index 990678
  Continuing at 990781
  Match failed at index 990784
  Continuing at 990937
  Match failed at index 990940
  Continuing at 991043
  Match failed at index 991046
  Continuing at 991199
  Match failed at index 991202
  Continuing at 991305
  Match failed at index 991308
  Continuing at 991461
  Match failed at index 991464
  Continuing at 991567
  Match failed at index 991570
  Continuing at 991723
  Match failed at index 991727
  Continuing at 995547
  Match failed at index 995550
  Continuing at 999432
  TypeSwitch[nxv16i32] from 999452 to 1001003
  Match failed at index 1001007
  Continuing at 1001026
  Match failed at index 1001027
  Continuing at 1001046
  Match failed at index 1001047
  Continuing at 1001066
  Match failed at index 1001067
  Continuing at 1001086
  Continuing at 1001346
  Match failed at index 1001348
  Continuing at 1003248
  Continuing at 1003249
  TypeSwitch[nxv16i32] from 1003258 to 1005385
  Match failed at index 1005389
  Continuing at 1005416
  Match failed at index 1005417
  Continuing at 1005444
  Match failed at index 1005445
  Continuing at 1005472
  Match failed at index 1005473
  Continuing at 1005500
  Continuing at 1005856
  Match failed at index 1005858
  Continuing at 1008458
  Continuing at 1008459
  TypeSwitch[nxv16i32] from 1008474 to 1008837
  Morphed node: t49: nxv16i32 = PseudoVADD_VV_M8 t56, t53, Constant:i64<64>, TargetConstant:i64<5>, test_addarray.c:9:15
ISEL: Match complete!

ISEL: Starting selection on root node: t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20

ISEL: Starting selection on root node: t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20

ISEL: Starting selection on root node: t17: i64 = add nsw t15, Constant:i64<-64>, test_addarray.c:7:20
ISEL: Starting pattern match
  Initial Opcode index to 16032
  Skipped scope entry (due to false predicate) at index 16038, continuing at 16121
  Skipped scope entry (due to false predicate) at index 16122, continuing at 16156
  Skipped scope entry (due to false predicate) at index 16157, continuing at 16191
  Skipped scope entry (due to false predicate) at index 16192, continuing at 16226
  Match failed at index 16036
  Continuing at 16227
  Skipped scope entry (due to false predicate) at index 16240, continuing at 16308
  Skipped scope entry (due to false predicate) at index 16309, continuing at 16338
  Skipped scope entry (due to false predicate) at index 16339, continuing at 16368
  Skipped scope entry (due to false predicate) at index 16369, continuing at 16398
  Match failed at index 16238
  Continuing at 16399
  TypeSwitch[i64] from 16408 to 16411
  Match failed at index 16413
  Continuing at 16444
  Continuing at 16445
  Skipped scope entry (due to false predicate) at index 16451, continuing at 16598
  Skipped scope entry (due to false predicate) at index 16599, continuing at 16624
  Match failed at index 16448
  Continuing at 16625
  Skipped scope entry (due to false predicate) at index 16635, continuing at 16752
  Skipped scope entry (due to false predicate) at index 16753, continuing at 16773
  Match failed at index 16633
  Continuing at 16774
  Match failed at index 16777
  Continuing at 17225
  Match failed at index 17232
  Continuing at 17671
  TypeSwitch[i64] from 17685 to 17688
Creating constant: t60: i64 = TargetConstant<-64>
  Morphed node: t17: i64 = ADDI nsw t15, TargetConstant:i64<-64>, test_addarray.c:7:20
ISEL: Match complete!

ISEL: Starting selection on root node: t27: i64 = add t6, Constant:i64<256>, test_addarray.c:7:20
ISEL: Starting pattern match
  Initial Opcode index to 16032
  Skipped scope entry (due to false predicate) at index 16038, continuing at 16121
  Skipped scope entry (due to false predicate) at index 16122, continuing at 16156
  Skipped scope entry (due to false predicate) at index 16157, continuing at 16191
  Skipped scope entry (due to false predicate) at index 16192, continuing at 16226
  Match failed at index 16036
  Continuing at 16227
  Skipped scope entry (due to false predicate) at index 16240, continuing at 16308
  Skipped scope entry (due to false predicate) at index 16309, continuing at 16338
  Skipped scope entry (due to false predicate) at index 16339, continuing at 16368
  Skipped scope entry (due to false predicate) at index 16369, continuing at 16398
  Match failed at index 16238
  Continuing at 16399
  TypeSwitch[i64] from 16408 to 16411
  Match failed at index 16413
  Continuing at 16444
  Continuing at 16445
  Skipped scope entry (due to false predicate) at index 16451, continuing at 16598
  Skipped scope entry (due to false predicate) at index 16599, continuing at 16624
  Match failed at index 16448
  Continuing at 16625
  Skipped scope entry (due to false predicate) at index 16635, continuing at 16752
  Skipped scope entry (due to false predicate) at index 16753, continuing at 16773
  Match failed at index 16633
  Continuing at 16774
  Match failed at index 16777
  Continuing at 17225
  Match failed at index 17232
  Continuing at 17671
  TypeSwitch[i64] from 17685 to 17688
Creating constant: t61: i64 = TargetConstant<256>
  Morphed node: t27: i64 = ADDI t6, TargetConstant:i64<256>, test_addarray.c:7:20
ISEL: Match complete!

ISEL: Starting selection on root node: t53: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t0, t6, Constant:i64<64>, test_addarray.c:9:10
ISEL: Starting pattern match
  Initial Opcode index to 1273858
  TypeSwitch[nxv16i32] from 1273867 to 1274284
  Morphed node: t53: nxv16i32,ch = PseudoVLE32_V_M8<Mem:(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t6, Constant:i64<64>, TargetConstant:i64<5>, t0, test_addarray.c:9:10
ISEL: Match complete!

ISEL: Starting selection on root node: t24: i64 = add t4, Constant:i64<256>, test_addarray.c:7:20
ISEL: Starting pattern match
  Initial Opcode index to 16032
  Skipped scope entry (due to false predicate) at index 16038, continuing at 16121
  Skipped scope entry (due to false predicate) at index 16122, continuing at 16156
  Skipped scope entry (due to false predicate) at index 16157, continuing at 16191
  Skipped scope entry (due to false predicate) at index 16192, continuing at 16226
  Match failed at index 16036
  Continuing at 16227
  Skipped scope entry (due to false predicate) at index 16240, continuing at 16308
  Skipped scope entry (due to false predicate) at index 16309, continuing at 16338
  Skipped scope entry (due to false predicate) at index 16339, continuing at 16368
  Skipped scope entry (due to false predicate) at index 16369, continuing at 16398
  Match failed at index 16238
  Continuing at 16399
  TypeSwitch[i64] from 16408 to 16411
  Match failed at index 16413
  Continuing at 16444
  Continuing at 16445
  Skipped scope entry (due to false predicate) at index 16451, continuing at 16598
  Skipped scope entry (due to false predicate) at index 16599, continuing at 16624
  Match failed at index 16448
  Continuing at 16625
  Skipped scope entry (due to false predicate) at index 16635, continuing at 16752
  Skipped scope entry (due to false predicate) at index 16753, continuing at 16773
  Match failed at index 16633
  Continuing at 16774
  Match failed at index 16777
  Continuing at 17225
  Match failed at index 17232
  Continuing at 17671
  TypeSwitch[i64] from 17685 to 17688
  Morphed node: t24: i64 = ADDI t4, TargetConstant:i64<256>, test_addarray.c:7:20
ISEL: Match complete!

ISEL: Starting selection on root node: t56: nxv16i32,ch = RISCVISD::VLE_VL<(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t0, t4, Constant:i64<64>, test_addarray.c:9:17
ISEL: Starting pattern match
  Initial Opcode index to 1273858
  TypeSwitch[nxv16i32] from 1273867 to 1274284
  Morphed node: t56: nxv16i32,ch = PseudoVLE32_V_M8<Mem:(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t4, Constant:i64<64>, TargetConstant:i64<5>, t0, test_addarray.c:9:17
ISEL: Match complete!

ISEL: Starting selection on root node: t21: i64 = add t2, Constant:i64<256>, test_addarray.c:7:20
ISEL: Starting pattern match
  Initial Opcode index to 16032
  Skipped scope entry (due to false predicate) at index 16038, continuing at 16121
  Skipped scope entry (due to false predicate) at index 16122, continuing at 16156
  Skipped scope entry (due to false predicate) at index 16157, continuing at 16191
  Skipped scope entry (due to false predicate) at index 16192, continuing at 16226
  Match failed at index 16036
  Continuing at 16227
  Skipped scope entry (due to false predicate) at index 16240, continuing at 16308
  Skipped scope entry (due to false predicate) at index 16309, continuing at 16338
  Skipped scope entry (due to false predicate) at index 16339, continuing at 16368
  Skipped scope entry (due to false predicate) at index 16369, continuing at 16398
  Match failed at index 16238
  Continuing at 16399
  TypeSwitch[i64] from 16408 to 16411
  Match failed at index 16413
  Continuing at 16444
  Continuing at 16445
  Skipped scope entry (due to false predicate) at index 16451, continuing at 16598
  Skipped scope entry (due to false predicate) at index 16599, continuing at 16624
  Match failed at index 16448
  Continuing at 16625
  Skipped scope entry (due to false predicate) at index 16635, continuing at 16752
  Skipped scope entry (due to false predicate) at index 16753, continuing at 16773
  Match failed at index 16633
  Continuing at 16774
  Match failed at index 16777
  Continuing at 17225
  Match failed at index 17232
  Continuing at 17671
  TypeSwitch[i64] from 17685 to 17688
  Morphed node: t21: i64 = ADDI t2, TargetConstant:i64<256>, test_addarray.c:7:20
ISEL: Match complete!

ISEL: Starting selection on root node: t34: ch = CopyToReg t0, Register:i64 %39, Constant:i64<960>

ISEL: Starting selection on root node: t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20

ISEL: Starting selection on root node: t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20

ISEL: Starting selection on root node: t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20

ISEL: Starting selection on root node: t47: i64 = Constant<64>
Creating constant: t63: i64 = TargetConstant<64>
Creating new machine node: t64: i64 = ADDI Register:i64 $x0, TargetConstant:i64<64>

ISEL: Starting selection on root node: t38: ch = BasicBlock<vector.body 0xe2aa50>

ISEL: Starting selection on root node: t36: ch = BasicBlock<for.body.preheader 0xe2a908>

ISEL: Starting selection on root node: t33: i64 = Register %39

ISEL: Starting selection on root node: t32: i64 = Constant<960>
Creating constant: t65: i64 = TargetConstant<960>
Creating new machine node: t66: i64 = ADDI Register:i64 $x0, TargetConstant:i64<960>

ISEL: Starting selection on root node: t28: i64 = Register %12

ISEL: Starting selection on root node: t25: i64 = Register %11

ISEL: Starting selection on root node: t22: i64 = Register %10

ISEL: Starting selection on root node: t18: i64 = Register %9

ISEL: Starting selection on root node: t14: i64 = Register %8

ISEL: Starting selection on root node: t7: i64 = Constant<0>
Creating new node: t67: i64,ch = CopyFromReg t0, Register:i64 $x0

ISEL: Starting selection on root node: t5: i64 = Register %5

ISEL: Starting selection on root node: t3: i64 = Register %6

ISEL: Starting selection on root node: t1: i64 = Register %7

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.3 'add:vector.body'
SelectionDAG has 41 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20
  t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20
  t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20
    t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20
  t17: i64 = ADDI nsw t15, TargetConstant:i64<-64>, test_addarray.c:7:20
  t64: i64 = ADDI Register:i64 $x0, TargetConstant:i64<64>
      t67: i64,ch = CopyFromReg t0, Register:i64 $x0
        t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20
          t21: i64 = ADDI t2, TargetConstant:i64<256>, test_addarray.c:7:20
        t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20
          t24: i64 = ADDI t4, TargetConstant:i64<256>, test_addarray.c:7:20
        t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20
          t27: i64 = ADDI t6, TargetConstant:i64<256>, test_addarray.c:7:20
        t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20
          t66: i64 = ADDI Register:i64 $x0, TargetConstant:i64<960>
        t34: ch = CopyToReg t0, Register:i64 %39, t66
            t56: nxv16i32,ch = PseudoVLE32_V_M8<Mem:(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t4, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:17
            t53: nxv16i32,ch = PseudoVLE32_V_M8<Mem:(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t6, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:10
          t49: nxv16i32 = PseudoVADD_VV_M8 t56, t53, t64, TargetConstant:i64<5>, test_addarray.c:9:15
        t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:8
      t35: ch = TokenFactor t19, t23, t26, t29, t34, t52, test_addarray.c:7:20
    t51: ch = BEQ t17, t67, BasicBlock:ch<for.body.preheader 0xe2a908>, t35, test_addarray.c:7:20
  t39: ch = PseudoBR BasicBlock:ch<vector.body 0xe2aa50>, t51, test_addarray.c:7:20


********** List Scheduling %bb.3 'vector.body' **********
SU(0): t39: ch = PseudoBR BasicBlock:ch<vector.body 0xe2aa50>, t51, test_addarray.c:7:20

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t51: ch = BEQ t17, t67, BasicBlock:ch<for.body.preheader 0xe2a908>, t35, test_addarray.c:7:20

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(21): Data Latency=1
    SU(20): Data Latency=1
    SU(2): Ord  Latency=0 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t35: ch = TokenFactor t19, t23, t26, t29, t34, t52, test_addarray.c:7:20

  # preds left       : 6
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(19): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(13): Ord  Latency=1 Barrier
    SU(11): Ord  Latency=1 Barrier
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(3): t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:8

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1
    SU(5): Data Latency=1
    SU(4): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(4): t64: i64 = ADDI Register:i64 $x0, TargetConstant:i64<64>

  # preds left       : 0
  # succs left       : 4
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(3): Data Latency=1
    SU(6): Data Latency=1
    SU(7): Data Latency=1
    SU(9): Data Latency=1
SU(5): t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Data Latency=1
    SU(18): Data Latency=1
SU(6): t49: nxv16i32 = PseudoVADD_VV_M8 t56, t53, t64, TargetConstant:i64<5>, test_addarray.c:9:15

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(9): Data Latency=1
    SU(7): Data Latency=1
    SU(4): Data Latency=1
  Successors:
    SU(3): Data Latency=1
SU(7): t53: nxv16i32,ch = PseudoVLE32_V_M8<Mem:(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t6, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:10

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(8): Data Latency=1
    SU(4): Data Latency=1
  Successors:
    SU(6): Data Latency=1
SU(8): t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(7): Data Latency=1
    SU(14): Data Latency=1
SU(9): t56: nxv16i32,ch = PseudoVLE32_V_M8<Mem:(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t4, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:17

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(10): Data Latency=1
    SU(4): Data Latency=1
  Successors:
    SU(6): Data Latency=1
SU(10): t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(9): Data Latency=1
    SU(16): Data Latency=1
SU(11): t34: ch = CopyToReg t0, Register:i64 %39, t66

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(12): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(12): t66: i64 = ADDI Register:i64 $x0, TargetConstant:i64<960>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(11): Data Latency=1
SU(13): t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(14): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(14): t27: i64 = ADDI t6, TargetConstant:i64<256>, test_addarray.c:7:20

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(8): Data Latency=1
  Successors:
    SU(13): Data Latency=1
SU(15): t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(16): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(16): t24: i64 = ADDI t4, TargetConstant:i64<256>, test_addarray.c:7:20

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(10): Data Latency=1
  Successors:
    SU(15): Data Latency=1
SU(17): t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(18): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(18): t21: i64 = ADDI t2, TargetConstant:i64<256>, test_addarray.c:7:20

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(17): Data Latency=1
SU(19): t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(21): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(20): t67: i64,ch = CopyFromReg t0, Register:i64 $x0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(21): t17: i64 = ADDI nsw t15, TargetConstant:i64<-64>, test_addarray.c:7:20

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(22): Data Latency=1
  Successors:
    SU(1): Data Latency=1
    SU(19): Data Latency=1
SU(22): t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(21): Data Latency=1
VRegCycle: SU(14)
VRegCycle: SU(16)
VRegCycle: SU(18)

Examining Available:
Height 0: SU(0): t39: ch = PseudoBR BasicBlock:ch<vector.body 0xe2aa50>, t51, test_addarray.c:7:20


*** Scheduling [0]: SU(0): t39: ch = PseudoBR BasicBlock:ch<vector.body 0xe2aa50>, t51, test_addarray.c:7:20


Examining Available:
Height 1: SU(1): t51: ch = BEQ t17, t67, BasicBlock:ch<for.body.preheader 0xe2a908>, t35, test_addarray.c:7:20


*** Scheduling [1]: SU(1): t51: ch = BEQ t17, t67, BasicBlock:ch<for.body.preheader 0xe2a908>, t35, test_addarray.c:7:20


Examining Available:
Height 1: SU(2): t35: ch = TokenFactor t19, t23, t26, t29, t34, t52, test_addarray.c:7:20

Height 2: SU(20): t67: i64,ch = CopyFromReg t0, Register:i64 $x0


*** Scheduling [2]: SU(2): t35: ch = TokenFactor t19, t23, t26, t29, t34, t52, test_addarray.c:7:20


Examining Available:
Height 2: SU(20): t67: i64,ch = CopyFromReg t0, Register:i64 $x0

Height 3: SU(11): t34: ch = CopyToReg t0, Register:i64 %39, t66

Height 3: SU(13): t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20

Height 3: SU(15): t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20

Height 3: SU(17): t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20

Height 3: SU(19): t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

Height 3: SU(3): t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:8


*** Scheduling [3]: SU(20): t67: i64,ch = CopyFromReg t0, Register:i64 $x0


Examining Available:
Height 3: SU(11): t34: ch = CopyToReg t0, Register:i64 %39, t66

Height 3: SU(13): t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20

Height 3: SU(15): t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20

Height 3: SU(17): t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20

Height 3: SU(19): t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

Height 3: SU(3): t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:8


*** Scheduling [4]: SU(11): t34: ch = CopyToReg t0, Register:i64 %39, t66


Examining Available:
Height 5: SU(12): t66: i64 = ADDI Register:i64 $x0, TargetConstant:i64<960>

Height 3: SU(13): t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20

Height 3: SU(15): t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20

Height 3: SU(17): t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20

Height 3: SU(19): t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

Height 3: SU(3): t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:8


*** Scheduling [5]: SU(12): t66: i64 = ADDI Register:i64 $x0, TargetConstant:i64<960>


Examining Available:
Height 3: SU(13): t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20

Height 3: SU(15): t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20

Height 3: SU(17): t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20

Height 3: SU(19): t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

Height 3: SU(3): t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:8


*** Scheduling [6]: SU(13): t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20


Examining Available:
Height 7: SU(14): t27: i64 = ADDI t6, TargetConstant:i64<256>, test_addarray.c:7:20

Height 3: SU(15): t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20

Height 3: SU(17): t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20

Height 3: SU(19): t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

Height 3: SU(3): t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:8


*** Scheduling [7]: SU(14): t27: i64 = ADDI t6, TargetConstant:i64<256>, test_addarray.c:7:20


Examining Available:
Height 3: SU(15): t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20

Height 3: SU(17): t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20

Height 3: SU(19): t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

Height 3: SU(3): t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:8


*** Scheduling [8]: SU(15): t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20


Examining Available:
Height 9: SU(16): t24: i64 = ADDI t4, TargetConstant:i64<256>, test_addarray.c:7:20

Height 3: SU(17): t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20

Height 3: SU(19): t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

Height 3: SU(3): t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:8


*** Scheduling [9]: SU(16): t24: i64 = ADDI t4, TargetConstant:i64<256>, test_addarray.c:7:20


Examining Available:
Height 3: SU(17): t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20

Height 3: SU(19): t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

Height 3: SU(3): t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:8


*** Scheduling [10]: SU(17): t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20


Examining Available:
Height 11: SU(18): t21: i64 = ADDI t2, TargetConstant:i64<256>, test_addarray.c:7:20

Height 3: SU(19): t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

Height 3: SU(3): t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:8


*** Scheduling [11]: SU(18): t21: i64 = ADDI t2, TargetConstant:i64<256>, test_addarray.c:7:20


Examining Available:
Height 3: SU(19): t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

Height 3: SU(3): t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:8


*** Scheduling [12]: SU(19): t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20


Examining Available:
Height 13: SU(21): t17: i64 = ADDI nsw t15, TargetConstant:i64<-64>, test_addarray.c:7:20

Height 3: SU(3): t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:8


*** Scheduling [13]: SU(21): t17: i64 = ADDI nsw t15, TargetConstant:i64<-64>, test_addarray.c:7:20


Examining Available:
Height 14: SU(22): t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20

Height 3: SU(3): t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:8


*** Scheduling [14]: SU(22): t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20


Examining Available:
Height 3: SU(3): t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:8


*** Scheduling [15]: SU(3): t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:8


Examining Available:
Height 16: SU(6): t49: nxv16i32 = PseudoVADD_VV_M8 t56, t53, t64, TargetConstant:i64<5>, test_addarray.c:9:15

Height 16: SU(5): t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20


*** Scheduling [16]: SU(6): t49: nxv16i32 = PseudoVADD_VV_M8 t56, t53, t64, TargetConstant:i64<5>, test_addarray.c:9:15


Examining Available:
Height 17: SU(9): t56: nxv16i32,ch = PseudoVLE32_V_M8<Mem:(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t4, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:17

Height 17: SU(7): t53: nxv16i32,ch = PseudoVLE32_V_M8<Mem:(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t6, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:10

Height 16: SU(5): t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20


*** Scheduling [17]: SU(9): t56: nxv16i32,ch = PseudoVLE32_V_M8<Mem:(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t4, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:17


Examining Available:
Height 17: SU(7): t53: nxv16i32,ch = PseudoVLE32_V_M8<Mem:(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t6, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:10

Height 18: SU(10): t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20

Height 16: SU(5): t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20


*** Scheduling [18]: SU(7): t53: nxv16i32,ch = PseudoVLE32_V_M8<Mem:(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t6, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:10


Examining Available:
Height 19: SU(4): t64: i64 = ADDI Register:i64 $x0, TargetConstant:i64<64>

Height 19: SU(8): t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20

Height 18: SU(10): t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20

Height 16: SU(5): t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20


*** Scheduling [19]: SU(4): t64: i64 = ADDI Register:i64 $x0, TargetConstant:i64<64>


Examining Available:
Height 19: SU(8): t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20

Height 18: SU(10): t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20

Height 16: SU(5): t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20


*** Scheduling [20]: SU(8): t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20


Examining Available:
Height 18: SU(10): t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20

Height 16: SU(5): t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20


*** Scheduling [21]: SU(10): t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20


Examining Available:
Height 16: SU(5): t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20


*** Scheduling [22]: SU(5): t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20

*** Final schedule ***
SU(5): t2: i64,ch = CopyFromReg t0, Register:i64 %7, test_addarray.c:7:20

SU(10): t4: i64,ch = CopyFromReg t0, Register:i64 %6, test_addarray.c:7:20

SU(8): t6: i64,ch = CopyFromReg t0, Register:i64 %5, test_addarray.c:7:20

SU(4): t64: i64 = ADDI Register:i64 $x0, TargetConstant:i64<64>

SU(7): t53: nxv16i32,ch = PseudoVLE32_V_M8<Mem:(load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17)> t6, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:10

SU(9): t56: nxv16i32,ch = PseudoVLE32_V_M8<Mem:(load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21)> t4, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:17

SU(6): t49: nxv16i32 = PseudoVADD_VV_M8 t56, t53, t64, TargetConstant:i64<5>, test_addarray.c:9:15

SU(3): t52: ch = PseudoVSE32_V_M8<Mem:(store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27)> t49, t2, t64, TargetConstant:i64<5>, t0, test_addarray.c:9:8

SU(22): t15: i64,ch = CopyFromReg t0, Register:i64 %8, test_addarray.c:7:20

SU(21): t17: i64 = ADDI nsw t15, TargetConstant:i64<-64>, test_addarray.c:7:20

SU(19): t19: ch = CopyToReg t0, Register:i64 %9, t17, test_addarray.c:7:20

SU(18): t21: i64 = ADDI t2, TargetConstant:i64<256>, test_addarray.c:7:20

SU(17): t23: ch = CopyToReg t0, Register:i64 %10, t21, test_addarray.c:7:20

SU(16): t24: i64 = ADDI t4, TargetConstant:i64<256>, test_addarray.c:7:20

SU(15): t26: ch = CopyToReg t0, Register:i64 %11, t24, test_addarray.c:7:20

SU(14): t27: i64 = ADDI t6, TargetConstant:i64<256>, test_addarray.c:7:20

SU(13): t29: ch = CopyToReg t0, Register:i64 %12, t27, test_addarray.c:7:20

SU(12): t66: i64 = ADDI Register:i64 $x0, TargetConstant:i64<960>

SU(11): t34: ch = CopyToReg t0, Register:i64 %39, t66

SU(20): t67: i64,ch = CopyFromReg t0, Register:i64 $x0

SU(2): t35: ch = TokenFactor t19, t23, t26, t29, t34, t52, test_addarray.c:7:20

SU(1): t51: ch = BEQ t17, t67, BasicBlock:ch<for.body.preheader 0xe2a908>, t35, test_addarray.c:7:20

SU(0): t39: ch = PseudoBR BasicBlock:ch<vector.body 0xe2aa50>, t51, test_addarray.c:7:20


Total amount of phi nodes to update: 5
Node 0 : (0xe2a9e8, 2147483687)
Node 1 : (0xe2ab30, 2147483660)
Node 2 : (0xe2ab98, 2147483659)
Node 3 : (0xe2ac00, 2147483658)
Node 4 : (0xe2ac68, 2147483657)
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2
Creating new node: t4: i64 = AssertZext t2, ValueType:ch:i10, test_addarray.c:7:2
Creating constant: t5: i64 = Constant<-999>
Creating new node: t6: i64 = add nuw nsw t4, Constant:i64<-999>, test_addarray.c:7:2
Creating new node: t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2
Creating new node: t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2
Creating constant: t11: i64 = Constant<2>
Creating new node: t12: i64 = shl t4, Constant:i64<2>, test_addarray.c:7:2
Creating new node: t13: i64 = add t10, t12, test_addarray.c:7:2
Creating new node: t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2
Creating new node: t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2
Creating new node: t18: i64 = add t17, t12, test_addarray.c:7:2
Creating new node: t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2
Creating new node: t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2
Creating new node: t23: i64 = add t22, t12, test_addarray.c:7:2
Creating new node: t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2
Creating new node: t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2
Creating new node: t28: ch = br t26, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2
Initial selection DAG: %bb.2 'add:for.body.preheader'
SelectionDAG has 29 nodes:
  t0: ch = EntryToken
    t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2
  t4: i64 = AssertZext t2, ValueType:ch:i10, test_addarray.c:7:2
  t12: i64 = shl t4, Constant:i64<2>, test_addarray.c:7:2
        t6: i64 = add nuw nsw t4, Constant:i64<-999>, test_addarray.c:7:2
      t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2
          t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2
        t13: i64 = add t10, t12, test_addarray.c:7:2
      t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2
          t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2
        t18: i64 = add t17, t12, test_addarray.c:7:2
      t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2
          t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2
        t23: i64 = add t22, t12, test_addarray.c:7:2
      t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2
    t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2
  t28: ch = br t26, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2



Combining: t28: ch = br t26, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2

Combining: t27: ch = BasicBlock<for.body 0xe2adb0>

Combining: t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2

Combining: t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2

Combining: t24: i64 = Register %4

Combining: t23: i64 = add t22, t12, test_addarray.c:7:2

Combining: t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2

Combining: t21: i64 = Register %21

Combining: t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2

Combining: t19: i64 = Register %3

Combining: t18: i64 = add t17, t12, test_addarray.c:7:2

Combining: t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2

Combining: t16: i64 = Register %22

Combining: t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2

Combining: t14: i64 = Register %2

Combining: t13: i64 = add t10, t12, test_addarray.c:7:2

Combining: t12: i64 = shl t4, Constant:i64<2>, test_addarray.c:7:2

Combining: t11: i64 = Constant<2>

Combining: t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2

Combining: t9: i64 = Register %23

Combining: t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2

Combining: t7: i64 = Register %1

Combining: t6: i64 = add nuw nsw t4, Constant:i64<-999>, test_addarray.c:7:2

Combining: t5: i64 = Constant<-999>

Combining: t4: i64 = AssertZext t2, ValueType:ch:i10, test_addarray.c:7:2

Combining: t3: ch = ValueType:i10

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2

Combining: t1: i64 = Register %0

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.2 'add:for.body.preheader'
SelectionDAG has 29 nodes:
  t0: ch = EntryToken
    t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2
  t4: i64 = AssertZext t2, ValueType:ch:i10, test_addarray.c:7:2
  t12: i64 = shl t4, Constant:i64<2>, test_addarray.c:7:2
        t6: i64 = add nuw nsw t4, Constant:i64<-999>, test_addarray.c:7:2
      t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2
          t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2
        t13: i64 = add t10, t12, test_addarray.c:7:2
      t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2
          t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2
        t18: i64 = add t17, t12, test_addarray.c:7:2
      t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2
          t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2
        t23: i64 = add t22, t12, test_addarray.c:7:2
      t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2
    t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2
  t28: ch = br t26, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2


Legalizing node: t27: ch = BasicBlock<for.body 0xe2adb0>
Analyzing result type: ch
Legal result type
Legally typed node: t27: ch = BasicBlock<for.body 0xe2adb0>

Legalizing node: t24: i64 = Register %4
Ignoring node results
Legally typed node: t24: i64 = Register %4

Legalizing node: t21: i64 = Register %21
Ignoring node results
Legally typed node: t21: i64 = Register %21

Legalizing node: t19: i64 = Register %3
Ignoring node results
Legally typed node: t19: i64 = Register %3

Legalizing node: t16: i64 = Register %22
Ignoring node results
Legally typed node: t16: i64 = Register %22

Legalizing node: t14: i64 = Register %2
Ignoring node results
Legally typed node: t14: i64 = Register %2

Legalizing node: t11: i64 = Constant<2>
Analyzing result type: i64
Legal result type
Legally typed node: t11: i64 = Constant<2>

Legalizing node: t9: i64 = Register %23
Ignoring node results
Legally typed node: t9: i64 = Register %23

Legalizing node: t7: i64 = Register %1
Ignoring node results
Legally typed node: t7: i64 = Register %1

Legalizing node: t5: i64 = Constant<-999>
Analyzing result type: i64
Legal result type
Legally typed node: t5: i64 = Constant<-999>

Legalizing node: t3: ch = ValueType:i10
Analyzing result type: ch
Legal result type
Legally typed node: t3: ch = ValueType:i10

Legalizing node: t1: i64 = Register %0
Ignoring node results
Legally typed node: t1: i64 = Register %0

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2

Legalizing node: t4: i64 = AssertZext t2, ValueType:ch:i10, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2
Legal operand
Analyzing operand: t3: ch = ValueType:i10
Legal operand
Legally typed node: t4: i64 = AssertZext t2, ValueType:ch:i10, test_addarray.c:7:2

Legalizing node: t6: i64 = add nuw nsw t4, Constant:i64<-999>, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t4: i64 = AssertZext t2, ValueType:ch:i10, test_addarray.c:7:2
Legal operand
Analyzing operand: t5: i64 = Constant<-999>
Legal operand
Legally typed node: t6: i64 = add nuw nsw t4, Constant:i64<-999>, test_addarray.c:7:2

Legalizing node: t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t6: i64 = add nuw nsw t4, Constant:i64<-999>, test_addarray.c:7:2
Legal operand
Legally typed node: t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2

Legalizing node: t12: i64 = shl t4, Constant:i64<2>, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t4: i64 = AssertZext t2, ValueType:ch:i10, test_addarray.c:7:2
Legal operand
Analyzing operand: t11: i64 = Constant<2>
Legal operand
Legally typed node: t12: i64 = shl t4, Constant:i64<2>, test_addarray.c:7:2

Legalizing node: t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2

Legalizing node: t13: i64 = add t10, t12, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2
Legal operand
Analyzing operand: t12: i64 = shl t4, Constant:i64<2>, test_addarray.c:7:2
Legal operand
Legally typed node: t13: i64 = add t10, t12, test_addarray.c:7:2

Legalizing node: t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t13: i64 = add t10, t12, test_addarray.c:7:2
Legal operand
Legally typed node: t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2

Legalizing node: t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2

Legalizing node: t18: i64 = add t17, t12, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2
Legal operand
Analyzing operand: t12: i64 = shl t4, Constant:i64<2>, test_addarray.c:7:2
Legal operand
Legally typed node: t18: i64 = add t17, t12, test_addarray.c:7:2

Legalizing node: t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t18: i64 = add t17, t12, test_addarray.c:7:2
Legal operand
Legally typed node: t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2

Legalizing node: t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2

Legalizing node: t23: i64 = add t22, t12, test_addarray.c:7:2
Analyzing result type: i64
Legal result type
Analyzing operand: t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2
Legal operand
Analyzing operand: t12: i64 = shl t4, Constant:i64<2>, test_addarray.c:7:2
Legal operand
Legally typed node: t23: i64 = add t22, t12, test_addarray.c:7:2

Legalizing node: t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t23: i64 = add t22, t12, test_addarray.c:7:2
Legal operand
Legally typed node: t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2

Legalizing node: t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2
Analyzing result type: ch
Legal result type
Analyzing operand: t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2
Legal operand
Analyzing operand: t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2
Legal operand
Analyzing operand: t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2
Legal operand
Analyzing operand: t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2
Legal operand
Legally typed node: t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2

Legalizing node: t28: ch = br t26, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2
Analyzing result type: ch
Legal result type
Analyzing operand: t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2
Legal operand
Analyzing operand: t27: ch = BasicBlock<for.body 0xe2adb0>
Legal operand
Legally typed node: t28: ch = br t26, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2

Legalizing node: t65535: ch = handlenode t28
Analyzing result type: ch
Legal result type
Analyzing operand: t28: ch = br t26, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2
Legal operand
Legally typed node: t65535: ch = handlenode t28

Type-legalized selection DAG: %bb.2 'add:for.body.preheader'
SelectionDAG has 29 nodes:
  t0: ch = EntryToken
    t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2
  t4: i64 = AssertZext t2, ValueType:ch:i10, test_addarray.c:7:2
  t12: i64 = shl t4, Constant:i64<2>, test_addarray.c:7:2
        t6: i64 = add nuw nsw t4, Constant:i64<-999>, test_addarray.c:7:2
      t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2
          t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2
        t13: i64 = add t10, t12, test_addarray.c:7:2
      t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2
          t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2
        t18: i64 = add t17, t12, test_addarray.c:7:2
      t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2
          t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2
        t23: i64 = add t22, t12, test_addarray.c:7:2
      t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2
    t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2
  t28: ch = br t26, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2



Legalizing: t28: ch = br t26, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t13: i64 = add t10, t12, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t18: i64 = add t17, t12, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t23: i64 = add t22, t12, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t6: i64 = add nuw nsw t4, Constant:i64<-999>, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t12: i64 = shl t4, Constant:i64<2>, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t4: i64 = AssertZext t2, ValueType:ch:i10, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t27: ch = BasicBlock<for.body 0xe2adb0>
Legal node: nothing to do

Legalizing: t24: i64 = Register %4

Legalizing: t21: i64 = Register %21

Legalizing: t19: i64 = Register %3

Legalizing: t16: i64 = Register %22

Legalizing: t14: i64 = Register %2

Legalizing: t11: i64 = Constant<2>
Legal node: nothing to do

Legalizing: t9: i64 = Register %23

Legalizing: t7: i64 = Register %1

Legalizing: t5: i64 = Constant<-999>
Legal node: nothing to do

Legalizing: t3: ch = ValueType:i10
Legal node: nothing to do

Legalizing: t1: i64 = Register %0

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.2 'add:for.body.preheader'
SelectionDAG has 29 nodes:
  t0: ch = EntryToken
    t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2
  t4: i64 = AssertZext t2, ValueType:ch:i10, test_addarray.c:7:2
  t12: i64 = shl t4, Constant:i64<2>, test_addarray.c:7:2
        t6: i64 = add nuw nsw t4, Constant:i64<-999>, test_addarray.c:7:2
      t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2
          t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2
        t13: i64 = add t10, t12, test_addarray.c:7:2
      t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2
          t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2
        t18: i64 = add t17, t12, test_addarray.c:7:2
      t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2
          t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2
        t23: i64 = add t22, t12, test_addarray.c:7:2
      t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2
    t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2
  t28: ch = br t26, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2



Legalizing: t28: ch = br t26, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2
Legal node: nothing to do

Combining: t28: ch = br t26, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2

Legalizing: t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2
Legal node: nothing to do

Combining: t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2

Legalizing: t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2
Legal node: nothing to do

Combining: t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2

Legalizing: t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2
Legal node: nothing to do

Combining: t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2

Legalizing: t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2
Legal node: nothing to do

Combining: t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2

Legalizing: t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2
Legal node: nothing to do

Combining: t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2

Legalizing: t13: i64 = add t10, t12, test_addarray.c:7:2
Legal node: nothing to do

Combining: t13: i64 = add t10, t12, test_addarray.c:7:2

Legalizing: t18: i64 = add t17, t12, test_addarray.c:7:2
Legal node: nothing to do

Combining: t18: i64 = add t17, t12, test_addarray.c:7:2

Legalizing: t23: i64 = add t22, t12, test_addarray.c:7:2
Legal node: nothing to do

Combining: t23: i64 = add t22, t12, test_addarray.c:7:2

Legalizing: t6: i64 = add nuw nsw t4, Constant:i64<-999>, test_addarray.c:7:2
Legal node: nothing to do

Combining: t6: i64 = add nuw nsw t4, Constant:i64<-999>, test_addarray.c:7:2

Legalizing: t12: i64 = shl t4, Constant:i64<2>, test_addarray.c:7:2
Legal node: nothing to do

Combining: t12: i64 = shl t4, Constant:i64<2>, test_addarray.c:7:2

Legalizing: t4: i64 = AssertZext t2, ValueType:ch:i10, test_addarray.c:7:2
Legal node: nothing to do

Combining: t4: i64 = AssertZext t2, ValueType:ch:i10, test_addarray.c:7:2

Legalizing: t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2
Legal node: nothing to do

Combining: t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2

Legalizing: t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2
Legal node: nothing to do

Combining: t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2

Legalizing: t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2
Legal node: nothing to do

Combining: t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2

Legalizing: t27: ch = BasicBlock<for.body 0xe2adb0>
Legal node: nothing to do

Combining: t27: ch = BasicBlock<for.body 0xe2adb0>

Legalizing: t24: i64 = Register %4

Combining: t24: i64 = Register %4

Legalizing: t21: i64 = Register %21

Combining: t21: i64 = Register %21

Legalizing: t19: i64 = Register %3

Combining: t19: i64 = Register %3

Legalizing: t16: i64 = Register %22

Combining: t16: i64 = Register %22

Legalizing: t14: i64 = Register %2

Combining: t14: i64 = Register %2

Legalizing: t11: i64 = Constant<2>
Legal node: nothing to do

Combining: t11: i64 = Constant<2>

Legalizing: t9: i64 = Register %23

Combining: t9: i64 = Register %23

Legalizing: t7: i64 = Register %1

Combining: t7: i64 = Register %1

Legalizing: t5: i64 = Constant<-999>
Legal node: nothing to do

Combining: t5: i64 = Constant<-999>

Legalizing: t3: ch = ValueType:i10
Legal node: nothing to do

Combining: t3: ch = ValueType:i10

Legalizing: t1: i64 = Register %0

Combining: t1: i64 = Register %0

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.2 'add:for.body.preheader'
SelectionDAG has 29 nodes:
  t0: ch = EntryToken
    t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2
  t4: i64 = AssertZext t2, ValueType:ch:i10, test_addarray.c:7:2
  t12: i64 = shl t4, Constant:i64<2>, test_addarray.c:7:2
        t6: i64 = add nuw nsw t4, Constant:i64<-999>, test_addarray.c:7:2
      t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2
          t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2
        t13: i64 = add t10, t12, test_addarray.c:7:2
      t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2
          t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2
        t18: i64 = add t17, t12, test_addarray.c:7:2
      t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2
          t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2
        t23: i64 = add t22, t12, test_addarray.c:7:2
      t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2
    t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2
  t28: ch = br t26, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2


===== Instruction selection begins: %bb.2 'for.body.preheader'

ISEL: Starting selection on root node: t28: ch = br t26, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 895177
  Morphed node: t28: ch = PseudoBR BasicBlock:ch<for.body 0xe2adb0>, t26, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2

ISEL: Starting selection on root node: t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2

ISEL: Starting selection on root node: t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2

ISEL: Starting selection on root node: t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2

ISEL: Starting selection on root node: t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2

ISEL: Starting selection on root node: t13: i64 = add t10, t12, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 16032
  Skipped scope entry (due to false predicate) at index 16038, continuing at 16121
  Skipped scope entry (due to false predicate) at index 16122, continuing at 16156
  Skipped scope entry (due to false predicate) at index 16157, continuing at 16191
  Skipped scope entry (due to false predicate) at index 16192, continuing at 16226
  Match failed at index 16036
  Continuing at 16227
  Match failed at index 16244
  Continuing at 16308
  Match failed at index 16309
  Continuing at 16338
  Match failed at index 16339
  Continuing at 16368
  Match failed at index 16369
  Continuing at 16398
  Continuing at 16399
  Match failed at index 16402
  Continuing at 16444
  Continuing at 16445
  Skipped scope entry (due to false predicate) at index 16451, continuing at 16598
  Skipped scope entry (due to false predicate) at index 16599, continuing at 16624
  Match failed at index 16448
  Continuing at 16625
  Skipped scope entry (due to false predicate) at index 16641, continuing at 16677
  Match failed at index 16687
  Continuing at 16697
  Match failed at index 16698
  Continuing at 16713
  Continuing at 16714
  Match failed at index 16715
  Continuing at 16751
  Continuing at 16752
  Match failed at index 16753
  Continuing at 16773
  Continuing at 16774
  Match failed at index 16777
  Continuing at 17225
  Match failed at index 17232
  Continuing at 17671
  Match failed at index 17677
  Continuing at 17778
  Morphed node: t13: i64 = ADD t10, t12, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t18: i64 = add t17, t12, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 16032
  Skipped scope entry (due to false predicate) at index 16038, continuing at 16121
  Skipped scope entry (due to false predicate) at index 16122, continuing at 16156
  Skipped scope entry (due to false predicate) at index 16157, continuing at 16191
  Skipped scope entry (due to false predicate) at index 16192, continuing at 16226
  Match failed at index 16036
  Continuing at 16227
  Match failed at index 16244
  Continuing at 16308
  Match failed at index 16309
  Continuing at 16338
  Match failed at index 16339
  Continuing at 16368
  Match failed at index 16369
  Continuing at 16398
  Continuing at 16399
  Match failed at index 16402
  Continuing at 16444
  Continuing at 16445
  Skipped scope entry (due to false predicate) at index 16451, continuing at 16598
  Skipped scope entry (due to false predicate) at index 16599, continuing at 16624
  Match failed at index 16448
  Continuing at 16625
  Skipped scope entry (due to false predicate) at index 16641, continuing at 16677
  Match failed at index 16687
  Continuing at 16697
  Match failed at index 16698
  Continuing at 16713
  Continuing at 16714
  Match failed at index 16715
  Continuing at 16751
  Continuing at 16752
  Match failed at index 16753
  Continuing at 16773
  Continuing at 16774
  Match failed at index 16777
  Continuing at 17225
  Match failed at index 17232
  Continuing at 17671
  Match failed at index 17677
  Continuing at 17778
  Morphed node: t18: i64 = ADD t17, t12, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t23: i64 = add t22, t12, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 16032
  Skipped scope entry (due to false predicate) at index 16038, continuing at 16121
  Skipped scope entry (due to false predicate) at index 16122, continuing at 16156
  Skipped scope entry (due to false predicate) at index 16157, continuing at 16191
  Skipped scope entry (due to false predicate) at index 16192, continuing at 16226
  Match failed at index 16036
  Continuing at 16227
  Match failed at index 16244
  Continuing at 16308
  Match failed at index 16309
  Continuing at 16338
  Match failed at index 16339
  Continuing at 16368
  Match failed at index 16369
  Continuing at 16398
  Continuing at 16399
  Match failed at index 16402
  Continuing at 16444
  Continuing at 16445
  Skipped scope entry (due to false predicate) at index 16451, continuing at 16598
  Skipped scope entry (due to false predicate) at index 16599, continuing at 16624
  Match failed at index 16448
  Continuing at 16625
  Skipped scope entry (due to false predicate) at index 16641, continuing at 16677
  Match failed at index 16687
  Continuing at 16697
  Match failed at index 16698
  Continuing at 16713
  Continuing at 16714
  Match failed at index 16715
  Continuing at 16751
  Continuing at 16752
  Match failed at index 16753
  Continuing at 16773
  Continuing at 16774
  Match failed at index 16777
  Continuing at 17225
  Match failed at index 17232
  Continuing at 17671
  Match failed at index 17677
  Continuing at 17778
  Morphed node: t23: i64 = ADD t22, t12, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i64 = add nuw nsw t4, Constant:i64<-999>, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 16032
  Skipped scope entry (due to false predicate) at index 16038, continuing at 16121
  Skipped scope entry (due to false predicate) at index 16122, continuing at 16156
  Skipped scope entry (due to false predicate) at index 16157, continuing at 16191
  Skipped scope entry (due to false predicate) at index 16192, continuing at 16226
  Match failed at index 16036
  Continuing at 16227
  Skipped scope entry (due to false predicate) at index 16240, continuing at 16308
  Skipped scope entry (due to false predicate) at index 16309, continuing at 16338
  Skipped scope entry (due to false predicate) at index 16339, continuing at 16368
  Skipped scope entry (due to false predicate) at index 16369, continuing at 16398
  Match failed at index 16238
  Continuing at 16399
  TypeSwitch[i64] from 16408 to 16411
  Match failed at index 16413
  Continuing at 16444
  Continuing at 16445
  Skipped scope entry (due to false predicate) at index 16451, continuing at 16598
  Skipped scope entry (due to false predicate) at index 16599, continuing at 16624
  Match failed at index 16448
  Continuing at 16625
  Skipped scope entry (due to false predicate) at index 16635, continuing at 16752
  Skipped scope entry (due to false predicate) at index 16753, continuing at 16773
  Match failed at index 16633
  Continuing at 16774
  Match failed at index 16777
  Continuing at 17225
  Match failed at index 17232
  Continuing at 17671
  TypeSwitch[i64] from 17685 to 17688
Creating constant: t29: i64 = TargetConstant<-999>
  Morphed node: t6: i64 = ADDI nuw nsw t4, TargetConstant:i64<-999>, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t12: i64 = shl t4, Constant:i64<2>, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 50991
  Match failed at index 50994
  Continuing at 51056
  Match failed at index 51057
  Continuing at 51102
  TypeSwitch[i64] from 51116 to 51119
Creating constant: t30: i64 = TargetConstant<2>
  Morphed node: t12: i64 = SLLI t4, TargetConstant:i64<2>, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i64 = AssertZext t2, ValueType:ch:i10, test_addarray.c:7:2

ISEL: Starting selection on root node: t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2

ISEL: Starting selection on root node: t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2

ISEL: Starting selection on root node: t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2

ISEL: Starting selection on root node: t27: ch = BasicBlock<for.body 0xe2adb0>

ISEL: Starting selection on root node: t24: i64 = Register %4

ISEL: Starting selection on root node: t21: i64 = Register %21

ISEL: Starting selection on root node: t19: i64 = Register %3

ISEL: Starting selection on root node: t16: i64 = Register %22

ISEL: Starting selection on root node: t14: i64 = Register %2

ISEL: Starting selection on root node: t9: i64 = Register %23

ISEL: Starting selection on root node: t7: i64 = Register %1

ISEL: Starting selection on root node: t1: i64 = Register %0

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.2 'add:for.body.preheader'
SelectionDAG has 27 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2
  t12: i64 = SLLI t2, TargetConstant:i64<2>, test_addarray.c:7:2
        t6: i64 = ADDI nuw nsw t2, TargetConstant:i64<-999>, test_addarray.c:7:2
      t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2
          t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2
        t13: i64 = ADD t10, t12, test_addarray.c:7:2
      t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2
          t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2
        t18: i64 = ADD t17, t12, test_addarray.c:7:2
      t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2
          t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2
        t23: i64 = ADD t22, t12, test_addarray.c:7:2
      t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2
    t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2
  t28: ch = PseudoBR BasicBlock:ch<for.body 0xe2adb0>, t26, test_addarray.c:7:2


********** List Scheduling %bb.2 'for.body.preheader' **********
SU(0): t28: ch = PseudoBR BasicBlock:ch<for.body 0xe2adb0>, t26, test_addarray.c:7:2

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Barrier
SU(1): t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(13): Ord  Latency=1 Barrier
    SU(10): Ord  Latency=1 Barrier
    SU(7): Ord  Latency=1 Barrier
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=0 Barrier
SU(2): t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(3): t23: i64 = ADD t22, t12, test_addarray.c:7:2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1
    SU(4): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(4): t12: i64 = SLLI t2, TargetConstant:i64<2>, test_addarray.c:7:2

  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(3): Data Latency=1
    SU(8): Data Latency=1
    SU(11): Data Latency=1
SU(5): t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(4): Data Latency=1
    SU(14): Data Latency=1
SU(6): t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(3): Data Latency=1
SU(7): t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(8): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(8): t18: i64 = ADD t17, t12, test_addarray.c:7:2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(9): Data Latency=1
    SU(4): Data Latency=1
  Successors:
    SU(7): Data Latency=1
SU(9): t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(8): Data Latency=1
SU(10): t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(11): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(11): t13: i64 = ADD t10, t12, test_addarray.c:7:2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(12): Data Latency=1
    SU(4): Data Latency=1
  Successors:
    SU(10): Data Latency=1
SU(12): t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(11): Data Latency=1
SU(13): t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(14): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(14): t6: i64 = ADDI nuw nsw t2, TargetConstant:i64<-999>, test_addarray.c:7:2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(13): Data Latency=1

Examining Available:
Height 0: SU(0): t28: ch = PseudoBR BasicBlock:ch<for.body 0xe2adb0>, t26, test_addarray.c:7:2


*** Scheduling [0]: SU(0): t28: ch = PseudoBR BasicBlock:ch<for.body 0xe2adb0>, t26, test_addarray.c:7:2


Examining Available:
Height 0: SU(1): t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2


*** Scheduling [1]: SU(1): t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2


Examining Available:
Height 2: SU(2): t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2

Height 2: SU(7): t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2

Height 2: SU(10): t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2

Height 2: SU(13): t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2


*** Scheduling [2]: SU(2): t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2


Examining Available:
Height 3: SU(3): t23: i64 = ADD t22, t12, test_addarray.c:7:2

Height 2: SU(7): t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2

Height 2: SU(10): t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2

Height 2: SU(13): t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2


*** Scheduling [3]: SU(3): t23: i64 = ADD t22, t12, test_addarray.c:7:2


Examining Available:
Height 4: SU(6): t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2

Height 2: SU(7): t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2

Height 2: SU(10): t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2

Height 2: SU(13): t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2


*** Scheduling [4]: SU(6): t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2


Examining Available:
Height 2: SU(7): t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2

Height 2: SU(10): t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2

Height 2: SU(13): t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2


*** Scheduling [5]: SU(7): t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2


Examining Available:
Height 6: SU(8): t18: i64 = ADD t17, t12, test_addarray.c:7:2

Height 2: SU(10): t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2

Height 2: SU(13): t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2


*** Scheduling [6]: SU(8): t18: i64 = ADD t17, t12, test_addarray.c:7:2


Examining Available:
Height 7: SU(9): t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2

Height 2: SU(10): t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2

Height 2: SU(13): t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2


*** Scheduling [7]: SU(9): t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2


Examining Available:
Height 2: SU(10): t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2

Height 2: SU(13): t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2


*** Scheduling [8]: SU(10): t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2


Examining Available:
Height 9: SU(11): t13: i64 = ADD t10, t12, test_addarray.c:7:2

Height 2: SU(13): t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2


*** Scheduling [9]: SU(11): t13: i64 = ADD t10, t12, test_addarray.c:7:2


Examining Available:
Height 10: SU(12): t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2

Height 10: SU(4): t12: i64 = SLLI t2, TargetConstant:i64<2>, test_addarray.c:7:2

Height 2: SU(13): t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2


*** Scheduling [10]: SU(12): t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2


Examining Available:
Height 10: SU(4): t12: i64 = SLLI t2, TargetConstant:i64<2>, test_addarray.c:7:2

Height 2: SU(13): t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2


*** Scheduling [11]: SU(4): t12: i64 = SLLI t2, TargetConstant:i64<2>, test_addarray.c:7:2


Examining Available:
Height 2: SU(13): t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2


*** Scheduling [12]: SU(13): t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2


Examining Available:
Height 13: SU(14): t6: i64 = ADDI nuw nsw t2, TargetConstant:i64<-999>, test_addarray.c:7:2


*** Scheduling [13]: SU(14): t6: i64 = ADDI nuw nsw t2, TargetConstant:i64<-999>, test_addarray.c:7:2


Examining Available:
Height 14: SU(5): t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2


*** Scheduling [14]: SU(5): t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2

*** Final schedule ***
SU(5): t2: i64,ch = CopyFromReg t0, Register:i64 %0, test_addarray.c:7:2

SU(14): t6: i64 = ADDI nuw nsw t2, TargetConstant:i64<-999>, test_addarray.c:7:2

SU(13): t8: ch = CopyToReg t0, Register:i64 %1, t6, test_addarray.c:7:2

SU(4): t12: i64 = SLLI t2, TargetConstant:i64<2>, test_addarray.c:7:2

SU(12): t10: i64,ch = CopyFromReg t0, Register:i64 %23, test_addarray.c:7:2

SU(11): t13: i64 = ADD t10, t12, test_addarray.c:7:2

SU(10): t15: ch = CopyToReg t0, Register:i64 %2, t13, test_addarray.c:7:2

SU(9): t17: i64,ch = CopyFromReg t0, Register:i64 %22, test_addarray.c:7:2

SU(8): t18: i64 = ADD t17, t12, test_addarray.c:7:2

SU(7): t20: ch = CopyToReg t0, Register:i64 %3, t18, test_addarray.c:7:2

SU(6): t22: i64,ch = CopyFromReg t0, Register:i64 %21, test_addarray.c:7:2

SU(3): t23: i64 = ADD t22, t12, test_addarray.c:7:2

SU(2): t25: ch = CopyToReg t0, Register:i64 %4, t23, test_addarray.c:7:2

SU(1): t26: ch = TokenFactor t8, t15, t20, t25, test_addarray.c:7:2

SU(0): t28: ch = PseudoBR BasicBlock:ch<for.body 0xe2adb0>, t26, test_addarray.c:7:2


Total amount of phi nodes to update: 4
Node 0 : (0xe2ae90, 2147483652)
Node 1 : (0xe2aef8, 2147483651)
Node 2 : (0xe2af60, 2147483650)
Node 3 : (0xe2afc8, 2147483649)
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10
Creating constant: t3: i64 = Constant<0>
Creating new node: t4: i64 = undef
Creating new node: t5: i32,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13)> t0, t2, undef:i64, test_addarray.c:9:10
Creating new node: t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17
Creating new node: t8: i32,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13)> t0, t7, undef:i64, test_addarray.c:9:17
Creating new node: t9: i32 = add nsw t8, t5, test_addarray.c:9:15
Creating new node: t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8
Creating new node: t12: ch = TokenFactor t5:1, t8:1, test_addarray.c:9:8
Creating new node: t13: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13)> t12, t9, t11, undef:i64, test_addarray.c:9:8
Creating new node: t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16
Creating constant: t16: i64 = Constant<1>
Creating new node: t17: i64,i1 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16
Creating new node: t19: ch = CopyToReg t0, Register:i64 %17, t17, test_addarray.c:7:16
Creating constant: t20: i64 = Constant<4>
Creating new node: t21: i64 = add t11, Constant:i64<4>, test_addarray.c:7:16
Creating new node: t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16
Creating new node: t24: i64 = add t7, Constant:i64<4>, test_addarray.c:7:16
Creating new node: t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16
Creating new node: t27: i64 = add t2, Constant:i64<4>, test_addarray.c:7:16
Creating new node: t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16
Creating new node: t30: ch = TokenFactor t19, t23, t26, t29, t13, test_addarray.c:7:2
Creating new node: t32: ch = brcond t30, t17:1, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
Creating new node: t34: ch = br t32, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2
Initial selection DAG: %bb.5 'add:for.body'
SelectionDAG has 35 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10
  t3: i64 = Constant<0>
  t5: i32,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13)> t0, t2, undef:i64, test_addarray.c:9:10
  t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17
  t8: i32,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13)> t0, t7, undef:i64, test_addarray.c:9:17
  t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8
    t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16
  t17: i64,i1 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16
        t19: ch = CopyToReg t0, Register:i64 %17, t17, test_addarray.c:7:16
          t21: i64 = add t11, Constant:i64<4>, test_addarray.c:7:16
        t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16
          t24: i64 = add t7, Constant:i64<4>, test_addarray.c:7:16
        t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16
          t27: i64 = add t2, Constant:i64<4>, test_addarray.c:7:16
        t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16
          t12: ch = TokenFactor t5:1, t8:1, test_addarray.c:9:8
          t9: i32 = add nsw t8, t5, test_addarray.c:9:15
        t13: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13)> t12, t9, t11, undef:i64, test_addarray.c:9:8
      t30: ch = TokenFactor t19, t23, t26, t29, t13, test_addarray.c:7:2
    t32: ch = brcond t30, t17:1, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
  t34: ch = br t32, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2



Combining: t34: ch = br t32, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2

Combining: t33: ch = BasicBlock<for.body 0xe2adb0>

Combining: t32: ch = brcond t30, t17:1, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2

Combining: t31: ch = BasicBlock<for.cond.cleanup 0xe2acd0>

Combining: t30: ch = TokenFactor t19, t23, t26, t29, t13, test_addarray.c:7:2

Combining: t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16

Combining: t28: i64 = Register %20

Combining: t27: i64 = add t2, Constant:i64<4>, test_addarray.c:7:16

Combining: t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16

Combining: t25: i64 = Register %19

Combining: t24: i64 = add t7, Constant:i64<4>, test_addarray.c:7:16

Combining: t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16

Combining: t22: i64 = Register %18

Combining: t21: i64 = add t11, Constant:i64<4>, test_addarray.c:7:16

Combining: t20: i64 = Constant<4>

Combining: t19: ch = CopyToReg t0, Register:i64 %17, t17, test_addarray.c:7:16

Combining: t18: i64 = Register %17

Combining: t17: i64,i1 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16

Combining: t16: i64 = Constant<1>

Combining: t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16

Combining: t14: i64 = Register %16

Combining: t13: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13)> t12, t9, t11, undef:i64, test_addarray.c:9:8

Combining: t12: ch = TokenFactor t5:1, t8:1, test_addarray.c:9:8

Combining: t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8

Combining: t10: i64 = Register %15

Combining: t9: i32 = add nsw t8, t5, test_addarray.c:9:15

Combining: t8: i32,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13)> t0, t7, undef:i64, test_addarray.c:9:17

Combining: t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17

Combining: t6: i64 = Register %14

Combining: t5: i32,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13)> t0, t2, undef:i64, test_addarray.c:9:10

Combining: t4: i64 = undef

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10

Combining: t1: i64 = Register %13

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.5 'add:for.body'
SelectionDAG has 34 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10
  t5: i32,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13)> t0, t2, undef:i64, test_addarray.c:9:10
  t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17
  t8: i32,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13)> t0, t7, undef:i64, test_addarray.c:9:17
  t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8
    t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16
  t17: i64,i1 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16
        t19: ch = CopyToReg t0, Register:i64 %17, t17, test_addarray.c:7:16
          t21: i64 = add t11, Constant:i64<4>, test_addarray.c:7:16
        t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16
          t24: i64 = add t7, Constant:i64<4>, test_addarray.c:7:16
        t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16
          t27: i64 = add t2, Constant:i64<4>, test_addarray.c:7:16
        t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16
          t12: ch = TokenFactor t5:1, t8:1, test_addarray.c:9:8
          t9: i32 = add nsw t8, t5, test_addarray.c:9:15
        t13: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13)> t12, t9, t11, undef:i64, test_addarray.c:9:8
      t30: ch = TokenFactor t19, t23, t26, t29, t13, test_addarray.c:7:2
    t32: ch = brcond t30, t17:1, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
  t34: ch = br t32, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2


Legalizing node: t33: ch = BasicBlock<for.body 0xe2adb0>
Analyzing result type: ch
Legal result type
Legally typed node: t33: ch = BasicBlock<for.body 0xe2adb0>

Legalizing node: t31: ch = BasicBlock<for.cond.cleanup 0xe2acd0>
Analyzing result type: ch
Legal result type
Legally typed node: t31: ch = BasicBlock<for.cond.cleanup 0xe2acd0>

Legalizing node: t28: i64 = Register %20
Ignoring node results
Legally typed node: t28: i64 = Register %20

Legalizing node: t25: i64 = Register %19
Ignoring node results
Legally typed node: t25: i64 = Register %19

Legalizing node: t22: i64 = Register %18
Ignoring node results
Legally typed node: t22: i64 = Register %18

Legalizing node: t20: i64 = Constant<4>
Analyzing result type: i64
Legal result type
Legally typed node: t20: i64 = Constant<4>

Legalizing node: t18: i64 = Register %17
Ignoring node results
Legally typed node: t18: i64 = Register %17

Legalizing node: t16: i64 = Constant<1>
Analyzing result type: i64
Legal result type
Legally typed node: t16: i64 = Constant<1>

Legalizing node: t14: i64 = Register %16
Ignoring node results
Legally typed node: t14: i64 = Register %16

Legalizing node: t10: i64 = Register %15
Ignoring node results
Legally typed node: t10: i64 = Register %15

Legalizing node: t6: i64 = Register %14
Ignoring node results
Legally typed node: t6: i64 = Register %14

Legalizing node: t4: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t4: i64 = undef

Legalizing node: t1: i64 = Register %13
Ignoring node results
Legally typed node: t1: i64 = Register %13

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10

Legalizing node: t5: i32,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13)> t0, t2, undef:i64, test_addarray.c:9:10
Analyzing result type: i32
Promote integer result: t5: i32,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13)> t0, t2, undef:i64, test_addarray.c:9:10

Creating new node: t35: i64,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13), anyext from i32> t0, t2, undef:i64, test_addarray.c:9:10
Legalizing node: t35: i64,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13), anyext from i32> t0, t2, undef:i64, test_addarray.c:9:10
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t35: i64,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13), anyext from i32> t0, t2, undef:i64, test_addarray.c:9:10

Legalizing node: t27: i64 = add t2, Constant:i64<4>, test_addarray.c:7:16
Analyzing result type: i64
Legal result type
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10
Legal operand
Analyzing operand: t20: i64 = Constant<4>
Legal operand
Legally typed node: t27: i64 = add t2, Constant:i64<4>, test_addarray.c:7:16

Legalizing node: t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t27: i64 = add t2, Constant:i64<4>, test_addarray.c:7:16
Legal operand
Legally typed node: t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16

Legalizing node: t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17

Legalizing node: t8: i32,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13)> t0, t7, undef:i64, test_addarray.c:9:17
Analyzing result type: i32
Promote integer result: t8: i32,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13)> t0, t7, undef:i64, test_addarray.c:9:17

Creating new node: t36: i64,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13), anyext from i32> t0, t7, undef:i64, test_addarray.c:9:17
Legalizing node: t9: i32 = add nsw t8, t5, test_addarray.c:9:15
Analyzing result type: i32
Promote integer result: t9: i32 = add nsw t8, t5, test_addarray.c:9:15

Creating new node: t37: i64 = any_extend t8, test_addarray.c:9:15
Creating new node: t38: i64 = any_extend t5, test_addarray.c:9:15
Creating new node: t39: i64 = add t37, t38, test_addarray.c:9:15
Creating new node: t41: i64 = sign_extend_inreg t39, ValueType:ch:i32, test_addarray.c:9:15
Creating new node: t42: i32 = truncate t41, test_addarray.c:9:15
Node has been custom expanded, done
Legalizing node: t40: ch = ValueType:i32
Analyzing result type: ch
Legal result type
Legally typed node: t40: ch = ValueType:i32

Legalizing node: t38: i64 = any_extend t5, test_addarray.c:9:15
Analyzing result type: i64
Legal result type
Analyzing operand: t5: i32,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13)> t0, t2, undef:i64, test_addarray.c:9:10
Promote integer operand: t38: i64 = any_extend t5, test_addarray.c:9:15

Replacing: t38: i64 = any_extend t5, test_addarray.c:9:15
     with: t35: i64,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa <0xdb33d8>), anyext from i32> t0, t2, undef:i64, test_addarray.c:9:10
Legalizing node: t37: i64 = any_extend t8, test_addarray.c:9:15
Analyzing result type: i64
Legal result type
Analyzing operand: t8: i32,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13)> t0, t7, undef:i64, test_addarray.c:9:17
Promote integer operand: t37: i64 = any_extend t8, test_addarray.c:9:15

Replacing: t37: i64 = any_extend t8, test_addarray.c:9:15
     with: t36: i64,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa <0xdb33d8>), anyext from i32> t0, t7, undef:i64, test_addarray.c:9:17
Legalizing node: t36: i64,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13), anyext from i32> t0, t7, undef:i64, test_addarray.c:9:17
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t36: i64,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13), anyext from i32> t0, t7, undef:i64, test_addarray.c:9:17

Legalizing node: t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8
Analyzing result type: ch
Legal result type
Analyzing operand: t35: i64,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13), anyext from i32> t0, t2, undef:i64, test_addarray.c:9:10
Legal operand
Analyzing operand: t36: i64,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13), anyext from i32> t0, t7, undef:i64, test_addarray.c:9:17
Legal operand
Legally typed node: t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8

Legalizing node: t39: i64 = add t36, t35, test_addarray.c:9:15
Analyzing result type: i64
Legal result type
Analyzing operand: t36: i64,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13), anyext from i32> t0, t7, undef:i64, test_addarray.c:9:17
Legal operand
Analyzing operand: t35: i64,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13), anyext from i32> t0, t2, undef:i64, test_addarray.c:9:10
Legal operand
Legally typed node: t39: i64 = add t36, t35, test_addarray.c:9:15

Legalizing node: t41: i64 = sign_extend_inreg t39, ValueType:ch:i32, test_addarray.c:9:15
Analyzing result type: i64
Legal result type
Analyzing operand: t39: i64 = add t36, t35, test_addarray.c:9:15
Legal operand
Analyzing operand: t40: ch = ValueType:i32
Legal operand
Legally typed node: t41: i64 = sign_extend_inreg t39, ValueType:ch:i32, test_addarray.c:9:15

Legalizing node: t42: i32 = truncate t41, test_addarray.c:9:15
Analyzing result type: i32
Promote integer result: t42: i32 = truncate t41, test_addarray.c:9:15

Legalizing node: t24: i64 = add t7, Constant:i64<4>, test_addarray.c:7:16
Analyzing result type: i64
Legal result type
Analyzing operand: t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17
Legal operand
Analyzing operand: t20: i64 = Constant<4>
Legal operand
Legally typed node: t24: i64 = add t7, Constant:i64<4>, test_addarray.c:7:16

Legalizing node: t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t24: i64 = add t7, Constant:i64<4>, test_addarray.c:7:16
Legal operand
Legally typed node: t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16

Legalizing node: t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8

Legalizing node: t13: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13)> t12, t42, t11, undef:i64, test_addarray.c:9:8
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8
Legal operand
Analyzing operand: t42: i32 = truncate t41, test_addarray.c:9:15
Promote integer operand: t13: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13)> t12, t42, t11, undef:i64, test_addarray.c:9:8

Creating new node: t43: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13), trunc to i32> t12, t41, t11, undef:i64, test_addarray.c:9:8
Replacing: t13: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13)> t12, t42, t11, undef:i64, test_addarray.c:9:8
     with: t43: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa <0xdb33d8>), trunc to i32> t12, t41, t11, undef:i64, test_addarray.c:9:8
Legalizing node: t43: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13), trunc to i32> t12, t41, t11, undef:i64, test_addarray.c:9:8
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8
Legal operand
Analyzing operand: t41: i64 = sign_extend_inreg t39, ValueType:ch:i32, test_addarray.c:9:15
Legal operand
Analyzing operand: t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t43: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13), trunc to i32> t12, t41, t11, undef:i64, test_addarray.c:9:8

Legalizing node: t21: i64 = add t11, Constant:i64<4>, test_addarray.c:7:16
Analyzing result type: i64
Legal result type
Analyzing operand: t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8
Legal operand
Analyzing operand: t20: i64 = Constant<4>
Legal operand
Legally typed node: t21: i64 = add t11, Constant:i64<4>, test_addarray.c:7:16

Legalizing node: t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t21: i64 = add t11, Constant:i64<4>, test_addarray.c:7:16
Legal operand
Legally typed node: t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16

Legalizing node: t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16

Legalizing node: t17: i64,i1 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16
Analyzing result type: i64
Legal result type
Analyzing result type: i1
Promote integer result: t17: i64,i1 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16

Creating new node: t44: i64,i64 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16
Legalizing node: t44: i64,i64 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16
Analyzing result type: i64
Legal result type
Analyzing result type: i64
Legal result type
Analyzing operand: t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16
Legal operand
Analyzing operand: t16: i64 = Constant<1>
Legal operand
Legally typed node: t44: i64,i64 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16

Legalizing node: t19: ch = CopyToReg t0, Register:i64 %17, t44, test_addarray.c:7:16
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t44: i64,i64 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16
Legal operand
Legally typed node: t19: ch = CopyToReg t0, Register:i64 %17, t44, test_addarray.c:7:16

Legalizing node: t30: ch = TokenFactor t19, t23, t26, t29, t43, test_addarray.c:7:2
Analyzing result type: ch
Legal result type
Analyzing operand: t19: ch = CopyToReg t0, Register:i64 %17, t44, test_addarray.c:7:16
Legal operand
Analyzing operand: t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16
Legal operand
Analyzing operand: t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16
Legal operand
Analyzing operand: t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16
Legal operand
Analyzing operand: t43: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13), trunc to i32> t12, t41, t11, undef:i64, test_addarray.c:9:8
Legal operand
Legally typed node: t30: ch = TokenFactor t19, t23, t26, t29, t43, test_addarray.c:7:2

Legalizing node: t32: ch = brcond t30, t17:1, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
Analyzing result type: ch
Legal result type
Analyzing operand: t30: ch = TokenFactor t19, t23, t26, t29, t43, test_addarray.c:7:2
Legal operand
Analyzing operand: t17: i64,i1 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16
Promote integer operand: t32: ch = brcond t30, t17:1, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2

Creating new node: t45: i64 = zero_extend t17:1, test_addarray.c:7:16
Legalizing node: t45: i64 = zero_extend t17:1, test_addarray.c:7:16
Analyzing result type: i64
Legal result type
Analyzing operand: t17: i64,i1 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16
Promote integer operand: t45: i64 = zero_extend t17:1, test_addarray.c:7:16

Creating new node: t46: i64 = and t44:1, Constant:i64<1>, test_addarray.c:7:16
Replacing: t45: i64 = zero_extend t17:1, test_addarray.c:7:16
     with: t46: i64 = and t44:1, Constant:i64<1>, test_addarray.c:7:16
Legalizing node: t46: i64 = and t44:1, Constant:i64<1>, test_addarray.c:7:16
Analyzing result type: i64
Legal result type
Analyzing operand: t44: i64,i64 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16
Legal operand
Analyzing operand: t16: i64 = Constant<1>
Legal operand
Legally typed node: t46: i64 = and t44:1, Constant:i64<1>, test_addarray.c:7:16

Legalizing node: t32: ch = brcond t30, t46, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
Analyzing result type: ch
Legal result type
Analyzing operand: t30: ch = TokenFactor t19, t23, t26, t29, t43, test_addarray.c:7:2
Legal operand
Analyzing operand: t46: i64 = and t44:1, Constant:i64<1>, test_addarray.c:7:16
Legal operand
Analyzing operand: t31: ch = BasicBlock<for.cond.cleanup 0xe2acd0>
Legal operand
Legally typed node: t32: ch = brcond t30, t46, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2

Legalizing node: t34: ch = br t32, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2
Analyzing result type: ch
Legal result type
Analyzing operand: t32: ch = brcond t30, t46, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
Legal operand
Analyzing operand: t33: ch = BasicBlock<for.body 0xe2adb0>
Legal operand
Legally typed node: t34: ch = br t32, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2

Legalizing node: t65535: ch = handlenode t34
Analyzing result type: ch
Legal result type
Analyzing operand: t34: ch = br t32, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2
Legal operand
Legally typed node: t65535: ch = handlenode t34

Type-legalized selection DAG: %bb.5 'add:for.body'
SelectionDAG has 37 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10
  t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17
  t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8
  t35: i64,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13), anyext from i32> t0, t2, undef:i64, test_addarray.c:9:10
  t36: i64,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13), anyext from i32> t0, t7, undef:i64, test_addarray.c:9:17
    t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16
  t44: i64,i64 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16
        t19: ch = CopyToReg t0, Register:i64 %17, t44, test_addarray.c:7:16
          t21: i64 = add t11, Constant:i64<4>, test_addarray.c:7:16
        t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16
          t24: i64 = add t7, Constant:i64<4>, test_addarray.c:7:16
        t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16
          t27: i64 = add t2, Constant:i64<4>, test_addarray.c:7:16
        t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16
          t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8
            t39: i64 = add t36, t35, test_addarray.c:9:15
          t41: i64 = sign_extend_inreg t39, ValueType:ch:i32, test_addarray.c:9:15
        t43: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13), trunc to i32> t12, t41, t11, undef:i64, test_addarray.c:9:8
      t30: ch = TokenFactor t19, t23, t26, t29, t43, test_addarray.c:7:2
      t46: i64 = and t44:1, Constant:i64<1>, test_addarray.c:7:16
    t32: ch = brcond t30, t46, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
  t34: ch = br t32, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2



Combining: t46: i64 = and t44:1, Constant:i64<1>, test_addarray.c:7:16

Replacing.2 t46: i64 = and t44:1, Constant:i64<1>, test_addarray.c:7:16

With: t44: i64,i64 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16


Combining: t44: i64,i64 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16

Combining: t43: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13), trunc to i32> t12, t41, t11, undef:i64, test_addarray.c:9:8
Creating new node: t47: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13), trunc to i32> t12, t39, t11, undef:i64, test_addarray.c:9:8
 ... into: t47: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13), trunc to i32> t12, t39, t11, undef:i64, test_addarray.c:9:8

Combining: t47: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13), trunc to i32> t12, t39, t11, undef:i64, test_addarray.c:9:8

Combining: t39: i64 = add t36, t35, test_addarray.c:9:15

Combining: t36: i64,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13), anyext from i32> t0, t7, undef:i64, test_addarray.c:9:17

Combining: t35: i64,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13), anyext from i32> t0, t2, undef:i64, test_addarray.c:9:10

Combining: t34: ch = br t32, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2

Combining: t33: ch = BasicBlock<for.body 0xe2adb0>

Combining: t32: ch = brcond t30, t44:1, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2

Combining: t31: ch = BasicBlock<for.cond.cleanup 0xe2acd0>

Combining: t30: ch = TokenFactor t19, t23, t26, t29, t47, test_addarray.c:7:2

Combining: t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16

Combining: t28: i64 = Register %20

Combining: t27: i64 = add t2, Constant:i64<4>, test_addarray.c:7:16

Combining: t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16

Combining: t25: i64 = Register %19

Combining: t24: i64 = add t7, Constant:i64<4>, test_addarray.c:7:16

Combining: t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16

Combining: t22: i64 = Register %18

Combining: t21: i64 = add t11, Constant:i64<4>, test_addarray.c:7:16

Combining: t20: i64 = Constant<4>

Combining: t19: ch = CopyToReg t0, Register:i64 %17, t44, test_addarray.c:7:16

Combining: t18: i64 = Register %17

Combining: t16: i64 = Constant<1>

Combining: t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16

Combining: t14: i64 = Register %16

Combining: t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8

Combining: t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8

Combining: t10: i64 = Register %15

Combining: t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17

Combining: t6: i64 = Register %14

Combining: t4: i64 = undef

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10

Combining: t1: i64 = Register %13

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.5 'add:for.body'
SelectionDAG has 34 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10
  t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17
  t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8
  t35: i64,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13), anyext from i32> t0, t2, undef:i64, test_addarray.c:9:10
  t36: i64,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13), anyext from i32> t0, t7, undef:i64, test_addarray.c:9:17
    t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16
  t44: i64,i64 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16
        t19: ch = CopyToReg t0, Register:i64 %17, t44, test_addarray.c:7:16
          t21: i64 = add t11, Constant:i64<4>, test_addarray.c:7:16
        t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16
          t24: i64 = add t7, Constant:i64<4>, test_addarray.c:7:16
        t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16
          t27: i64 = add t2, Constant:i64<4>, test_addarray.c:7:16
        t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16
          t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8
          t39: i64 = add t36, t35, test_addarray.c:9:15
        t47: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13), trunc to i32> t12, t39, t11, undef:i64, test_addarray.c:9:8
      t30: ch = TokenFactor t19, t23, t26, t29, t47, test_addarray.c:7:2
    t32: ch = brcond t30, t44:1, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
  t34: ch = br t32, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2



Legalizing: t34: ch = br t32, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t32: ch = brcond t30, t44:1, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
Trying custom legalization
Creating constant: t48: i64 = Constant<0>
Creating new node: t50: ch = RISCVISD::BR_CC t30, t44:1, Constant:i64<0>, setne:ch, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
Successfully custom legalized node
 ... replacing: t32: ch = brcond t30, t44:1, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
     with:      t50: ch = RISCVISD::BR_CC t30, t44:1, Constant:i64<0>, setne:ch, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2

Legalizing: t30: ch = TokenFactor t19, t23, t26, t29, t47, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t47: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13), trunc to i32> t12, t39, t11, undef:i64, test_addarray.c:9:8
Legalizing truncating store operations

Legalizing: t19: ch = CopyToReg t0, Register:i64 %17, t44, test_addarray.c:7:16
Legal node: nothing to do

Legalizing: t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16
Legal node: nothing to do

Legalizing: t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16
Legal node: nothing to do

Legalizing: t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8
Legal node: nothing to do

Legalizing: t39: i64 = add t36, t35, test_addarray.c:9:15
Legal node: nothing to do

Legalizing: t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16
Legal node: nothing to do

Legalizing: t44: i64,i64 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16
Trying to expand node
Creating new node: t51: i64 = add t15, Constant:i64<1>, test_addarray.c:7:16
Creating new node: t53: i64 = setcc t51, t15, setult:ch, test_addarray.c:7:16
Successfully expanded node
 ... replacing: t44: i64,i64 = uaddo t15, Constant:i64<1>, test_addarray.c:7:16
     with:      t51: i64 = add t15, Constant:i64<1>, test_addarray.c:7:16
      and:      t53: i64 = setcc t51, t15, setult:ch, test_addarray.c:7:16

Legalizing: t21: i64 = add t11, Constant:i64<4>, test_addarray.c:7:16
Legal node: nothing to do

Legalizing: t24: i64 = add t7, Constant:i64<4>, test_addarray.c:7:16
Legal node: nothing to do

Legalizing: t36: i64,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13), anyext from i32> t0, t7, undef:i64, test_addarray.c:9:17
Legalizing extending load operation

Legalizing: t27: i64 = add t2, Constant:i64<4>, test_addarray.c:7:16
Legal node: nothing to do

Legalizing: t35: i64,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13), anyext from i32> t0, t2, undef:i64, test_addarray.c:9:10
Legalizing extending load operation

Legalizing: t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16
Legal node: nothing to do

Legalizing: t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8
Legal node: nothing to do

Legalizing: t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10
Legal node: nothing to do

Legalizing: t33: ch = BasicBlock<for.body 0xe2adb0>
Legal node: nothing to do

Legalizing: t31: ch = BasicBlock<for.cond.cleanup 0xe2acd0>
Legal node: nothing to do

Legalizing: t28: i64 = Register %20

Legalizing: t25: i64 = Register %19

Legalizing: t22: i64 = Register %18

Legalizing: t20: i64 = Constant<4>
Legal node: nothing to do

Legalizing: t18: i64 = Register %17

Legalizing: t16: i64 = Constant<1>
Legal node: nothing to do

Legalizing: t14: i64 = Register %16

Legalizing: t10: i64 = Register %15

Legalizing: t6: i64 = Register %14

Legalizing: t4: i64 = undef
Legal node: nothing to do

Legalizing: t1: i64 = Register %13

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t53: i64 = setcc t51, t15, setult:ch, test_addarray.c:7:16
Legal node: nothing to do

Legalizing: t52: ch = setult
Legal node: nothing to do

Legalizing: t51: i64 = add t15, Constant:i64<1>, test_addarray.c:7:16
Legal node: nothing to do

Legalizing: t50: ch = RISCVISD::BR_CC t30, t53, Constant:i64<0>, setne:ch, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
Legal node: nothing to do

Legalizing: t49: ch = setne
Legal node: nothing to do

Legalizing: t48: i64 = Constant<0>
Legal node: nothing to do
Legalized selection DAG: %bb.5 'add:for.body'
SelectionDAG has 38 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10
  t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17
  t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8
  t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16
  t35: i64,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13), anyext from i32> t0, t2, undef:i64, test_addarray.c:9:10
  t36: i64,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13), anyext from i32> t0, t7, undef:i64, test_addarray.c:9:17
  t51: i64 = add t15, Constant:i64<1>, test_addarray.c:7:16
        t19: ch = CopyToReg t0, Register:i64 %17, t51, test_addarray.c:7:16
          t21: i64 = add t11, Constant:i64<4>, test_addarray.c:7:16
        t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16
          t24: i64 = add t7, Constant:i64<4>, test_addarray.c:7:16
        t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16
          t27: i64 = add t2, Constant:i64<4>, test_addarray.c:7:16
        t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16
          t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8
          t39: i64 = add t36, t35, test_addarray.c:9:15
        t47: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13), trunc to i32> t12, t39, t11, undef:i64, test_addarray.c:9:8
      t30: ch = TokenFactor t19, t23, t26, t29, t47, test_addarray.c:7:2
      t53: i64 = setcc t51, t15, setult:ch, test_addarray.c:7:16
    t50: ch = RISCVISD::BR_CC t30, t53, Constant:i64<0>, setne:ch, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
  t34: ch = br t50, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2



Legalizing: t53: i64 = setcc t51, t15, setult:ch, test_addarray.c:7:16
Legal node: nothing to do

Combining: t53: i64 = setcc t51, t15, setult:ch, test_addarray.c:7:16

Legalizing: t52: ch = setult
Legal node: nothing to do

Combining: t52: ch = setult

Legalizing: t51: i64 = add t15, Constant:i64<1>, test_addarray.c:7:16
Legal node: nothing to do

Combining: t51: i64 = add t15, Constant:i64<1>, test_addarray.c:7:16

Legalizing: t50: ch = RISCVISD::BR_CC t30, t53, Constant:i64<0>, setne:ch, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
Legal node: nothing to do

Combining: t50: ch = RISCVISD::BR_CC t30, t53, Constant:i64<0>, setne:ch, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
Creating new node: t54: ch = RISCVISD::BR_CC t30, t51, t15, setult:ch, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
 ... into: t54: ch = RISCVISD::BR_CC t30, t51, t15, setult:ch, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2

Legalizing: t51: i64 = add t15, Constant:i64<1>, test_addarray.c:7:16
Legal node: nothing to do

Combining: t51: i64 = add t15, Constant:i64<1>, test_addarray.c:7:16

Legalizing: t52: ch = setult
Legal node: nothing to do

Combining: t52: ch = setult

Legalizing: t54: ch = RISCVISD::BR_CC t30, t51, t15, setult:ch, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
Legal node: nothing to do

Combining: t54: ch = RISCVISD::BR_CC t30, t51, t15, setult:ch, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2

Legalizing: t34: ch = br t54, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2
Legal node: nothing to do

Combining: t34: ch = br t54, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2

Legalizing: t30: ch = TokenFactor t19, t23, t26, t29, t47, test_addarray.c:7:2
Legal node: nothing to do

Combining: t30: ch = TokenFactor t19, t23, t26, t29, t47, test_addarray.c:7:2

Legalizing: t47: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13), trunc to i32> t12, t39, t11, undef:i64, test_addarray.c:9:8
Legalizing truncating store operations

Combining: t47: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13), trunc to i32> t12, t39, t11, undef:i64, test_addarray.c:9:8

Legalizing: t19: ch = CopyToReg t0, Register:i64 %17, t51, test_addarray.c:7:16
Legal node: nothing to do

Combining: t19: ch = CopyToReg t0, Register:i64 %17, t51, test_addarray.c:7:16

Legalizing: t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16
Legal node: nothing to do

Combining: t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16

Legalizing: t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16
Legal node: nothing to do

Combining: t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16

Legalizing: t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8
Legal node: nothing to do

Combining: t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8

Legalizing: t39: i64 = add t36, t35, test_addarray.c:9:15
Legal node: nothing to do

Combining: t39: i64 = add t36, t35, test_addarray.c:9:15

Legalizing: t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16
Legal node: nothing to do

Combining: t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16

Legalizing: t21: i64 = add t11, Constant:i64<4>, test_addarray.c:7:16
Legal node: nothing to do

Combining: t21: i64 = add t11, Constant:i64<4>, test_addarray.c:7:16

Legalizing: t24: i64 = add t7, Constant:i64<4>, test_addarray.c:7:16
Legal node: nothing to do

Combining: t24: i64 = add t7, Constant:i64<4>, test_addarray.c:7:16

Legalizing: t36: i64,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13), anyext from i32> t0, t7, undef:i64, test_addarray.c:9:17
Legalizing extending load operation

Combining: t36: i64,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13), anyext from i32> t0, t7, undef:i64, test_addarray.c:9:17

Legalizing: t27: i64 = add t2, Constant:i64<4>, test_addarray.c:7:16
Legal node: nothing to do

Combining: t27: i64 = add t2, Constant:i64<4>, test_addarray.c:7:16

Legalizing: t35: i64,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13), anyext from i32> t0, t2, undef:i64, test_addarray.c:9:10
Legalizing extending load operation

Combining: t35: i64,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13), anyext from i32> t0, t2, undef:i64, test_addarray.c:9:10

Legalizing: t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16
Legal node: nothing to do

Combining: t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16

Legalizing: t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8
Legal node: nothing to do

Combining: t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8

Legalizing: t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17
Legal node: nothing to do

Combining: t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10

Legalizing: t33: ch = BasicBlock<for.body 0xe2adb0>
Legal node: nothing to do

Combining: t33: ch = BasicBlock<for.body 0xe2adb0>

Legalizing: t31: ch = BasicBlock<for.cond.cleanup 0xe2acd0>
Legal node: nothing to do

Combining: t31: ch = BasicBlock<for.cond.cleanup 0xe2acd0>

Legalizing: t28: i64 = Register %20

Combining: t28: i64 = Register %20

Legalizing: t25: i64 = Register %19

Combining: t25: i64 = Register %19

Legalizing: t22: i64 = Register %18

Combining: t22: i64 = Register %18

Legalizing: t20: i64 = Constant<4>
Legal node: nothing to do

Combining: t20: i64 = Constant<4>

Legalizing: t18: i64 = Register %17

Combining: t18: i64 = Register %17

Legalizing: t16: i64 = Constant<1>
Legal node: nothing to do

Combining: t16: i64 = Constant<1>

Legalizing: t14: i64 = Register %16

Combining: t14: i64 = Register %16

Legalizing: t10: i64 = Register %15

Combining: t10: i64 = Register %15

Legalizing: t6: i64 = Register %14

Combining: t6: i64 = Register %14

Legalizing: t4: i64 = undef
Legal node: nothing to do

Combining: t4: i64 = undef

Legalizing: t1: i64 = Register %13

Combining: t1: i64 = Register %13

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.5 'add:for.body'
SelectionDAG has 35 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10
  t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17
  t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8
  t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16
  t35: i64,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13), anyext from i32> t0, t2, undef:i64, test_addarray.c:9:10
  t36: i64,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13), anyext from i32> t0, t7, undef:i64, test_addarray.c:9:17
  t51: i64 = add t15, Constant:i64<1>, test_addarray.c:7:16
        t19: ch = CopyToReg t0, Register:i64 %17, t51, test_addarray.c:7:16
          t21: i64 = add t11, Constant:i64<4>, test_addarray.c:7:16
        t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16
          t24: i64 = add t7, Constant:i64<4>, test_addarray.c:7:16
        t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16
          t27: i64 = add t2, Constant:i64<4>, test_addarray.c:7:16
        t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16
          t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8
          t39: i64 = add t36, t35, test_addarray.c:9:15
        t47: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13), trunc to i32> t12, t39, t11, undef:i64, test_addarray.c:9:8
      t30: ch = TokenFactor t19, t23, t26, t29, t47, test_addarray.c:7:2
    t54: ch = RISCVISD::BR_CC t30, t51, t15, setult:ch, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
  t34: ch = br t54, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2


===== Instruction selection begins: %bb.5 'for.body'

ISEL: Starting selection on root node: t34: ch = br t54, BasicBlock:ch<for.body 0xe2adb0>, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 895177
  Morphed node: t34: ch = PseudoBR BasicBlock:ch<for.body 0xe2adb0>, t54, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t54: ch = RISCVISD::BR_CC t30, t51, t15, setult:ch, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, test_addarray.c:7:2
ISEL: Starting pattern match
  Initial Opcode index to 907160
  Skipped scope entry (due to false predicate) at index 907171, continuing at 907191
  Skipped scope entry (due to false predicate) at index 907192, continuing at 907212
  Skipped scope entry (due to false predicate) at index 907213, continuing at 907233
  Skipped scope entry (due to false predicate) at index 907234, continuing at 907254
  Morphed node: t54: ch = BLTU t51, t15, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, t30, test_addarray.c:7:2
ISEL: Match complete!

ISEL: Starting selection on root node: t30: ch = TokenFactor t19, t23, t26, t29, t47, test_addarray.c:7:2

ISEL: Starting selection on root node: t47: ch = store<(store (s32) into %ir.lsr.iv2, !tbaa !13), trunc to i32> t12, t39, t11, undef:i64, test_addarray.c:9:8
ISEL: Starting pattern match
  Initial Opcode index to 32754
  Skipped scope entry (due to false predicate) at index 32760, continuing at 32934
  Match failed at index 32942
  Continuing at 33146
  Skipped scope entry (due to false predicate) at index 33156, continuing at 33175
  Skipped scope entry (due to false predicate) at index 33176, continuing at 33195
Creating constant: t55: i64 = TargetConstant<0>
  Morphed node: t47: ch = SW<Mem:(store (s32) into %ir.lsr.iv2, !tbaa !13)> t39, t11, TargetConstant:i64<0>, t12, test_addarray.c:9:8
ISEL: Match complete!

ISEL: Starting selection on root node: t19: ch = CopyToReg t0, Register:i64 %17, t51, test_addarray.c:7:16

ISEL: Starting selection on root node: t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16

ISEL: Starting selection on root node: t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16

ISEL: Starting selection on root node: t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8

ISEL: Starting selection on root node: t39: i64 = add t36, t35, test_addarray.c:9:15
ISEL: Starting pattern match
  Initial Opcode index to 16032
  Skipped scope entry (due to false predicate) at index 16038, continuing at 16121
  Skipped scope entry (due to false predicate) at index 16122, continuing at 16156
  Skipped scope entry (due to false predicate) at index 16157, continuing at 16191
  Skipped scope entry (due to false predicate) at index 16192, continuing at 16226
  Match failed at index 16036
  Continuing at 16227
  Skipped scope entry (due to false predicate) at index 16240, continuing at 16308
  Skipped scope entry (due to false predicate) at index 16309, continuing at 16338
  Skipped scope entry (due to false predicate) at index 16339, continuing at 16368
  Skipped scope entry (due to false predicate) at index 16369, continuing at 16398
  Match failed at index 16238
  Continuing at 16399
  Match failed at index 16402
  Continuing at 16444
  Continuing at 16445
  Skipped scope entry (due to false predicate) at index 16451, continuing at 16598
  Skipped scope entry (due to false predicate) at index 16599, continuing at 16624
  Match failed at index 16448
  Continuing at 16625
  Skipped scope entry (due to false predicate) at index 16635, continuing at 16752
  Skipped scope entry (due to false predicate) at index 16753, continuing at 16773
  Match failed at index 16633
  Continuing at 16774
  Match failed at index 16777
  Continuing at 17225
  Match failed at index 17232
  Continuing at 17671
  Match failed at index 17677
  Continuing at 17778
  Morphed node: t39: i64 = ADD t36, t35, test_addarray.c:9:15
ISEL: Match complete!

ISEL: Starting selection on root node: t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16

ISEL: Starting selection on root node: t51: i64 = add t15, Constant:i64<1>, test_addarray.c:7:16
ISEL: Starting pattern match
  Initial Opcode index to 16032
  Skipped scope entry (due to false predicate) at index 16038, continuing at 16121
  Skipped scope entry (due to false predicate) at index 16122, continuing at 16156
  Skipped scope entry (due to false predicate) at index 16157, continuing at 16191
  Skipped scope entry (due to false predicate) at index 16192, continuing at 16226
  Match failed at index 16036
  Continuing at 16227
  Skipped scope entry (due to false predicate) at index 16240, continuing at 16308
  Skipped scope entry (due to false predicate) at index 16309, continuing at 16338
  Skipped scope entry (due to false predicate) at index 16339, continuing at 16368
  Skipped scope entry (due to false predicate) at index 16369, continuing at 16398
  Match failed at index 16238
  Continuing at 16399
  TypeSwitch[i64] from 16408 to 16411
  Match failed at index 16413
  Continuing at 16444
  Continuing at 16445
  Skipped scope entry (due to false predicate) at index 16451, continuing at 16598
  Skipped scope entry (due to false predicate) at index 16599, continuing at 16624
  Match failed at index 16448
  Continuing at 16625
  Skipped scope entry (due to false predicate) at index 16635, continuing at 16752
  Skipped scope entry (due to false predicate) at index 16753, continuing at 16773
  Match failed at index 16633
  Continuing at 16774
  Match failed at index 16777
  Continuing at 17225
  Match failed at index 17232
  Continuing at 17671
  TypeSwitch[i64] from 17685 to 17688
Creating constant: t56: i64 = TargetConstant<1>
  Morphed node: t51: i64 = ADDI t15, TargetConstant:i64<1>, test_addarray.c:7:16
ISEL: Match complete!

ISEL: Starting selection on root node: t21: i64 = add t11, Constant:i64<4>, test_addarray.c:7:16
ISEL: Starting pattern match
  Initial Opcode index to 16032
  Skipped scope entry (due to false predicate) at index 16038, continuing at 16121
  Skipped scope entry (due to false predicate) at index 16122, continuing at 16156
  Skipped scope entry (due to false predicate) at index 16157, continuing at 16191
  Skipped scope entry (due to false predicate) at index 16192, continuing at 16226
  Match failed at index 16036
  Continuing at 16227
  Skipped scope entry (due to false predicate) at index 16240, continuing at 16308
  Skipped scope entry (due to false predicate) at index 16309, continuing at 16338
  Skipped scope entry (due to false predicate) at index 16339, continuing at 16368
  Skipped scope entry (due to false predicate) at index 16369, continuing at 16398
  Match failed at index 16238
  Continuing at 16399
  TypeSwitch[i64] from 16408 to 16411
  Match failed at index 16413
  Continuing at 16444
  Continuing at 16445
  Skipped scope entry (due to false predicate) at index 16451, continuing at 16598
  Skipped scope entry (due to false predicate) at index 16599, continuing at 16624
  Match failed at index 16448
  Continuing at 16625
  Skipped scope entry (due to false predicate) at index 16635, continuing at 16752
  Skipped scope entry (due to false predicate) at index 16753, continuing at 16773
  Match failed at index 16633
  Continuing at 16774
  Match failed at index 16777
  Continuing at 17225
  Match failed at index 17232
  Continuing at 17671
  TypeSwitch[i64] from 17685 to 17688
Creating constant: t57: i64 = TargetConstant<4>
  Morphed node: t21: i64 = ADDI t11, TargetConstant:i64<4>, test_addarray.c:7:16
ISEL: Match complete!

ISEL: Starting selection on root node: t24: i64 = add t7, Constant:i64<4>, test_addarray.c:7:16
ISEL: Starting pattern match
  Initial Opcode index to 16032
  Skipped scope entry (due to false predicate) at index 16038, continuing at 16121
  Skipped scope entry (due to false predicate) at index 16122, continuing at 16156
  Skipped scope entry (due to false predicate) at index 16157, continuing at 16191
  Skipped scope entry (due to false predicate) at index 16192, continuing at 16226
  Match failed at index 16036
  Continuing at 16227
  Skipped scope entry (due to false predicate) at index 16240, continuing at 16308
  Skipped scope entry (due to false predicate) at index 16309, continuing at 16338
  Skipped scope entry (due to false predicate) at index 16339, continuing at 16368
  Skipped scope entry (due to false predicate) at index 16369, continuing at 16398
  Match failed at index 16238
  Continuing at 16399
  TypeSwitch[i64] from 16408 to 16411
  Match failed at index 16413
  Continuing at 16444
  Continuing at 16445
  Skipped scope entry (due to false predicate) at index 16451, continuing at 16598
  Skipped scope entry (due to false predicate) at index 16599, continuing at 16624
  Match failed at index 16448
  Continuing at 16625
  Skipped scope entry (due to false predicate) at index 16635, continuing at 16752
  Skipped scope entry (due to false predicate) at index 16753, continuing at 16773
  Match failed at index 16633
  Continuing at 16774
  Match failed at index 16777
  Continuing at 17225
  Match failed at index 17232
  Continuing at 17671
  TypeSwitch[i64] from 17685 to 17688
  Morphed node: t24: i64 = ADDI t7, TargetConstant:i64<4>, test_addarray.c:7:16
ISEL: Match complete!

ISEL: Starting selection on root node: t36: i64,ch = load<(load (s32) from %ir.lsr.iv5, !tbaa !13), anyext from i32> t0, t7, undef:i64, test_addarray.c:9:17
ISEL: Starting pattern match
  Initial Opcode index to 35769
  Match failed at index 35775
  Continuing at 36559
  Skipped scope entry (due to false predicate) at index 36566, continuing at 36610
  Match failed at index 36613
  Continuing at 36655
  Match failed at index 36656
  Continuing at 36700
  Match failed at index 36703
  Continuing at 36745
  Match failed at index 36746
  Continuing at 36767
  Match failed at index 36768
  Continuing at 36858
  Match failed at index 36859
  Continuing at 36882
  Morphed node: t36: i64,ch = LW<Mem:(load (s32) from %ir.lsr.iv5, !tbaa !13)> t7, TargetConstant:i64<0>, t0, test_addarray.c:9:17
ISEL: Match complete!

ISEL: Starting selection on root node: t27: i64 = add t2, Constant:i64<4>, test_addarray.c:7:16
ISEL: Starting pattern match
  Initial Opcode index to 16032
  Skipped scope entry (due to false predicate) at index 16038, continuing at 16121
  Skipped scope entry (due to false predicate) at index 16122, continuing at 16156
  Skipped scope entry (due to false predicate) at index 16157, continuing at 16191
  Skipped scope entry (due to false predicate) at index 16192, continuing at 16226
  Match failed at index 16036
  Continuing at 16227
  Skipped scope entry (due to false predicate) at index 16240, continuing at 16308
  Skipped scope entry (due to false predicate) at index 16309, continuing at 16338
  Skipped scope entry (due to false predicate) at index 16339, continuing at 16368
  Skipped scope entry (due to false predicate) at index 16369, continuing at 16398
  Match failed at index 16238
  Continuing at 16399
  TypeSwitch[i64] from 16408 to 16411
  Match failed at index 16413
  Continuing at 16444
  Continuing at 16445
  Skipped scope entry (due to false predicate) at index 16451, continuing at 16598
  Skipped scope entry (due to false predicate) at index 16599, continuing at 16624
  Match failed at index 16448
  Continuing at 16625
  Skipped scope entry (due to false predicate) at index 16635, continuing at 16752
  Skipped scope entry (due to false predicate) at index 16753, continuing at 16773
  Match failed at index 16633
  Continuing at 16774
  Match failed at index 16777
  Continuing at 17225
  Match failed at index 17232
  Continuing at 17671
  TypeSwitch[i64] from 17685 to 17688
  Morphed node: t27: i64 = ADDI t2, TargetConstant:i64<4>, test_addarray.c:7:16
ISEL: Match complete!

ISEL: Starting selection on root node: t35: i64,ch = load<(load (s32) from %ir.lsr.iv8, !tbaa !13), anyext from i32> t0, t2, undef:i64, test_addarray.c:9:10
ISEL: Starting pattern match
  Initial Opcode index to 35769
  Match failed at index 35775
  Continuing at 36559
  Skipped scope entry (due to false predicate) at index 36566, continuing at 36610
  Match failed at index 36613
  Continuing at 36655
  Match failed at index 36656
  Continuing at 36700
  Match failed at index 36703
  Continuing at 36745
  Match failed at index 36746
  Continuing at 36767
  Match failed at index 36768
  Continuing at 36858
  Match failed at index 36859
  Continuing at 36882
  Morphed node: t35: i64,ch = LW<Mem:(load (s32) from %ir.lsr.iv8, !tbaa !13)> t2, TargetConstant:i64<0>, t0, test_addarray.c:9:10
ISEL: Match complete!

ISEL: Starting selection on root node: t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16

ISEL: Starting selection on root node: t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8

ISEL: Starting selection on root node: t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10

ISEL: Starting selection on root node: t33: ch = BasicBlock<for.body 0xe2adb0>

ISEL: Starting selection on root node: t31: ch = BasicBlock<for.cond.cleanup 0xe2acd0>

ISEL: Starting selection on root node: t28: i64 = Register %20

ISEL: Starting selection on root node: t25: i64 = Register %19

ISEL: Starting selection on root node: t22: i64 = Register %18

ISEL: Starting selection on root node: t18: i64 = Register %17

ISEL: Starting selection on root node: t14: i64 = Register %16

ISEL: Starting selection on root node: t10: i64 = Register %15

ISEL: Starting selection on root node: t6: i64 = Register %14

ISEL: Starting selection on root node: t1: i64 = Register %13

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.5 'add:for.body'
SelectionDAG has 34 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10
  t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17
  t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8
  t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16
  t35: i64,ch = LW<Mem:(load (s32) from %ir.lsr.iv8, !tbaa !13)> t2, TargetConstant:i64<0>, t0, test_addarray.c:9:10
  t36: i64,ch = LW<Mem:(load (s32) from %ir.lsr.iv5, !tbaa !13)> t7, TargetConstant:i64<0>, t0, test_addarray.c:9:17
  t51: i64 = ADDI t15, TargetConstant:i64<1>, test_addarray.c:7:16
        t19: ch = CopyToReg t0, Register:i64 %17, t51, test_addarray.c:7:16
          t21: i64 = ADDI t11, TargetConstant:i64<4>, test_addarray.c:7:16
        t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16
          t24: i64 = ADDI t7, TargetConstant:i64<4>, test_addarray.c:7:16
        t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16
          t27: i64 = ADDI t2, TargetConstant:i64<4>, test_addarray.c:7:16
        t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16
          t39: i64 = ADD t36, t35, test_addarray.c:9:15
          t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8
        t47: ch = SW<Mem:(store (s32) into %ir.lsr.iv2, !tbaa !13)> t39, t11, TargetConstant:i64<0>, t12, test_addarray.c:9:8
      t30: ch = TokenFactor t19, t23, t26, t29, t47, test_addarray.c:7:2
    t54: ch = BLTU t51, t15, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, t30, test_addarray.c:7:2
  t34: ch = PseudoBR BasicBlock:ch<for.body 0xe2adb0>, t54, test_addarray.c:7:2


********** List Scheduling %bb.5 'for.body' **********
SU(0): t34: ch = PseudoBR BasicBlock:ch<for.body 0xe2adb0>, t54, test_addarray.c:7:2

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t54: ch = BLTU t51, t15, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, t30, test_addarray.c:7:2

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(19): Data Latency=1
    SU(18): Data Latency=1
    SU(2): Ord  Latency=0 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t30: ch = TokenFactor t19, t23, t26, t29, t47, test_addarray.c:7:2

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(17): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(13): Ord  Latency=1 Barrier
    SU(11): Ord  Latency=1 Barrier
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(3): t47: ch = SW<Mem:(store (s32) into %ir.lsr.iv2, !tbaa !13)> t39, t11, TargetConstant:i64<0>, t12, test_addarray.c:9:8

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(10): Data Latency=1
    SU(9): Data Latency=1
    SU(4): Ord  Latency=0 Barrier
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(4): t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(7): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(3): Ord  Latency=0 Barrier
SU(5): t36: i64,ch = LW<Mem:(load (s32) from %ir.lsr.iv5, !tbaa !13)> t7, TargetConstant:i64<0>, t0, test_addarray.c:9:17

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(10): Data Latency=1
SU(6): t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(5): Data Latency=1
    SU(14): Data Latency=1
SU(7): t35: i64,ch = LW<Mem:(load (s32) from %ir.lsr.iv8, !tbaa !13)> t2, TargetConstant:i64<0>, t0, test_addarray.c:9:10

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(8): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(10): Data Latency=1
SU(8): t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(7): Data Latency=1
    SU(12): Data Latency=1
SU(9): t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Data Latency=1
    SU(16): Data Latency=1
SU(10): t39: i64 = ADD t36, t35, test_addarray.c:9:15

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
    SU(7): Data Latency=1
  Successors:
    SU(3): Data Latency=1
SU(11): t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(12): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(12): t27: i64 = ADDI t2, TargetConstant:i64<4>, test_addarray.c:7:16

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(8): Data Latency=1
  Successors:
    SU(11): Data Latency=1
SU(13): t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(14): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(14): t24: i64 = ADDI t7, TargetConstant:i64<4>, test_addarray.c:7:16

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(13): Data Latency=1
SU(15): t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(16): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(16): t21: i64 = ADDI t11, TargetConstant:i64<4>, test_addarray.c:7:16

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(9): Data Latency=1
  Successors:
    SU(15): Data Latency=1
SU(17): t19: ch = CopyToReg t0, Register:i64 %17, t51, test_addarray.c:7:16

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(19): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
SU(18): t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(1): Data Latency=1
    SU(19): Data Latency=1
SU(19): t51: i64 = ADDI t15, TargetConstant:i64<1>, test_addarray.c:7:16

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(18): Data Latency=1
  Successors:
    SU(1): Data Latency=1
    SU(17): Data Latency=1
VRegCycle: SU(12)
VRegCycle: SU(14)
VRegCycle: SU(16)

Examining Available:
Height 0: SU(0): t34: ch = PseudoBR BasicBlock:ch<for.body 0xe2adb0>, t54, test_addarray.c:7:2


*** Scheduling [0]: SU(0): t34: ch = PseudoBR BasicBlock:ch<for.body 0xe2adb0>, t54, test_addarray.c:7:2


Examining Available:
Height 1: SU(1): t54: ch = BLTU t51, t15, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, t30, test_addarray.c:7:2


*** Scheduling [1]: SU(1): t54: ch = BLTU t51, t15, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, t30, test_addarray.c:7:2


Examining Available:
Height 1: SU(2): t30: ch = TokenFactor t19, t23, t26, t29, t47, test_addarray.c:7:2


*** Scheduling [2]: SU(2): t30: ch = TokenFactor t19, t23, t26, t29, t47, test_addarray.c:7:2


Examining Available:
Height 3: SU(11): t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16

Height 3: SU(13): t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16

Height 3: SU(15): t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16

Height 3: SU(17): t19: ch = CopyToReg t0, Register:i64 %17, t51, test_addarray.c:7:16

Height 3: SU(3): t47: ch = SW<Mem:(store (s32) into %ir.lsr.iv2, !tbaa !13)> t39, t11, TargetConstant:i64<0>, t12, test_addarray.c:9:8


*** Scheduling [3]: SU(11): t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16


Examining Available:
Height 4: SU(12): t27: i64 = ADDI t2, TargetConstant:i64<4>, test_addarray.c:7:16

Height 3: SU(13): t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16

Height 3: SU(15): t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16

Height 3: SU(17): t19: ch = CopyToReg t0, Register:i64 %17, t51, test_addarray.c:7:16

Height 3: SU(3): t47: ch = SW<Mem:(store (s32) into %ir.lsr.iv2, !tbaa !13)> t39, t11, TargetConstant:i64<0>, t12, test_addarray.c:9:8


*** Scheduling [4]: SU(12): t27: i64 = ADDI t2, TargetConstant:i64<4>, test_addarray.c:7:16


Examining Available:
Height 3: SU(13): t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16

Height 3: SU(15): t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16

Height 3: SU(17): t19: ch = CopyToReg t0, Register:i64 %17, t51, test_addarray.c:7:16

Height 3: SU(3): t47: ch = SW<Mem:(store (s32) into %ir.lsr.iv2, !tbaa !13)> t39, t11, TargetConstant:i64<0>, t12, test_addarray.c:9:8


*** Scheduling [5]: SU(13): t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16


Examining Available:
Height 6: SU(14): t24: i64 = ADDI t7, TargetConstant:i64<4>, test_addarray.c:7:16

Height 3: SU(15): t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16

Height 3: SU(17): t19: ch = CopyToReg t0, Register:i64 %17, t51, test_addarray.c:7:16

Height 3: SU(3): t47: ch = SW<Mem:(store (s32) into %ir.lsr.iv2, !tbaa !13)> t39, t11, TargetConstant:i64<0>, t12, test_addarray.c:9:8


*** Scheduling [6]: SU(14): t24: i64 = ADDI t7, TargetConstant:i64<4>, test_addarray.c:7:16


Examining Available:
Height 3: SU(15): t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16

Height 3: SU(17): t19: ch = CopyToReg t0, Register:i64 %17, t51, test_addarray.c:7:16

Height 3: SU(3): t47: ch = SW<Mem:(store (s32) into %ir.lsr.iv2, !tbaa !13)> t39, t11, TargetConstant:i64<0>, t12, test_addarray.c:9:8


*** Scheduling [7]: SU(15): t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16


Examining Available:
Height 8: SU(16): t21: i64 = ADDI t11, TargetConstant:i64<4>, test_addarray.c:7:16

Height 3: SU(17): t19: ch = CopyToReg t0, Register:i64 %17, t51, test_addarray.c:7:16

Height 3: SU(3): t47: ch = SW<Mem:(store (s32) into %ir.lsr.iv2, !tbaa !13)> t39, t11, TargetConstant:i64<0>, t12, test_addarray.c:9:8


*** Scheduling [8]: SU(16): t21: i64 = ADDI t11, TargetConstant:i64<4>, test_addarray.c:7:16


Examining Available:
Height 3: SU(17): t19: ch = CopyToReg t0, Register:i64 %17, t51, test_addarray.c:7:16

Height 3: SU(3): t47: ch = SW<Mem:(store (s32) into %ir.lsr.iv2, !tbaa !13)> t39, t11, TargetConstant:i64<0>, t12, test_addarray.c:9:8


*** Scheduling [9]: SU(17): t19: ch = CopyToReg t0, Register:i64 %17, t51, test_addarray.c:7:16


Examining Available:
Height 10: SU(19): t51: i64 = ADDI t15, TargetConstant:i64<1>, test_addarray.c:7:16

Height 3: SU(3): t47: ch = SW<Mem:(store (s32) into %ir.lsr.iv2, !tbaa !13)> t39, t11, TargetConstant:i64<0>, t12, test_addarray.c:9:8


*** Scheduling [10]: SU(19): t51: i64 = ADDI t15, TargetConstant:i64<1>, test_addarray.c:7:16


Examining Available:
Height 11: SU(18): t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16

Height 3: SU(3): t47: ch = SW<Mem:(store (s32) into %ir.lsr.iv2, !tbaa !13)> t39, t11, TargetConstant:i64<0>, t12, test_addarray.c:9:8


*** Scheduling [11]: SU(18): t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16


Examining Available:
Height 3: SU(3): t47: ch = SW<Mem:(store (s32) into %ir.lsr.iv2, !tbaa !13)> t39, t11, TargetConstant:i64<0>, t12, test_addarray.c:9:8


*** Scheduling [12]: SU(3): t47: ch = SW<Mem:(store (s32) into %ir.lsr.iv2, !tbaa !13)> t39, t11, TargetConstant:i64<0>, t12, test_addarray.c:9:8


Examining Available:
Height 12: SU(4): t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8

Height 13: SU(9): t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8

Height 13: SU(10): t39: i64 = ADD t36, t35, test_addarray.c:9:15


*** Scheduling [13]: SU(4): t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8


Examining Available:
Height 13: SU(9): t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8

Height 13: SU(10): t39: i64 = ADD t36, t35, test_addarray.c:9:15


*** Scheduling [14]: SU(9): t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8


Examining Available:
Height 13: SU(10): t39: i64 = ADD t36, t35, test_addarray.c:9:15


*** Scheduling [15]: SU(10): t39: i64 = ADD t36, t35, test_addarray.c:9:15


Examining Available:
Height 16: SU(5): t36: i64,ch = LW<Mem:(load (s32) from %ir.lsr.iv5, !tbaa !13)> t7, TargetConstant:i64<0>, t0, test_addarray.c:9:17

Height 16: SU(7): t35: i64,ch = LW<Mem:(load (s32) from %ir.lsr.iv8, !tbaa !13)> t2, TargetConstant:i64<0>, t0, test_addarray.c:9:10


*** Scheduling [16]: SU(5): t36: i64,ch = LW<Mem:(load (s32) from %ir.lsr.iv5, !tbaa !13)> t7, TargetConstant:i64<0>, t0, test_addarray.c:9:17


Examining Available:
Height 17: SU(6): t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17

Height 16: SU(7): t35: i64,ch = LW<Mem:(load (s32) from %ir.lsr.iv8, !tbaa !13)> t2, TargetConstant:i64<0>, t0, test_addarray.c:9:10


*** Scheduling [17]: SU(6): t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17


Examining Available:
Height 16: SU(7): t35: i64,ch = LW<Mem:(load (s32) from %ir.lsr.iv8, !tbaa !13)> t2, TargetConstant:i64<0>, t0, test_addarray.c:9:10


*** Scheduling [18]: SU(7): t35: i64,ch = LW<Mem:(load (s32) from %ir.lsr.iv8, !tbaa !13)> t2, TargetConstant:i64<0>, t0, test_addarray.c:9:10


Examining Available:
Height 19: SU(8): t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10


*** Scheduling [19]: SU(8): t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10

*** Final schedule ***
SU(8): t2: i64,ch = CopyFromReg t0, Register:i64 %13, test_addarray.c:9:10

SU(7): t35: i64,ch = LW<Mem:(load (s32) from %ir.lsr.iv8, !tbaa !13)> t2, TargetConstant:i64<0>, t0, test_addarray.c:9:10

SU(6): t7: i64,ch = CopyFromReg t0, Register:i64 %14, test_addarray.c:9:17

SU(5): t36: i64,ch = LW<Mem:(load (s32) from %ir.lsr.iv5, !tbaa !13)> t7, TargetConstant:i64<0>, t0, test_addarray.c:9:17

SU(10): t39: i64 = ADD t36, t35, test_addarray.c:9:15

SU(9): t11: i64,ch = CopyFromReg t0, Register:i64 %15, test_addarray.c:9:8

SU(4): t12: ch = TokenFactor t35:1, t36:1, test_addarray.c:9:8

SU(3): t47: ch = SW<Mem:(store (s32) into %ir.lsr.iv2, !tbaa !13)> t39, t11, TargetConstant:i64<0>, t12, test_addarray.c:9:8

SU(18): t15: i64,ch = CopyFromReg t0, Register:i64 %16, test_addarray.c:7:16

SU(19): t51: i64 = ADDI t15, TargetConstant:i64<1>, test_addarray.c:7:16

SU(17): t19: ch = CopyToReg t0, Register:i64 %17, t51, test_addarray.c:7:16

SU(16): t21: i64 = ADDI t11, TargetConstant:i64<4>, test_addarray.c:7:16

SU(15): t23: ch = CopyToReg t0, Register:i64 %18, t21, test_addarray.c:7:16

SU(14): t24: i64 = ADDI t7, TargetConstant:i64<4>, test_addarray.c:7:16

SU(13): t26: ch = CopyToReg t0, Register:i64 %19, t24, test_addarray.c:7:16

SU(12): t27: i64 = ADDI t2, TargetConstant:i64<4>, test_addarray.c:7:16

SU(11): t29: ch = CopyToReg t0, Register:i64 %20, t27, test_addarray.c:7:16

SU(2): t30: ch = TokenFactor t19, t23, t26, t29, t47, test_addarray.c:7:2

SU(1): t54: ch = BLTU t51, t15, BasicBlock:ch<for.cond.cleanup 0xe2acd0>, t30, test_addarray.c:7:2

SU(0): t34: ch = PseudoBR BasicBlock:ch<for.body 0xe2adb0>, t54, test_addarray.c:7:2


Total amount of phi nodes to update: 4
Node 0 : (0xe2ae90, 2147483668)
Node 1 : (0xe2aef8, 2147483667)
Node 2 : (0xe2af60, 2147483666)
Node 3 : (0xe2afc8, 2147483665)
Creating new node: t1: ch = RISCVISD::RET_FLAG t0, test_addarray.c:11:1
Initial selection DAG: %bb.4 'add:for.cond.cleanup'
SelectionDAG has 2 nodes:
    t0: ch = EntryToken
  t1: ch = RISCVISD::RET_FLAG t0, test_addarray.c:11:1



Combining: t1: ch = RISCVISD::RET_FLAG t0, test_addarray.c:11:1

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.4 'add:for.cond.cleanup'
SelectionDAG has 2 nodes:
    t0: ch = EntryToken
  t1: ch = RISCVISD::RET_FLAG t0, test_addarray.c:11:1


Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t1: ch = RISCVISD::RET_FLAG t0, test_addarray.c:11:1
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t1: ch = RISCVISD::RET_FLAG t0, test_addarray.c:11:1

Legalizing node: t65535: ch = handlenode t1
Analyzing result type: ch
Legal result type
Analyzing operand: t1: ch = RISCVISD::RET_FLAG t0, test_addarray.c:11:1
Legal operand
Legally typed node: t65535: ch = handlenode t1

Type-legalized selection DAG: %bb.4 'add:for.cond.cleanup'
SelectionDAG has 2 nodes:
    t0: ch = EntryToken
  t1: ch = RISCVISD::RET_FLAG t0, test_addarray.c:11:1



Legalizing: t1: ch = RISCVISD::RET_FLAG t0, test_addarray.c:11:1
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.4 'add:for.cond.cleanup'
SelectionDAG has 2 nodes:
    t0: ch = EntryToken
  t1: ch = RISCVISD::RET_FLAG t0, test_addarray.c:11:1



Legalizing: t1: ch = RISCVISD::RET_FLAG t0, test_addarray.c:11:1
Legal node: nothing to do

Combining: t1: ch = RISCVISD::RET_FLAG t0, test_addarray.c:11:1

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.4 'add:for.cond.cleanup'
SelectionDAG has 2 nodes:
    t0: ch = EntryToken
  t1: ch = RISCVISD::RET_FLAG t0, test_addarray.c:11:1


===== Instruction selection begins: %bb.4 'for.cond.cleanup'

ISEL: Starting selection on root node: t1: ch = RISCVISD::RET_FLAG t0, test_addarray.c:11:1
ISEL: Starting pattern match
  Initial Opcode index to 895194
  Morphed node: t1: ch = PseudoRET t0, test_addarray.c:11:1
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.4 'add:for.cond.cleanup'
SelectionDAG has 2 nodes:
    t0: ch = EntryToken
  t1: ch = PseudoRET t0, test_addarray.c:11:1


********** List Scheduling %bb.4 'for.cond.cleanup' **********
SU(0): t1: ch = PseudoRET t0, test_addarray.c:11:1

  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

Examining Available:
Height 0: SU(0): t1: ch = PseudoRET t0, test_addarray.c:11:1


*** Scheduling [0]: SU(0): t1: ch = PseudoRET t0, test_addarray.c:11:1

*** Final schedule ***
SU(0): t1: ch = PseudoRET t0, test_addarray.c:11:1


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function add: IsSSA, TracksLiveness
Function Live Ins: $x10 in %21, $x11 in %22, $x12 in %23

bb.0.entry:
  successors: %bb.2(0x40000000), %bb.1(0x40000000); %bb.2(50.00%), %bb.1(50.00%)
  liveins: $x10, $x11, $x12
  %23:gpr = COPY $x12
  %22:gpr = COPY $x11
  %21:gpr = COPY $x10
  %25:gpr = LUI 1
  %26:gpr = ADDIW killed %25:gpr, -100
  %27:gpr = ADD %23:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
  %28:gpr = ADD %21:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
  %29:gpr = ADD %22:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
  %30:gpr = SLTU %23:gpr, killed %28:gpr, debug-location !10; test_addarray.c:7:2
  %31:gpr = SLTU %21:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
  %32:gpr = AND killed %30:gpr, killed %31:gpr, debug-location !10; test_addarray.c:7:2
  %33:gpr = SLTU %23:gpr, killed %29:gpr, debug-location !10; test_addarray.c:7:2
  %34:gpr = SLTU %22:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
  %35:gpr = AND killed %33:gpr, killed %34:gpr, debug-location !10; test_addarray.c:7:2
  %36:gpr = OR killed %32:gpr, killed %35:gpr, debug-location !10; test_addarray.c:7:2
  %37:gpr = COPY $x0
  %24:gpr = COPY %37:gpr
  BNE killed %36:gpr, %37:gpr, %bb.2, debug-location !10; test_addarray.c:7:2
  PseudoBR %bb.1, debug-location !10; test_addarray.c:7:2

bb.1.vector.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %38:gpr = ADDI $x0, 960
  PseudoBR %bb.3, debug-location !10; test_addarray.c:7:2

bb.2.for.body.preheader:
; predecessors: %bb.0, %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)

  %0:gpr = PHI %24:gpr, %bb.0, %39:gpr, %bb.3
  %1:gpr = nuw nsw ADDI %0:gpr, -999, debug-location !10; test_addarray.c:7:2
  %45:gpr = SLLI %0:gpr, 2, debug-location !10; test_addarray.c:7:2
  %2:gpr = ADD %23:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
  %3:gpr = ADD %22:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
  %4:gpr = ADD %21:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2

bb.3.vector.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %5:gpr = PHI %21:gpr, %bb.1, %12:gpr, %bb.3, debug-location !11; test_addarray.c:7:20
  %6:gpr = PHI %22:gpr, %bb.1, %11:gpr, %bb.3, debug-location !11; test_addarray.c:7:20
  %7:gpr = PHI %23:gpr, %bb.1, %10:gpr, %bb.3, debug-location !11; test_addarray.c:7:20
  %8:gpr = PHI %38:gpr, %bb.1, %9:gpr, %bb.3, debug-location !11; test_addarray.c:7:20
  %40:gpr = ADDI $x0, 64
  %41:vrm8 = PseudoVLE32_V_M8 %5:gpr, %40:gpr, 5, debug-location !12 :: (load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17); test_addarray.c:9:10
  %42:vrm8 = PseudoVLE32_V_M8 %6:gpr, %40:gpr, 5, debug-location !20 :: (load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21); test_addarray.c:9:17
  %43:vrm8 = PseudoVADD_VV_M8 killed %42:vrm8, killed %41:vrm8, %40:gpr, 5, debug-location !23; test_addarray.c:9:15
  PseudoVSE32_V_M8 killed %43:vrm8, %7:gpr, %40:gpr, 5, debug-location !24 :: (store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27); test_addarray.c:9:8
  %9:gpr = nsw ADDI %8:gpr, -64, debug-location !11; test_addarray.c:7:20
  %10:gpr = ADDI %7:gpr, 256, debug-location !11; test_addarray.c:7:20
  %11:gpr = ADDI %6:gpr, 256, debug-location !11; test_addarray.c:7:20
  %12:gpr = ADDI %5:gpr, 256, debug-location !11; test_addarray.c:7:20
  %39:gpr = ADDI $x0, 960
  %44:gpr = COPY $x0
  BEQ %9:gpr, %44:gpr, %bb.2, debug-location !11; test_addarray.c:7:20
  PseudoBR %bb.3, debug-location !11; test_addarray.c:7:20

bb.4.for.cond.cleanup:
; predecessors: %bb.5

  PseudoRET debug-location !32; test_addarray.c:11:1

bb.5.for.body:
; predecessors: %bb.2, %bb.5
  successors: %bb.4(0x04000000), %bb.5(0x7c000000); %bb.4(3.12%), %bb.5(96.88%)

  %13:gpr = PHI %4:gpr, %bb.2, %20:gpr, %bb.5
  %14:gpr = PHI %3:gpr, %bb.2, %19:gpr, %bb.5
  %15:gpr = PHI %2:gpr, %bb.2, %18:gpr, %bb.5
  %16:gpr = PHI %1:gpr, %bb.2, %17:gpr, %bb.5
  %46:gpr = LW %13:gpr, 0, debug-location !12 :: (load (s32) from %ir.lsr.iv8, !tbaa !13); test_addarray.c:9:10
  %47:gpr = LW %14:gpr, 0, debug-location !20 :: (load (s32) from %ir.lsr.iv5, !tbaa !13); test_addarray.c:9:17
  %48:gpr = ADD killed %47:gpr, killed %46:gpr, debug-location !23; test_addarray.c:9:15
  SW killed %48:gpr, %15:gpr, 0, debug-location !24 :: (store (s32) into %ir.lsr.iv2, !tbaa !13); test_addarray.c:9:8
  %17:gpr = ADDI %16:gpr, 1, debug-location !33; test_addarray.c:7:16
  %18:gpr = ADDI %15:gpr, 4, debug-location !33; test_addarray.c:7:16
  %19:gpr = ADDI %14:gpr, 4, debug-location !33; test_addarray.c:7:16
  %20:gpr = ADDI %13:gpr, 4, debug-location !33; test_addarray.c:7:16
  BLTU %17:gpr, %16:gpr, %bb.4, debug-location !10; test_addarray.c:7:2
  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2

# End machine code for function add.

# Machine code for function add: IsSSA, TracksLiveness
Function Live Ins: $x10 in %21, $x11 in %22, $x12 in %23

0B	bb.0.entry:
	  successors: %bb.2(0x40000000), %bb.1(0x40000000); %bb.2(50.00%), %bb.1(50.00%)
	  liveins: $x10, $x11, $x12
16B	  %23:gpr = COPY $x12
32B	  %22:gpr = COPY $x11
48B	  %21:gpr = COPY $x10
64B	  %25:gpr = LUI 1
80B	  %26:gpr = ADDIW killed %25:gpr, -100
96B	  %27:gpr = ADD %23:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
112B	  %28:gpr = ADD %21:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
128B	  %29:gpr = ADD %22:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
144B	  %30:gpr = SLTU %23:gpr, killed %28:gpr, debug-location !10; test_addarray.c:7:2
160B	  %31:gpr = SLTU %21:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
176B	  %32:gpr = AND killed %30:gpr, killed %31:gpr, debug-location !10; test_addarray.c:7:2
192B	  %33:gpr = SLTU %23:gpr, killed %29:gpr, debug-location !10; test_addarray.c:7:2
208B	  %34:gpr = SLTU %22:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
224B	  %35:gpr = AND killed %33:gpr, killed %34:gpr, debug-location !10; test_addarray.c:7:2
240B	  %36:gpr = OR killed %32:gpr, killed %35:gpr, debug-location !10; test_addarray.c:7:2
256B	  %37:gpr = COPY $x0
272B	  %24:gpr = COPY %37:gpr
288B	  BNE killed %36:gpr, %37:gpr, %bb.2, debug-location !10; test_addarray.c:7:2
304B	  PseudoBR %bb.1, debug-location !10; test_addarray.c:7:2

320B	bb.1.vector.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

336B	  %38:gpr = ADDI $x0, 960
352B	  PseudoBR %bb.3, debug-location !10; test_addarray.c:7:2

368B	bb.2.for.body.preheader:
	; predecessors: %bb.0, %bb.3
	  successors: %bb.5(0x80000000); %bb.5(100.00%)

384B	  %0:gpr = PHI %24:gpr, %bb.0, %39:gpr, %bb.3
400B	  %1:gpr = nuw nsw ADDI %0:gpr, -999, debug-location !10; test_addarray.c:7:2
416B	  %45:gpr = SLLI %0:gpr, 2, debug-location !10; test_addarray.c:7:2
432B	  %2:gpr = ADD %23:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
448B	  %3:gpr = ADD %22:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
464B	  %4:gpr = ADD %21:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
480B	  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2

496B	bb.3.vector.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

512B	  %5:gpr = PHI %21:gpr, %bb.1, %12:gpr, %bb.3, debug-location !11; test_addarray.c:7:20
528B	  %6:gpr = PHI %22:gpr, %bb.1, %11:gpr, %bb.3, debug-location !11; test_addarray.c:7:20
544B	  %7:gpr = PHI %23:gpr, %bb.1, %10:gpr, %bb.3, debug-location !11; test_addarray.c:7:20
560B	  %8:gpr = PHI %38:gpr, %bb.1, %9:gpr, %bb.3, debug-location !11; test_addarray.c:7:20
576B	  %40:gpr = ADDI $x0, 64
592B	  %41:vrm8 = PseudoVLE32_V_M8 %5:gpr, %40:gpr, 5, debug-location !12 :: (load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17); test_addarray.c:9:10
608B	  %42:vrm8 = PseudoVLE32_V_M8 %6:gpr, %40:gpr, 5, debug-location !20 :: (load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21); test_addarray.c:9:17
624B	  %43:vrm8 = PseudoVADD_VV_M8 killed %42:vrm8, killed %41:vrm8, %40:gpr, 5, debug-location !23; test_addarray.c:9:15
640B	  PseudoVSE32_V_M8 killed %43:vrm8, %7:gpr, %40:gpr, 5, debug-location !24 :: (store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27); test_addarray.c:9:8
656B	  %9:gpr = nsw ADDI %8:gpr, -64, debug-location !11; test_addarray.c:7:20
672B	  %10:gpr = ADDI %7:gpr, 256, debug-location !11; test_addarray.c:7:20
688B	  %11:gpr = ADDI %6:gpr, 256, debug-location !11; test_addarray.c:7:20
704B	  %12:gpr = ADDI %5:gpr, 256, debug-location !11; test_addarray.c:7:20
720B	  %39:gpr = ADDI $x0, 960
736B	  %44:gpr = COPY $x0
752B	  BEQ %9:gpr, %44:gpr, %bb.2, debug-location !11; test_addarray.c:7:20
768B	  PseudoBR %bb.3, debug-location !11; test_addarray.c:7:20

784B	bb.4.for.cond.cleanup:
	; predecessors: %bb.5

800B	  PseudoRET debug-location !32; test_addarray.c:11:1

816B	bb.5.for.body:
	; predecessors: %bb.2, %bb.5
	  successors: %bb.4(0x04000000), %bb.5(0x7c000000); %bb.4(3.12%), %bb.5(96.88%)

832B	  %13:gpr = PHI %4:gpr, %bb.2, %20:gpr, %bb.5
848B	  %14:gpr = PHI %3:gpr, %bb.2, %19:gpr, %bb.5
864B	  %15:gpr = PHI %2:gpr, %bb.2, %18:gpr, %bb.5
880B	  %16:gpr = PHI %1:gpr, %bb.2, %17:gpr, %bb.5
896B	  %46:gpr = LW %13:gpr, 0, debug-location !12 :: (load (s32) from %ir.lsr.iv8, !tbaa !13); test_addarray.c:9:10
912B	  %47:gpr = LW %14:gpr, 0, debug-location !20 :: (load (s32) from %ir.lsr.iv5, !tbaa !13); test_addarray.c:9:17
928B	  %48:gpr = ADD killed %47:gpr, killed %46:gpr, debug-location !23; test_addarray.c:9:15
944B	  SW killed %48:gpr, %15:gpr, 0, debug-location !24 :: (store (s32) into %ir.lsr.iv2, !tbaa !13); test_addarray.c:9:8
960B	  %17:gpr = ADDI %16:gpr, 1, debug-location !33; test_addarray.c:7:16
976B	  %18:gpr = ADDI %15:gpr, 4, debug-location !33; test_addarray.c:7:16
992B	  %19:gpr = ADDI %14:gpr, 4, debug-location !33; test_addarray.c:7:16
1008B	  %20:gpr = ADDI %13:gpr, 4, debug-location !33; test_addarray.c:7:16
1024B	  BLTU %17:gpr, %16:gpr, %bb.4, debug-location !10; test_addarray.c:7:2
1040B	  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2

# End machine code for function add.

********** Stack Coloring **********
********** Function: add

block-frequency: add
====================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[vector.body.preheader]
 - 2: BB3[vector.body]
 - 3: BB2[for.body.preheader]
 - 4: BB5[for.body]
 - 5: BB4[for.cond.cleanup]
loop-detection
 - loop = BB5[for.body]
 - loop = BB3[vector.body]
compute-mass-in-loop: BB3[vector.body]*
 - node: BB3[vector.body]
  => [  exit  ] weight = 67108864, succ = BB2[for.body.preheader]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB3[vector.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[for.body.preheader]
compute-loop-scale: BB3[vector.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB3[vector.body]*
 - node: BB3[vector.body]
compute-mass-in-loop: BB5[for.body]*
 - node: BB5[for.body]
  => [  exit  ] weight = 67108864, succ = BB4[for.cond.cleanup]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB5[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB4[for.cond.cleanup]
compute-loop-scale: BB5[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB5[for.body]*
 - node: BB5[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1073741824, succ = BB2[for.body.preheader]
  => [ local  ] weight = 1073741824, succ = BB1[vector.body.preheader]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB1[vector.body.preheader]
  => assign 8000000000000000 (0000000000000000) to BB2[for.body.preheader]
 - node: BB1[vector.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB3[vector.body]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB3[vector.body]
 - node: BB3[vector.body]
  => [ local  ] weight = 576460752303423488, succ = BB2[for.body.preheader]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB2[for.body.preheader]
 - node: BB2[for.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB5[for.body]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB5[for.body]
 - node: BB5[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB4[for.cond.cleanup]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB4[for.cond.cleanup]
 - node: BB4[for.cond.cleanup]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB5[for.body]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB5[for.body]: 1.0 => 32.0
unwrap-loop-package: BB3[vector.body]*: mass = 7fffffffffffffff, scale = 32.0
  => combined-scale = 16.0
 - BB3[vector.body]: 1.0 => 16.0
float-to-int: min = 0.5, max = 32.0, factor = 16.0
 - BB0[entry]: float = 1.0, scaled = 16.0, int = 16
 - BB1[vector.body.preheader]: float = 0.5, scaled = 8.0, int = 8
 - BB3[vector.body]: float = 16.0, scaled = 256.0, int = 255
 - BB2[for.body.preheader]: float = 1.0, scaled = 16.0, int = 16
 - BB5[for.body]: float = 32.0, scaled = 512.0, int = 511
 - BB4[for.cond.cleanup]: float = 1.0, scaled = 16.0, int = 16
block-frequency-info: add
 - BB0[entry]: float = 1.0, int = 16
 - BB1[vector.body.preheader]: float = 0.5, int = 8
 - BB2[for.body.preheader]: float = 1.0, int = 16
 - BB3[vector.body]: float = 16.0, int = 255
 - BB4[for.cond.cleanup]: float = 1.0, int = 16
 - BB5[for.body]: float = 32.0, int = 511

******** Pre-regalloc Machine LICM: add ********
Entering %bb.3
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Hoisting %40:gpr = ADDI $x0, 64
 from %bb.3 to %bb.1
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Won't hoist cheap instr with loop PHI use: %39:gpr = ADDI $x0, 960
Can't remat / high reg-pressure: %44:gpr = COPY $x0
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Exiting %bb.3
Entering %bb.5
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate

block-frequency: add
====================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[vector.body.preheader]
 - 2: BB3[vector.body]
 - 3: BB2[for.body.preheader]
 - 4: BB5[for.body]
 - 5: BB4[for.cond.cleanup]
loop-detection
 - loop = BB5[for.body]
 - loop = BB3[vector.body]
compute-mass-in-loop: BB3[vector.body]*
 - node: BB3[vector.body]
  => [  exit  ] weight = 67108864, succ = BB2[for.body.preheader]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB3[vector.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[for.body.preheader]
compute-loop-scale: BB3[vector.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB3[vector.body]*
 - node: BB3[vector.body]
compute-mass-in-loop: BB5[for.body]*
 - node: BB5[for.body]
  => [  exit  ] weight = 67108864, succ = BB4[for.cond.cleanup]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB5[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB4[for.cond.cleanup]
compute-loop-scale: BB5[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB5[for.body]*
 - node: BB5[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1073741824, succ = BB2[for.body.preheader]
  => [ local  ] weight = 1073741824, succ = BB1[vector.body.preheader]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB1[vector.body.preheader]
  => assign 8000000000000000 (0000000000000000) to BB2[for.body.preheader]
 - node: BB1[vector.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB3[vector.body]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB3[vector.body]
 - node: BB3[vector.body]
  => [ local  ] weight = 576460752303423488, succ = BB2[for.body.preheader]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB2[for.body.preheader]
 - node: BB2[for.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB5[for.body]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB5[for.body]
 - node: BB5[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB4[for.cond.cleanup]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB4[for.cond.cleanup]
 - node: BB4[for.cond.cleanup]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB5[for.body]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB5[for.body]: 1.0 => 32.0
unwrap-loop-package: BB3[vector.body]*: mass = 7fffffffffffffff, scale = 32.0
  => combined-scale = 16.0
 - BB3[vector.body]: 1.0 => 16.0
float-to-int: min = 0.5, max = 32.0, factor = 16.0
 - BB0[entry]: float = 1.0, scaled = 16.0, int = 16
 - BB1[vector.body.preheader]: float = 0.5, scaled = 8.0, int = 8
 - BB3[vector.body]: float = 16.0, scaled = 256.0, int = 255
 - BB2[for.body.preheader]: float = 1.0, scaled = 16.0, int = 16
 - BB5[for.body]: float = 32.0, scaled = 512.0, int = 511
 - BB4[for.cond.cleanup]: float = 1.0, scaled = 16.0, int = 16
block-frequency-info: add
 - BB0[entry]: float = 1.0, int = 16
 - BB1[vector.body.preheader]: float = 0.5, int = 8
 - BB2[for.body.preheader]: float = 1.0, int = 16
 - BB3[vector.body]: float = 16.0, int = 255
 - BB4[for.cond.cleanup]: float = 1.0, int = 16
 - BB5[for.body]: float = 32.0, int = 511

Entering: entry
Entering: vector.body.preheader
Entering: vector.body
Examining: %39:gpr = ADDI $x0, 960
*** Found a common subexpression: %38:gpr = ADDI $x0, 960
Exiting: vector.body
Exiting: vector.body.preheader
Entering: for.body.preheader
Entering: for.body
Entering: for.cond.cleanup
Exiting: for.cond.cleanup
Exiting: for.body
Exiting: for.body.preheader
Exiting: entry
		Looking for trivial roots
Found a new trivial root: %bb.4
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 6, Num: 7
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.4
3: %bb.5
4: %bb.2
5: %bb.3
6: %bb.1
7: %bb.0
Found roots: %bb.4 
******** Machine Sinking ********
Sink instr %24:gpr = COPY %37:gpr
	into block bb.2.for.body.preheader:
; predecessors: %bb.0, %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)

  %0:gpr = PHI %24:gpr, %bb.0, %38:gpr, %bb.3
  %1:gpr = nuw nsw ADDI %0:gpr, -999, debug-location !10; test_addarray.c:7:2
  %45:gpr = SLLI %0:gpr, 2, debug-location !10; test_addarray.c:7:2
  %2:gpr = ADD %23:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
  %3:gpr = ADD %22:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
  %4:gpr = ADD %21:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2
Sinking along critical edge.
 *** PUNTING: Not legal or profitable to break critical edge
********** PEEPHOLE OPTIMIZER **********
********** Function: add
Encountered load fold barrier on PseudoVSE32_V_M8 killed %43:vrm8, %7:gpr, %40:gpr, 5, debug-location !24 :: (store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27); test_addarray.c:9:8
Encountered load fold barrier on SW killed %48:gpr, %15:gpr, 0, debug-location !24 :: (store (s32) into %ir.lsr.iv2, !tbaa !13); test_addarray.c:9:8
MBB: entry
MBB: vector.body.preheader
MBB: for.body.preheader
MBB: vector.body
MBB: for.cond.cleanup
MBB: for.body
Skipping Detect dead lanes pass
********** PROCESS IMPLICIT DEFS **********
********** Function: add
%38 live-out before critical edge %bb.3 -> %bb.2: %0:gpr = PHI %24:gpr, %bb.0, %38:gpr, %bb.3
Splitting critical edge: %bb.3 -- %bb.6 -- %bb.2
Removing terminator kill: BEQ %9:gpr, killed %44:gpr, %bb.2, debug-location !11; test_addarray.c:7:20
Updating terminators on %bb.3
Restored terminator kill: BNE %9:gpr, killed %44:gpr, %bb.3, debug-location !11; test_addarray.c:7:20
********** REWRITING TWO-ADDR INSTRS **********
********** Function: add
# Machine code for function add: NoPHIs, TracksLiveness, TiedOpsRewritten
Function Live Ins: $x10 in %21, $x11 in %22, $x12 in %23

0B	bb.0.entry:
	  successors: %bb.2(0x40000000), %bb.1(0x40000000); %bb.2(50.00%), %bb.1(50.00%)
	  liveins: $x10, $x11, $x12
16B	  %23:gpr = COPY killed $x12
32B	  %22:gpr = COPY killed $x11
48B	  %21:gpr = COPY killed $x10
64B	  %25:gpr = LUI 1
80B	  %26:gpr = ADDIW killed %25:gpr, -100
96B	  %27:gpr = ADD %23:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
112B	  %28:gpr = ADD %21:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
128B	  %29:gpr = ADD %22:gpr, killed %26:gpr, debug-location !10; test_addarray.c:7:2
144B	  %30:gpr = SLTU %23:gpr, killed %28:gpr, debug-location !10; test_addarray.c:7:2
160B	  %31:gpr = SLTU %21:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
176B	  %32:gpr = AND killed %30:gpr, killed %31:gpr, debug-location !10; test_addarray.c:7:2
192B	  %33:gpr = SLTU %23:gpr, killed %29:gpr, debug-location !10; test_addarray.c:7:2
208B	  %34:gpr = SLTU %22:gpr, killed %27:gpr, debug-location !10; test_addarray.c:7:2
224B	  %35:gpr = AND killed %33:gpr, killed %34:gpr, debug-location !10; test_addarray.c:7:2
240B	  %36:gpr = OR killed %32:gpr, killed %35:gpr, debug-location !10; test_addarray.c:7:2
256B	  %37:gpr = COPY $x0
272B	  %24:gpr = COPY %37:gpr
288B	  %49:gpr = COPY killed %24:gpr
304B	  BNE killed %36:gpr, killed %37:gpr, %bb.2, debug-location !10; test_addarray.c:7:2
320B	  PseudoBR %bb.1, debug-location !10; test_addarray.c:7:2

336B	bb.1.vector.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

352B	  %38:gpr = ADDI $x0, 960
368B	  %40:gpr = ADDI $x0, 64
384B	  %50:gpr = COPY %21:gpr
400B	  %51:gpr = COPY %22:gpr
416B	  %52:gpr = COPY %23:gpr
432B	  %53:gpr = COPY %38:gpr
448B	  PseudoBR %bb.3, debug-location !10; test_addarray.c:7:2

464B	bb.2.for.body.preheader:
	; predecessors: %bb.0, %bb.6
	  successors: %bb.5(0x80000000); %bb.5(100.00%)

480B	  %0:gpr = COPY killed %49:gpr
496B	  %1:gpr = nuw nsw ADDI %0:gpr, -999, debug-location !10; test_addarray.c:7:2
512B	  %45:gpr = SLLI killed %0:gpr, 2, debug-location !10; test_addarray.c:7:2
528B	  %2:gpr = ADD killed %23:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
544B	  %3:gpr = ADD killed %22:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
560B	  %4:gpr = ADD killed %21:gpr, killed %45:gpr, debug-location !10; test_addarray.c:7:2
576B	  %54:gpr = COPY killed %4:gpr
592B	  %55:gpr = COPY killed %3:gpr
608B	  %56:gpr = COPY killed %2:gpr
624B	  %57:gpr = COPY killed %1:gpr
640B	  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2

656B	bb.3.vector.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.6(0x04000000), %bb.3(0x7c000000); %bb.6(3.12%), %bb.3(96.88%)

672B	  %8:gpr = COPY killed %53:gpr, debug-location !11; test_addarray.c:7:20
688B	  %7:gpr = COPY killed %52:gpr, debug-location !11; test_addarray.c:7:20
704B	  %6:gpr = COPY killed %51:gpr, debug-location !11; test_addarray.c:7:20
720B	  %5:gpr = COPY killed %50:gpr, debug-location !11; test_addarray.c:7:20
736B	  dead $x0 = PseudoVSETVLI %40:gpr, 83, implicit-def $vl, implicit-def $vtype, debug-location !12; test_addarray.c:9:10
752B	  %41:vrm8 = PseudoVLE32_V_M8 %5:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !12 :: (load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17); test_addarray.c:9:10
768B	  %42:vrm8 = PseudoVLE32_V_M8 %6:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !20 :: (load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21); test_addarray.c:9:17
784B	  %43:vrm8 = PseudoVADD_VV_M8 killed %42:vrm8, killed %41:vrm8, $noreg, 5, implicit $vl, implicit $vtype, debug-location !23; test_addarray.c:9:15
800B	  PseudoVSE32_V_M8 killed %43:vrm8, %7:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !24 :: (store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27); test_addarray.c:9:8
816B	  %9:gpr = nsw ADDI killed %8:gpr, -64, debug-location !11; test_addarray.c:7:20
832B	  %10:gpr = ADDI killed %7:gpr, 256, debug-location !11; test_addarray.c:7:20
848B	  %11:gpr = ADDI killed %6:gpr, 256, debug-location !11; test_addarray.c:7:20
864B	  %12:gpr = ADDI killed %5:gpr, 256, debug-location !11; test_addarray.c:7:20
880B	  %44:gpr = COPY $x0
896B	  %50:gpr = COPY killed %12:gpr
912B	  %51:gpr = COPY killed %11:gpr
928B	  %52:gpr = COPY killed %10:gpr
944B	  %53:gpr = COPY %9:gpr
960B	  BNE killed %9:gpr, killed %44:gpr, %bb.3, debug-location !11; test_addarray.c:7:20

976B	bb.6:
	; predecessors: %bb.3
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

992B	  %49:gpr = COPY killed %38:gpr
1008B	  PseudoBR %bb.2

1024B	bb.4.for.cond.cleanup:
	; predecessors: %bb.5

1040B	  PseudoRET debug-location !32; test_addarray.c:11:1

1056B	bb.5.for.body:
	; predecessors: %bb.2, %bb.5
	  successors: %bb.4(0x04000000), %bb.5(0x7c000000); %bb.4(3.12%), %bb.5(96.88%)

1072B	  %16:gpr = COPY killed %57:gpr
1088B	  %15:gpr = COPY killed %56:gpr
1104B	  %14:gpr = COPY killed %55:gpr
1120B	  %13:gpr = COPY killed %54:gpr
1136B	  %46:gpr = LW %13:gpr, 0, debug-location !12 :: (load (s32) from %ir.lsr.iv8, !tbaa !13); test_addarray.c:9:10
1152B	  %47:gpr = LW %14:gpr, 0, debug-location !20 :: (load (s32) from %ir.lsr.iv5, !tbaa !13); test_addarray.c:9:17
1168B	  %48:gpr = ADD killed %47:gpr, killed %46:gpr, debug-location !23; test_addarray.c:9:15
1184B	  SW killed %48:gpr, %15:gpr, 0, debug-location !24 :: (store (s32) into %ir.lsr.iv2, !tbaa !13); test_addarray.c:9:8
1200B	  %17:gpr = ADDI %16:gpr, 1, debug-location !33; test_addarray.c:7:16
1216B	  %18:gpr = ADDI killed %15:gpr, 4, debug-location !33; test_addarray.c:7:16
1232B	  %19:gpr = ADDI killed %14:gpr, 4, debug-location !33; test_addarray.c:7:16
1248B	  %20:gpr = ADDI killed %13:gpr, 4, debug-location !33; test_addarray.c:7:16
1264B	  %54:gpr = COPY killed %20:gpr
1280B	  %55:gpr = COPY killed %19:gpr
1296B	  %56:gpr = COPY killed %18:gpr
1312B	  %57:gpr = COPY %17:gpr
1328B	  BLTU killed %17:gpr, killed %16:gpr, %bb.4, debug-location !10; test_addarray.c:7:2
1344B	  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2

# End machine code for function add.

Computing live-in reg-units in ABI blocks.
0B	%bb.0 X10#0 X11#0 X12#0
Created 3 new intervals.
********** INTERVALS **********
X10 [0B,48r:0)  0@0B-phi
X11 [0B,32r:0)  0@0B-phi
X12 [0B,16r:0)  0@0B-phi
%0 [480r,512r:0)  0@480r weight:0.000000e+00
%1 [496r,624r:0)  0@496r weight:0.000000e+00
%2 [528r,608r:0)  0@528r weight:0.000000e+00
%3 [544r,592r:0)  0@544r weight:0.000000e+00
%4 [560r,576r:0)  0@560r weight:0.000000e+00
%5 [720r,864r:0)  0@720r weight:0.000000e+00
%6 [704r,848r:0)  0@704r weight:0.000000e+00
%7 [688r,832r:0)  0@688r weight:0.000000e+00
%8 [672r,816r:0)  0@672r weight:0.000000e+00
%9 [816r,960r:0)  0@816r weight:0.000000e+00
%10 [832r,928r:0)  0@832r weight:0.000000e+00
%11 [848r,912r:0)  0@848r weight:0.000000e+00
%12 [864r,896r:0)  0@864r weight:0.000000e+00
%13 [1120r,1248r:0)  0@1120r weight:0.000000e+00
%14 [1104r,1232r:0)  0@1104r weight:0.000000e+00
%15 [1088r,1216r:0)  0@1088r weight:0.000000e+00
%16 [1072r,1328r:0)  0@1072r weight:0.000000e+00
%17 [1200r,1328r:0)  0@1200r weight:0.000000e+00
%18 [1216r,1296r:0)  0@1216r weight:0.000000e+00
%19 [1232r,1280r:0)  0@1232r weight:0.000000e+00
%20 [1248r,1264r:0)  0@1248r weight:0.000000e+00
%21 [48r,560r:0)[656B,1024B:0)  0@48r weight:0.000000e+00
%22 [32r,544r:0)[656B,1024B:0)  0@32r weight:0.000000e+00
%23 [16r,528r:0)[656B,1024B:0)  0@16r weight:0.000000e+00
%24 [272r,288r:0)  0@272r weight:0.000000e+00
%25 [64r,80r:0)  0@64r weight:0.000000e+00
%26 [80r,128r:0)  0@80r weight:0.000000e+00
%27 [96r,208r:0)  0@96r weight:0.000000e+00
%28 [112r,144r:0)  0@112r weight:0.000000e+00
%29 [128r,192r:0)  0@128r weight:0.000000e+00
%30 [144r,176r:0)  0@144r weight:0.000000e+00
%31 [160r,176r:0)  0@160r weight:0.000000e+00
%32 [176r,240r:0)  0@176r weight:0.000000e+00
%33 [192r,224r:0)  0@192r weight:0.000000e+00
%34 [208r,224r:0)  0@208r weight:0.000000e+00
%35 [224r,240r:0)  0@224r weight:0.000000e+00
%36 [240r,304r:0)  0@240r weight:0.000000e+00
%37 [256r,304r:0)  0@256r weight:0.000000e+00
%38 [352r,464B:0)[656B,992r:0)  0@352r weight:0.000000e+00
%40 [368r,464B:0)[656B,976B:0)  0@368r weight:0.000000e+00
%41 [752r,784r:0)  0@752r weight:0.000000e+00
%42 [768r,784r:0)  0@768r weight:0.000000e+00
%43 [784r,800r:0)  0@784r weight:0.000000e+00
%44 [880r,960r:0)  0@880r weight:0.000000e+00
%45 [512r,560r:0)  0@512r weight:0.000000e+00
%46 [1136r,1168r:0)  0@1136r weight:0.000000e+00
%47 [1152r,1168r:0)  0@1152r weight:0.000000e+00
%48 [1168r,1184r:0)  0@1168r weight:0.000000e+00
%49 [288r,336B:0)[464B,480r:2)[992r,1024B:1)  0@288r 1@992r 2@464B-phi weight:0.000000e+00
%50 [384r,464B:0)[656B,720r:2)[896r,976B:1)  0@384r 1@896r 2@656B-phi weight:0.000000e+00
%51 [400r,464B:0)[656B,704r:2)[912r,976B:1)  0@400r 1@912r 2@656B-phi weight:0.000000e+00
%52 [416r,464B:0)[656B,688r:2)[928r,976B:1)  0@416r 1@928r 2@656B-phi weight:0.000000e+00
%53 [432r,464B:0)[656B,672r:2)[944r,976B:1)  0@432r 1@944r 2@656B-phi weight:0.000000e+00
%54 [576r,656B:0)[1056B,1120r:2)[1264r,1360B:1)  0@576r 1@1264r 2@1056B-phi weight:0.000000e+00
%55 [592r,656B:0)[1056B,1104r:2)[1280r,1360B:1)  0@592r 1@1280r 2@1056B-phi weight:0.000000e+00
%56 [608r,656B:0)[1056B,1088r:2)[1296r,1360B:1)  0@608r 1@1296r 2@1056B-phi weight:0.000000e+00
%57 [624r,656B:0)[1056B,1072r:2)[1312r,1360B:1)  0@624r 1@1312r 2@1056B-phi weight:0.000000e+00
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function add: NoPHIs, TracksLiveness, TiedOpsRewritten
Function Live Ins: $x10 in %21, $x11 in %22, $x12 in %23

0B	bb.0.entry:
	  successors: %bb.2(0x40000000), %bb.1(0x40000000); %bb.2(50.00%), %bb.1(50.00%)
	  liveins: $x10, $x11, $x12
16B	  %23:gpr = COPY $x12
32B	  %22:gpr = COPY $x11
48B	  %21:gpr = COPY $x10
64B	  %25:gpr = LUI 1
80B	  %26:gpr = ADDIW %25:gpr, -100
96B	  %27:gpr = ADD %23:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
112B	  %28:gpr = ADD %21:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
128B	  %29:gpr = ADD %22:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
144B	  %30:gpr = SLTU %23:gpr, %28:gpr, debug-location !10; test_addarray.c:7:2
160B	  %31:gpr = SLTU %21:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
176B	  %32:gpr = AND %30:gpr, %31:gpr, debug-location !10; test_addarray.c:7:2
192B	  %33:gpr = SLTU %23:gpr, %29:gpr, debug-location !10; test_addarray.c:7:2
208B	  %34:gpr = SLTU %22:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
224B	  %35:gpr = AND %33:gpr, %34:gpr, debug-location !10; test_addarray.c:7:2
240B	  %36:gpr = OR %32:gpr, %35:gpr, debug-location !10; test_addarray.c:7:2
256B	  %37:gpr = COPY $x0
272B	  %24:gpr = COPY %37:gpr
288B	  %49:gpr = COPY %24:gpr
304B	  BNE %36:gpr, %37:gpr, %bb.2, debug-location !10; test_addarray.c:7:2
320B	  PseudoBR %bb.1, debug-location !10; test_addarray.c:7:2

336B	bb.1.vector.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

352B	  %38:gpr = ADDI $x0, 960
368B	  %40:gpr = ADDI $x0, 64
384B	  %50:gpr = COPY %21:gpr
400B	  %51:gpr = COPY %22:gpr
416B	  %52:gpr = COPY %23:gpr
432B	  %53:gpr = COPY %38:gpr
448B	  PseudoBR %bb.3, debug-location !10; test_addarray.c:7:2

464B	bb.2.for.body.preheader:
	; predecessors: %bb.0, %bb.6
	  successors: %bb.5(0x80000000); %bb.5(100.00%)

480B	  %0:gpr = COPY %49:gpr
496B	  %1:gpr = nuw nsw ADDI %0:gpr, -999, debug-location !10; test_addarray.c:7:2
512B	  %45:gpr = SLLI %0:gpr, 2, debug-location !10; test_addarray.c:7:2
528B	  %2:gpr = ADD %23:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
544B	  %3:gpr = ADD %22:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
560B	  %4:gpr = ADD %21:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
576B	  %54:gpr = COPY %4:gpr
592B	  %55:gpr = COPY %3:gpr
608B	  %56:gpr = COPY %2:gpr
624B	  %57:gpr = COPY %1:gpr
640B	  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2

656B	bb.3.vector.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.6(0x04000000), %bb.3(0x7c000000); %bb.6(3.12%), %bb.3(96.88%)

672B	  %8:gpr = COPY %53:gpr, debug-location !11; test_addarray.c:7:20
688B	  %7:gpr = COPY %52:gpr, debug-location !11; test_addarray.c:7:20
704B	  %6:gpr = COPY %51:gpr, debug-location !11; test_addarray.c:7:20
720B	  %5:gpr = COPY %50:gpr, debug-location !11; test_addarray.c:7:20
736B	  dead $x0 = PseudoVSETVLI %40:gpr, 83, implicit-def $vl, implicit-def $vtype, debug-location !12; test_addarray.c:9:10
752B	  %41:vrm8 = PseudoVLE32_V_M8 %5:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !12 :: (load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17); test_addarray.c:9:10
768B	  %42:vrm8 = PseudoVLE32_V_M8 %6:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !20 :: (load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21); test_addarray.c:9:17
784B	  %43:vrm8 = PseudoVADD_VV_M8 %42:vrm8, %41:vrm8, $noreg, 5, implicit $vl, implicit $vtype, debug-location !23; test_addarray.c:9:15
800B	  PseudoVSE32_V_M8 %43:vrm8, %7:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !24 :: (store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27); test_addarray.c:9:8
816B	  %9:gpr = nsw ADDI %8:gpr, -64, debug-location !11; test_addarray.c:7:20
832B	  %10:gpr = ADDI %7:gpr, 256, debug-location !11; test_addarray.c:7:20
848B	  %11:gpr = ADDI %6:gpr, 256, debug-location !11; test_addarray.c:7:20
864B	  %12:gpr = ADDI %5:gpr, 256, debug-location !11; test_addarray.c:7:20
880B	  %44:gpr = COPY $x0
896B	  %50:gpr = COPY %12:gpr
912B	  %51:gpr = COPY %11:gpr
928B	  %52:gpr = COPY %10:gpr
944B	  %53:gpr = COPY %9:gpr
960B	  BNE %9:gpr, %44:gpr, %bb.3, debug-location !11; test_addarray.c:7:20

976B	bb.6:
	; predecessors: %bb.3
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

992B	  %49:gpr = COPY %38:gpr
1008B	  PseudoBR %bb.2

1024B	bb.4.for.cond.cleanup:
	; predecessors: %bb.5

1040B	  PseudoRET debug-location !32; test_addarray.c:11:1

1056B	bb.5.for.body:
	; predecessors: %bb.2, %bb.5
	  successors: %bb.4(0x04000000), %bb.5(0x7c000000); %bb.4(3.12%), %bb.5(96.88%)

1072B	  %16:gpr = COPY %57:gpr
1088B	  %15:gpr = COPY %56:gpr
1104B	  %14:gpr = COPY %55:gpr
1120B	  %13:gpr = COPY %54:gpr
1136B	  %46:gpr = LW %13:gpr, 0, debug-location !12 :: (load (s32) from %ir.lsr.iv8, !tbaa !13); test_addarray.c:9:10
1152B	  %47:gpr = LW %14:gpr, 0, debug-location !20 :: (load (s32) from %ir.lsr.iv5, !tbaa !13); test_addarray.c:9:17
1168B	  %48:gpr = ADD %47:gpr, %46:gpr, debug-location !23; test_addarray.c:9:15
1184B	  SW %48:gpr, %15:gpr, 0, debug-location !24 :: (store (s32) into %ir.lsr.iv2, !tbaa !13); test_addarray.c:9:8
1200B	  %17:gpr = ADDI %16:gpr, 1, debug-location !33; test_addarray.c:7:16
1216B	  %18:gpr = ADDI %15:gpr, 4, debug-location !33; test_addarray.c:7:16
1232B	  %19:gpr = ADDI %14:gpr, 4, debug-location !33; test_addarray.c:7:16
1248B	  %20:gpr = ADDI %13:gpr, 4, debug-location !33; test_addarray.c:7:16
1264B	  %54:gpr = COPY %20:gpr
1280B	  %55:gpr = COPY %19:gpr
1296B	  %56:gpr = COPY %18:gpr
1312B	  %57:gpr = COPY %17:gpr
1328B	  BLTU %17:gpr, %16:gpr, %bb.4, debug-location !10; test_addarray.c:7:2
1344B	  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2

# End machine code for function add.

********** SIMPLE REGISTER COALESCING **********
********** Function: add
********** JOINING INTERVALS ***********
vector.body:
880B	%44:gpr = COPY $x0
	Considering merging %44 with $x0
		RHS = %44 [880r,960r:0)  0@880r weight:0.000000e+00
		updated: 960B	BNE %9:gpr, $x0, %bb.3, debug-location !11; test_addarray.c:7:20
	Success: %44 -> $x0
	Result = $x0
for.body:
672B	%8:gpr = COPY %53:gpr, debug-location !11; test_addarray.c:7:20
	Considering merging to GPR with %8 in %53
		RHS = %8 [672r,816r:0)  0@672r weight:0.000000e+00
		LHS = %53 [432r,464B:0)[656B,672r:2)[944r,976B:1)  0@432r 1@944r 2@656B-phi weight:0.000000e+00
		merge %8:0@672r into %53:2@656B --> @656B
		erased:	672r	%8:gpr = COPY %53:gpr, debug-location !11; test_addarray.c:7:20
AllocationOrder(GPR) = [ $x10 $x11 $x12 $x13 $x14 $x15 $x16 $x17 $x5 $x6 $x7 $x28 $x29 $x30 $x31 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $x1 ]
		updated: 816B	%9:gpr = nsw ADDI %53:gpr, -64, debug-location !11; test_addarray.c:7:20
	Success: %8 -> %53
	Result = %53 [432r,464B:0)[656B,816r:2)[944r,976B:1)  0@432r 1@944r 2@656B-phi weight:0.000000e+00
688B	%7:gpr = COPY %52:gpr, debug-location !11; test_addarray.c:7:20
	Considering merging to GPR with %7 in %52
		RHS = %7 [688r,832r:0)  0@688r weight:0.000000e+00
		LHS = %52 [416r,464B:0)[656B,688r:2)[928r,976B:1)  0@416r 1@928r 2@656B-phi weight:0.000000e+00
		merge %7:0@688r into %52:2@656B --> @656B
		erased:	688r	%7:gpr = COPY %52:gpr, debug-location !11; test_addarray.c:7:20
		updated: 800B	PseudoVSE32_V_M8 %43:vrm8, %52:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !24 :: (store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27); test_addarray.c:9:8
		updated: 832B	%10:gpr = ADDI %52:gpr, 256, debug-location !11; test_addarray.c:7:20
	Success: %7 -> %52
	Result = %52 [416r,464B:0)[656B,832r:2)[928r,976B:1)  0@416r 1@928r 2@656B-phi weight:0.000000e+00
704B	%6:gpr = COPY %51:gpr, debug-location !11; test_addarray.c:7:20
	Considering merging to GPR with %6 in %51
		RHS = %6 [704r,848r:0)  0@704r weight:0.000000e+00
		LHS = %51 [400r,464B:0)[656B,704r:2)[912r,976B:1)  0@400r 1@912r 2@656B-phi weight:0.000000e+00
		merge %6:0@704r into %51:2@656B --> @656B
		erased:	704r	%6:gpr = COPY %51:gpr, debug-location !11; test_addarray.c:7:20
		updated: 768B	%42:vrm8 = PseudoVLE32_V_M8 %51:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !20 :: (load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21); test_addarray.c:9:17
		updated: 848B	%11:gpr = ADDI %51:gpr, 256, debug-location !11; test_addarray.c:7:20
	Success: %6 -> %51
	Result = %51 [400r,464B:0)[656B,848r:2)[912r,976B:1)  0@400r 1@912r 2@656B-phi weight:0.000000e+00
720B	%5:gpr = COPY %50:gpr, debug-location !11; test_addarray.c:7:20
	Considering merging to GPR with %5 in %50
		RHS = %5 [720r,864r:0)  0@720r weight:0.000000e+00
		LHS = %50 [384r,464B:0)[656B,720r:2)[896r,976B:1)  0@384r 1@896r 2@656B-phi weight:0.000000e+00
		merge %5:0@720r into %50:2@656B --> @656B
		erased:	720r	%5:gpr = COPY %50:gpr, debug-location !11; test_addarray.c:7:20
		updated: 752B	%41:vrm8 = PseudoVLE32_V_M8 %50:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !12 :: (load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17); test_addarray.c:9:10
		updated: 864B	%12:gpr = ADDI %50:gpr, 256, debug-location !11; test_addarray.c:7:20
	Success: %5 -> %50
	Result = %50 [384r,464B:0)[656B,864r:2)[896r,976B:1)  0@384r 1@896r 2@656B-phi weight:0.000000e+00
896B	%50:gpr = COPY %12:gpr
	Considering merging to GPR with %12 in %50
		RHS = %12 [864r,896r:0)  0@864r weight:0.000000e+00
		LHS = %50 [384r,464B:0)[656B,864r:2)[896r,976B:1)  0@384r 1@896r 2@656B-phi weight:0.000000e+00
		merge %50:1@896r into %12:0@864r --> @864r
		erased:	896r	%50:gpr = COPY %12:gpr
		updated: 864B	%50:gpr = ADDI %50:gpr, 256, debug-location !11; test_addarray.c:7:20
	Success: %12 -> %50
	Result = %50 [384r,464B:0)[656B,864r:1)[864r,976B:2)  0@384r 1@656B-phi 2@864r weight:0.000000e+00
912B	%51:gpr = COPY %11:gpr
	Considering merging to GPR with %11 in %51
		RHS = %11 [848r,912r:0)  0@848r weight:0.000000e+00
		LHS = %51 [400r,464B:0)[656B,848r:2)[912r,976B:1)  0@400r 1@912r 2@656B-phi weight:0.000000e+00
		merge %51:1@912r into %11:0@848r --> @848r
		erased:	912r	%51:gpr = COPY %11:gpr
		updated: 848B	%51:gpr = ADDI %51:gpr, 256, debug-location !11; test_addarray.c:7:20
	Success: %11 -> %51
	Result = %51 [400r,464B:0)[656B,848r:1)[848r,976B:2)  0@400r 1@656B-phi 2@848r weight:0.000000e+00
928B	%52:gpr = COPY %10:gpr
	Considering merging to GPR with %10 in %52
		RHS = %10 [832r,928r:0)  0@832r weight:0.000000e+00
		LHS = %52 [416r,464B:0)[656B,832r:2)[928r,976B:1)  0@416r 1@928r 2@656B-phi weight:0.000000e+00
		merge %52:1@928r into %10:0@832r --> @832r
		erased:	928r	%52:gpr = COPY %10:gpr
		updated: 832B	%52:gpr = ADDI %52:gpr, 256, debug-location !11; test_addarray.c:7:20
	Success: %10 -> %52
	Result = %52 [416r,464B:0)[656B,832r:1)[832r,976B:2)  0@416r 1@656B-phi 2@832r weight:0.000000e+00
944B	%53:gpr = COPY %9:gpr
	Considering merging to GPR with %9 in %53
		RHS = %9 [816r,960r:0)  0@816r weight:0.000000e+00
		LHS = %53 [432r,464B:0)[656B,816r:2)[944r,976B:1)  0@432r 1@944r 2@656B-phi weight:0.000000e+00
		merge %53:1@944r into %9:0@816r --> @816r
		erased:	944r	%53:gpr = COPY %9:gpr
		updated: 816B	%53:gpr = nsw ADDI %53:gpr, -64, debug-location !11; test_addarray.c:7:20
		updated: 960B	BNE %53:gpr, $x0, %bb.3, debug-location !11; test_addarray.c:7:20
	Success: %9 -> %53
	Result = %53 [432r,464B:0)[656B,816r:1)[816r,976B:2)  0@432r 1@656B-phi 2@816r weight:0.000000e+00
1072B	%16:gpr = COPY %57:gpr
	Considering merging to GPR with %16 in %57
		RHS = %16 [1072r,1328r:0)  0@1072r weight:0.000000e+00
		LHS = %57 [624r,656B:0)[1056B,1072r:2)[1312r,1360B:1)  0@624r 1@1312r 2@1056B-phi weight:0.000000e+00
		merge %16:0@1072r into %57:2@1056B --> @1056B
		interference at %57:1@1312r
	Interference!
1088B	%15:gpr = COPY %56:gpr
	Considering merging to GPR with %15 in %56
		RHS = %15 [1088r,1216r:0)  0@1088r weight:0.000000e+00
		LHS = %56 [608r,656B:0)[1056B,1088r:2)[1296r,1360B:1)  0@608r 1@1296r 2@1056B-phi weight:0.000000e+00
		merge %15:0@1088r into %56:2@1056B --> @1056B
		erased:	1088r	%15:gpr = COPY %56:gpr
		updated: 1184B	SW %48:gpr, %56:gpr, 0, debug-location !24 :: (store (s32) into %ir.lsr.iv2, !tbaa !13); test_addarray.c:9:8
		updated: 1216B	%18:gpr = ADDI %56:gpr, 4, debug-location !33; test_addarray.c:7:16
	Success: %15 -> %56
	Result = %56 [608r,656B:0)[1056B,1216r:2)[1296r,1360B:1)  0@608r 1@1296r 2@1056B-phi weight:0.000000e+00
1104B	%14:gpr = COPY %55:gpr
	Considering merging to GPR with %14 in %55
		RHS = %14 [1104r,1232r:0)  0@1104r weight:0.000000e+00
		LHS = %55 [592r,656B:0)[1056B,1104r:2)[1280r,1360B:1)  0@592r 1@1280r 2@1056B-phi weight:0.000000e+00
		merge %14:0@1104r into %55:2@1056B --> @1056B
		erased:	1104r	%14:gpr = COPY %55:gpr
		updated: 1152B	%47:gpr = LW %55:gpr, 0, debug-location !20 :: (load (s32) from %ir.lsr.iv5, !tbaa !13); test_addarray.c:9:17
		updated: 1232B	%19:gpr = ADDI %55:gpr, 4, debug-location !33; test_addarray.c:7:16
	Success: %14 -> %55
	Result = %55 [592r,656B:0)[1056B,1232r:2)[1280r,1360B:1)  0@592r 1@1280r 2@1056B-phi weight:0.000000e+00
1120B	%13:gpr = COPY %54:gpr
	Considering merging to GPR with %13 in %54
		RHS = %13 [1120r,1248r:0)  0@1120r weight:0.000000e+00
		LHS = %54 [576r,656B:0)[1056B,1120r:2)[1264r,1360B:1)  0@576r 1@1264r 2@1056B-phi weight:0.000000e+00
		merge %13:0@1120r into %54:2@1056B --> @1056B
		erased:	1120r	%13:gpr = COPY %54:gpr
		updated: 1136B	%46:gpr = LW %54:gpr, 0, debug-location !12 :: (load (s32) from %ir.lsr.iv8, !tbaa !13); test_addarray.c:9:10
		updated: 1248B	%20:gpr = ADDI %54:gpr, 4, debug-location !33; test_addarray.c:7:16
	Success: %13 -> %54
	Result = %54 [576r,656B:0)[1056B,1248r:2)[1264r,1360B:1)  0@576r 1@1264r 2@1056B-phi weight:0.000000e+00
1264B	%54:gpr = COPY %20:gpr
	Considering merging to GPR with %20 in %54
		RHS = %20 [1248r,1264r:0)  0@1248r weight:0.000000e+00
		LHS = %54 [576r,656B:0)[1056B,1248r:2)[1264r,1360B:1)  0@576r 1@1264r 2@1056B-phi weight:0.000000e+00
		merge %54:1@1264r into %20:0@1248r --> @1248r
		erased:	1264r	%54:gpr = COPY %20:gpr
		updated: 1248B	%54:gpr = ADDI %54:gpr, 4, debug-location !33; test_addarray.c:7:16
	Success: %20 -> %54
	Result = %54 [576r,656B:0)[1056B,1248r:1)[1248r,1360B:2)  0@576r 1@1056B-phi 2@1248r weight:0.000000e+00
1280B	%55:gpr = COPY %19:gpr
	Considering merging to GPR with %19 in %55
		RHS = %19 [1232r,1280r:0)  0@1232r weight:0.000000e+00
		LHS = %55 [592r,656B:0)[1056B,1232r:2)[1280r,1360B:1)  0@592r 1@1280r 2@1056B-phi weight:0.000000e+00
		merge %55:1@1280r into %19:0@1232r --> @1232r
		erased:	1280r	%55:gpr = COPY %19:gpr
		updated: 1232B	%55:gpr = ADDI %55:gpr, 4, debug-location !33; test_addarray.c:7:16
	Success: %19 -> %55
	Result = %55 [592r,656B:0)[1056B,1232r:1)[1232r,1360B:2)  0@592r 1@1056B-phi 2@1232r weight:0.000000e+00
1296B	%56:gpr = COPY %18:gpr
	Considering merging to GPR with %18 in %56
		RHS = %18 [1216r,1296r:0)  0@1216r weight:0.000000e+00
		LHS = %56 [608r,656B:0)[1056B,1216r:2)[1296r,1360B:1)  0@608r 1@1296r 2@1056B-phi weight:0.000000e+00
		merge %56:1@1296r into %18:0@1216r --> @1216r
		erased:	1296r	%56:gpr = COPY %18:gpr
		updated: 1216B	%56:gpr = ADDI %56:gpr, 4, debug-location !33; test_addarray.c:7:16
	Success: %18 -> %56
	Result = %56 [608r,656B:0)[1056B,1216r:1)[1216r,1360B:2)  0@608r 1@1056B-phi 2@1216r weight:0.000000e+00
1312B	%57:gpr = COPY %17:gpr
	Considering merging to GPR with %17 in %57
		RHS = %17 [1200r,1328r:0)  0@1200r weight:0.000000e+00
		LHS = %57 [624r,656B:0)[1056B,1072r:2)[1312r,1360B:1)  0@624r 1@1312r 2@1056B-phi weight:0.000000e+00
		merge %57:1@1312r into %17:0@1200r --> @1200r
		erased:	1312r	%57:gpr = COPY %17:gpr
		updated: 1200B	%57:gpr = ADDI %16:gpr, 1, debug-location !33; test_addarray.c:7:16
		updated: 1328B	BLTU %57:gpr, %16:gpr, %bb.4, debug-location !10; test_addarray.c:7:2
	Success: %17 -> %57
	Result = %57 [624r,656B:0)[1056B,1072r:2)[1200r,1360B:1)  0@624r 1@1200r 2@1056B-phi weight:0.000000e+00
for.body.preheader:
entry:
16B	%23:gpr = COPY $x12
	Considering merging %23 with $x12
	Can only merge into reserved registers.
32B	%22:gpr = COPY $x11
	Considering merging %22 with $x11
	Can only merge into reserved registers.
48B	%21:gpr = COPY $x10
	Considering merging %21 with $x10
	Can only merge into reserved registers.
256B	%37:gpr = COPY $x0
	Considering merging %37 with $x0
		RHS = %37 [256r,304r:0)  0@256r weight:0.000000e+00
		updated: 272B	%24:gpr = COPY $x0
		updated: 304B	BNE %36:gpr, $x0, %bb.2, debug-location !10; test_addarray.c:7:2
	Success: %37 -> $x0
	Result = $x0
vector.body.preheader:
384B	%50:gpr = COPY %21:gpr
	Considering merging to GPR with %21 in %50
		RHS = %21 [48r,560r:0)[656B,1024B:0)  0@48r weight:0.000000e+00
		LHS = %50 [384r,464B:0)[656B,864r:1)[864r,976B:2)  0@384r 1@656B-phi 2@864r weight:0.000000e+00
		merge %50:0@384r into %21:0@48r --> @48r
		interference at %50:2@864r
	Interference!
400B	%51:gpr = COPY %22:gpr
	Considering merging to GPR with %22 in %51
		RHS = %22 [32r,544r:0)[656B,1024B:0)  0@32r weight:0.000000e+00
		LHS = %51 [400r,464B:0)[656B,848r:1)[848r,976B:2)  0@400r 1@656B-phi 2@848r weight:0.000000e+00
		merge %51:0@400r into %22:0@32r --> @32r
		interference at %51:2@848r
	Interference!
416B	%52:gpr = COPY %23:gpr
	Considering merging to GPR with %23 in %52
		RHS = %23 [16r,528r:0)[656B,1024B:0)  0@16r weight:0.000000e+00
		LHS = %52 [416r,464B:0)[656B,832r:1)[832r,976B:2)  0@416r 1@656B-phi 2@832r weight:0.000000e+00
		merge %52:0@416r into %23:0@16r --> @16r
		interference at %52:2@832r
	Interference!
432B	%53:gpr = COPY %38:gpr
	Considering merging to GPR with %38 in %53
		RHS = %38 [352r,464B:0)[656B,992r:0)  0@352r weight:0.000000e+00
		LHS = %53 [432r,464B:0)[656B,816r:1)[816r,976B:2)  0@432r 1@656B-phi 2@816r weight:0.000000e+00
		merge %53:0@432r into %38:0@352r --> @352r
		interference at %53:2@816r
		updated: 432B	%53:gpr = ADDI $x0, 960
		updated: 816B	%53:gpr = nsw ADDI %53:gpr, -64, debug-location !11; test_addarray.c:7:20
		updated: 960B	BNE %53:gpr, $x0, %bb.3, debug-location !11; test_addarray.c:7:20
Remat: %53:gpr = ADDI $x0, 960
Shrink: %38 [352r,464B:0)[656B,992r:0)  0@352r weight:0.000000e+00
 live-in at 976B
 live-in at 656B
Shrunk: %38 [352r,464B:0)[656B,992r:0)  0@352r weight:0.000000e+00
:
992B	%49:gpr = COPY %38:gpr
	Considering merging to GPR with %38 in %49
		RHS = %38 [352r,464B:0)[656B,992r:0)  0@352r weight:0.000000e+00
		LHS = %49 [288r,336B:0)[464B,480r:2)[992r,1024B:1)  0@288r 1@992r 2@464B-phi weight:0.000000e+00
		merge %49:1@992r into %38:0@352r --> @352r
		erased:	992r	%49:gpr = COPY %38:gpr
		updated: 352B	%49:gpr = ADDI $x0, 960
	Success: %38 -> %49
	Result = %49 [288r,336B:0)[352r,464B:1)[464B,480r:2)[656B,1024B:1)  0@288r 1@352r 2@464B-phi weight:0.000000e+00
for.cond.cleanup:
480B	%0:gpr = COPY %49:gpr
	Considering merging to GPR with %0 in %49
		RHS = %0 [480r,512r:0)  0@480r weight:0.000000e+00
		LHS = %49 [288r,336B:0)[352r,464B:1)[464B,480r:2)[656B,1024B:1)  0@288r 1@352r 2@464B-phi weight:0.000000e+00
		merge %0:0@480r into %49:2@464B --> @464B
		erased:	480r	%0:gpr = COPY %49:gpr
		updated: 496B	%1:gpr = nuw nsw ADDI %49:gpr, -999, debug-location !10; test_addarray.c:7:2
		updated: 512B	%45:gpr = SLLI %49:gpr, 2, debug-location !10; test_addarray.c:7:2
	Success: %0 -> %49
	Result = %49 [288r,336B:0)[352r,464B:1)[464B,512r:2)[656B,1024B:1)  0@288r 1@352r 2@464B-phi weight:0.000000e+00
576B	%54:gpr = COPY %4:gpr
	Considering merging to GPR with %4 in %54
		RHS = %4 [560r,576r:0)  0@560r weight:0.000000e+00
		LHS = %54 [576r,656B:0)[1056B,1248r:1)[1248r,1360B:2)  0@576r 1@1056B-phi 2@1248r weight:0.000000e+00
		merge %54:0@576r into %4:0@560r --> @560r
		erased:	576r	%54:gpr = COPY %4:gpr
		updated: 560B	%54:gpr = ADD %21:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
	Success: %4 -> %54
	Result = %54 [560r,656B:0)[1056B,1248r:1)[1248r,1360B:2)  0@560r 1@1056B-phi 2@1248r weight:0.000000e+00
592B	%55:gpr = COPY %3:gpr
	Considering merging to GPR with %3 in %55
		RHS = %3 [544r,592r:0)  0@544r weight:0.000000e+00
		LHS = %55 [592r,656B:0)[1056B,1232r:1)[1232r,1360B:2)  0@592r 1@1056B-phi 2@1232r weight:0.000000e+00
		merge %55:0@592r into %3:0@544r --> @544r
		erased:	592r	%55:gpr = COPY %3:gpr
		updated: 544B	%55:gpr = ADD %22:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
	Success: %3 -> %55
	Result = %55 [544r,656B:0)[1056B,1232r:1)[1232r,1360B:2)  0@544r 1@1056B-phi 2@1232r weight:0.000000e+00
608B	%56:gpr = COPY %2:gpr
	Considering merging to GPR with %2 in %56
		RHS = %2 [528r,608r:0)  0@528r weight:0.000000e+00
		LHS = %56 [608r,656B:0)[1056B,1216r:1)[1216r,1360B:2)  0@608r 1@1056B-phi 2@1216r weight:0.000000e+00
		merge %56:0@608r into %2:0@528r --> @528r
		erased:	608r	%56:gpr = COPY %2:gpr
		updated: 528B	%56:gpr = ADD %23:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
	Success: %2 -> %56
	Result = %56 [528r,656B:0)[1056B,1216r:1)[1216r,1360B:2)  0@528r 1@1056B-phi 2@1216r weight:0.000000e+00
624B	%57:gpr = COPY %1:gpr
	Considering merging to GPR with %1 in %57
		RHS = %1 [496r,624r:0)  0@496r weight:0.000000e+00
		LHS = %57 [624r,656B:0)[1056B,1072r:2)[1200r,1360B:1)  0@624r 1@1200r 2@1056B-phi weight:0.000000e+00
		merge %57:0@624r into %1:0@496r --> @496r
		erased:	624r	%57:gpr = COPY %1:gpr
		updated: 496B	%57:gpr = nuw nsw ADDI %49:gpr, -999, debug-location !10; test_addarray.c:7:2
	Success: %1 -> %57
	Result = %57 [496r,656B:0)[1056B,1072r:2)[1200r,1360B:1)  0@496r 1@1200r 2@1056B-phi weight:0.000000e+00
272B	%24:gpr = COPY $x0
	Considering merging %24 with $x0
		RHS = %24 [272r,288r:0)  0@272r weight:0.000000e+00
		updated: 288B	%49:gpr = COPY $x0
	Success: %24 -> $x0
	Result = $x0
288B	%49:gpr = COPY $x0
	Considering merging %49 with $x0
	Cannot join complex intervals into reserved register.
1072B	%16:gpr = COPY %57:gpr
	Considering merging to GPR with %16 in %57
		RHS = %16 [1072r,1328r:0)  0@1072r weight:0.000000e+00
		LHS = %57 [496r,656B:0)[1056B,1072r:2)[1200r,1360B:1)  0@496r 1@1200r 2@1056B-phi weight:0.000000e+00
		merge %16:0@1072r into %57:2@1056B --> @1056B
		interference at %57:1@1200r
	Interference!
384B	%50:gpr = COPY %21:gpr
	Considering merging to GPR with %21 in %50
		RHS = %21 [48r,560r:0)[656B,1024B:0)  0@48r weight:0.000000e+00
		LHS = %50 [384r,464B:0)[656B,864r:1)[864r,976B:2)  0@384r 1@656B-phi 2@864r weight:0.000000e+00
		merge %50:0@384r into %21:0@48r --> @48r
		interference at %50:2@864r
	Interference!
400B	%51:gpr = COPY %22:gpr
	Considering merging to GPR with %22 in %51
		RHS = %22 [32r,544r:0)[656B,1024B:0)  0@32r weight:0.000000e+00
		LHS = %51 [400r,464B:0)[656B,848r:1)[848r,976B:2)  0@400r 1@656B-phi 2@848r weight:0.000000e+00
		merge %51:0@400r into %22:0@32r --> @32r
		interference at %51:2@848r
	Interference!
416B	%52:gpr = COPY %23:gpr
	Considering merging to GPR with %23 in %52
		RHS = %23 [16r,528r:0)[656B,1024B:0)  0@16r weight:0.000000e+00
		LHS = %52 [416r,464B:0)[656B,832r:1)[832r,976B:2)  0@416r 1@656B-phi 2@832r weight:0.000000e+00
		merge %52:0@416r into %23:0@16r --> @16r
		interference at %52:2@832r
	Interference!
Trying to inflate 0 regs.
********** INTERVALS **********
X10 [0B,48r:0)  0@0B-phi
X11 [0B,32r:0)  0@0B-phi
X12 [0B,16r:0)  0@0B-phi
%16 [1072r,1328r:0)  0@1072r weight:0.000000e+00
%21 [48r,560r:0)[656B,1024B:0)  0@48r weight:0.000000e+00
%22 [32r,544r:0)[656B,1024B:0)  0@32r weight:0.000000e+00
%23 [16r,528r:0)[656B,1024B:0)  0@16r weight:0.000000e+00
%25 [64r,80r:0)  0@64r weight:0.000000e+00
%26 [80r,128r:0)  0@80r weight:0.000000e+00
%27 [96r,208r:0)  0@96r weight:0.000000e+00
%28 [112r,144r:0)  0@112r weight:0.000000e+00
%29 [128r,192r:0)  0@128r weight:0.000000e+00
%30 [144r,176r:0)  0@144r weight:0.000000e+00
%31 [160r,176r:0)  0@160r weight:0.000000e+00
%32 [176r,240r:0)  0@176r weight:0.000000e+00
%33 [192r,224r:0)  0@192r weight:0.000000e+00
%34 [208r,224r:0)  0@208r weight:0.000000e+00
%35 [224r,240r:0)  0@224r weight:0.000000e+00
%36 [240r,304r:0)  0@240r weight:0.000000e+00
%40 [368r,464B:0)[656B,976B:0)  0@368r weight:0.000000e+00
%41 [752r,784r:0)  0@752r weight:0.000000e+00
%42 [768r,784r:0)  0@768r weight:0.000000e+00
%43 [784r,800r:0)  0@784r weight:0.000000e+00
%45 [512r,560r:0)  0@512r weight:0.000000e+00
%46 [1136r,1168r:0)  0@1136r weight:0.000000e+00
%47 [1152r,1168r:0)  0@1152r weight:0.000000e+00
%48 [1168r,1184r:0)  0@1168r weight:0.000000e+00
%49 [288r,336B:0)[352r,464B:1)[464B,512r:2)[656B,1024B:1)  0@288r 1@352r 2@464B-phi weight:0.000000e+00
%50 [384r,464B:0)[656B,864r:1)[864r,976B:2)  0@384r 1@656B-phi 2@864r weight:0.000000e+00
%51 [400r,464B:0)[656B,848r:1)[848r,976B:2)  0@400r 1@656B-phi 2@848r weight:0.000000e+00
%52 [416r,464B:0)[656B,832r:1)[832r,976B:2)  0@416r 1@656B-phi 2@832r weight:0.000000e+00
%53 [432r,464B:0)[656B,816r:1)[816r,976B:2)  0@432r 1@656B-phi 2@816r weight:0.000000e+00
%54 [560r,656B:0)[1056B,1248r:1)[1248r,1360B:2)  0@560r 1@1056B-phi 2@1248r weight:0.000000e+00
%55 [544r,656B:0)[1056B,1232r:1)[1232r,1360B:2)  0@544r 1@1056B-phi 2@1232r weight:0.000000e+00
%56 [528r,656B:0)[1056B,1216r:1)[1216r,1360B:2)  0@528r 1@1056B-phi 2@1216r weight:0.000000e+00
%57 [496r,656B:0)[1056B,1072r:2)[1200r,1360B:1)  0@496r 1@1200r 2@1056B-phi weight:0.000000e+00
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function add: NoPHIs, TracksLiveness, TiedOpsRewritten
Function Live Ins: $x10 in %21, $x11 in %22, $x12 in %23

0B	bb.0.entry:
	  successors: %bb.2(0x40000000), %bb.1(0x40000000); %bb.2(50.00%), %bb.1(50.00%)
	  liveins: $x10, $x11, $x12
16B	  %23:gpr = COPY $x12
32B	  %22:gpr = COPY $x11
48B	  %21:gpr = COPY $x10
64B	  %25:gpr = LUI 1
80B	  %26:gpr = ADDIW %25:gpr, -100
96B	  %27:gpr = ADD %23:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
112B	  %28:gpr = ADD %21:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
128B	  %29:gpr = ADD %22:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
144B	  %30:gpr = SLTU %23:gpr, %28:gpr, debug-location !10; test_addarray.c:7:2
160B	  %31:gpr = SLTU %21:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
176B	  %32:gpr = AND %30:gpr, %31:gpr, debug-location !10; test_addarray.c:7:2
192B	  %33:gpr = SLTU %23:gpr, %29:gpr, debug-location !10; test_addarray.c:7:2
208B	  %34:gpr = SLTU %22:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
224B	  %35:gpr = AND %33:gpr, %34:gpr, debug-location !10; test_addarray.c:7:2
240B	  %36:gpr = OR %32:gpr, %35:gpr, debug-location !10; test_addarray.c:7:2
288B	  %49:gpr = COPY $x0
304B	  BNE %36:gpr, $x0, %bb.2, debug-location !10; test_addarray.c:7:2
320B	  PseudoBR %bb.1, debug-location !10; test_addarray.c:7:2

336B	bb.1.vector.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

352B	  %49:gpr = ADDI $x0, 960
368B	  %40:gpr = ADDI $x0, 64
384B	  %50:gpr = COPY %21:gpr
400B	  %51:gpr = COPY %22:gpr
416B	  %52:gpr = COPY %23:gpr
432B	  %53:gpr = ADDI $x0, 960
448B	  PseudoBR %bb.3, debug-location !10; test_addarray.c:7:2

464B	bb.2.for.body.preheader:
	; predecessors: %bb.0, %bb.6
	  successors: %bb.5(0x80000000); %bb.5(100.00%)

496B	  %57:gpr = nuw nsw ADDI %49:gpr, -999, debug-location !10; test_addarray.c:7:2
512B	  %45:gpr = SLLI %49:gpr, 2, debug-location !10; test_addarray.c:7:2
528B	  %56:gpr = ADD %23:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
544B	  %55:gpr = ADD %22:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
560B	  %54:gpr = ADD %21:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
640B	  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2

656B	bb.3.vector.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.6(0x04000000), %bb.3(0x7c000000); %bb.6(3.12%), %bb.3(96.88%)

736B	  dead $x0 = PseudoVSETVLI %40:gpr, 83, implicit-def $vl, implicit-def $vtype, debug-location !12; test_addarray.c:9:10
752B	  %41:vrm8 = PseudoVLE32_V_M8 %50:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !12 :: (load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17); test_addarray.c:9:10
768B	  %42:vrm8 = PseudoVLE32_V_M8 %51:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !20 :: (load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21); test_addarray.c:9:17
784B	  %43:vrm8 = PseudoVADD_VV_M8 %42:vrm8, %41:vrm8, $noreg, 5, implicit $vl, implicit $vtype, debug-location !23; test_addarray.c:9:15
800B	  PseudoVSE32_V_M8 %43:vrm8, %52:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !24 :: (store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27); test_addarray.c:9:8
816B	  %53:gpr = nsw ADDI %53:gpr, -64, debug-location !11; test_addarray.c:7:20
832B	  %52:gpr = ADDI %52:gpr, 256, debug-location !11; test_addarray.c:7:20
848B	  %51:gpr = ADDI %51:gpr, 256, debug-location !11; test_addarray.c:7:20
864B	  %50:gpr = ADDI %50:gpr, 256, debug-location !11; test_addarray.c:7:20
960B	  BNE %53:gpr, $x0, %bb.3, debug-location !11; test_addarray.c:7:20

976B	bb.6:
	; predecessors: %bb.3
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

1008B	  PseudoBR %bb.2

1024B	bb.4.for.cond.cleanup:
	; predecessors: %bb.5

1040B	  PseudoRET debug-location !32; test_addarray.c:11:1

1056B	bb.5.for.body:
	; predecessors: %bb.2, %bb.5
	  successors: %bb.4(0x04000000), %bb.5(0x7c000000); %bb.4(3.12%), %bb.5(96.88%)

1072B	  %16:gpr = COPY %57:gpr
1136B	  %46:gpr = LW %54:gpr, 0, debug-location !12 :: (load (s32) from %ir.lsr.iv8, !tbaa !13); test_addarray.c:9:10
1152B	  %47:gpr = LW %55:gpr, 0, debug-location !20 :: (load (s32) from %ir.lsr.iv5, !tbaa !13); test_addarray.c:9:17
1168B	  %48:gpr = ADD %47:gpr, %46:gpr, debug-location !23; test_addarray.c:9:15
1184B	  SW %48:gpr, %56:gpr, 0, debug-location !24 :: (store (s32) into %ir.lsr.iv2, !tbaa !13); test_addarray.c:9:8
1200B	  %57:gpr = ADDI %16:gpr, 1, debug-location !33; test_addarray.c:7:16
1216B	  %56:gpr = ADDI %56:gpr, 4, debug-location !33; test_addarray.c:7:16
1232B	  %55:gpr = ADDI %55:gpr, 4, debug-location !33; test_addarray.c:7:16
1248B	  %54:gpr = ADDI %54:gpr, 4, debug-location !33; test_addarray.c:7:16
1328B	  BLTU %57:gpr, %16:gpr, %bb.4, debug-location !10; test_addarray.c:7:2
1344B	  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2

# End machine code for function add.

Before MISched:
# Machine code for function add: NoPHIs, TracksLiveness, TiedOpsRewritten
Function Live Ins: $x10 in %21, $x11 in %22, $x12 in %23

bb.0.entry:
  successors: %bb.2(0x40000000), %bb.1(0x40000000); %bb.2(50.00%), %bb.1(50.00%)
  liveins: $x10, $x11, $x12
  %23:gpr = COPY $x12
  %22:gpr = COPY $x11
  %21:gpr = COPY $x10
  %25:gpr = LUI 1
  %26:gpr = ADDIW %25:gpr, -100
  %27:gpr = ADD %23:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
  %28:gpr = ADD %21:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
  %29:gpr = ADD %22:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
  %30:gpr = SLTU %23:gpr, %28:gpr, debug-location !10; test_addarray.c:7:2
  %31:gpr = SLTU %21:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
  %32:gpr = AND %30:gpr, %31:gpr, debug-location !10; test_addarray.c:7:2
  %33:gpr = SLTU %23:gpr, %29:gpr, debug-location !10; test_addarray.c:7:2
  %34:gpr = SLTU %22:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
  %35:gpr = AND %33:gpr, %34:gpr, debug-location !10; test_addarray.c:7:2
  %36:gpr = OR %32:gpr, %35:gpr, debug-location !10; test_addarray.c:7:2
  %49:gpr = COPY $x0
  BNE %36:gpr, $x0, %bb.2, debug-location !10; test_addarray.c:7:2
  PseudoBR %bb.1, debug-location !10; test_addarray.c:7:2

bb.1.vector.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %49:gpr = ADDI $x0, 960
  %40:gpr = ADDI $x0, 64
  %50:gpr = COPY %21:gpr
  %51:gpr = COPY %22:gpr
  %52:gpr = COPY %23:gpr
  %53:gpr = ADDI $x0, 960
  PseudoBR %bb.3, debug-location !10; test_addarray.c:7:2

bb.2.for.body.preheader:
; predecessors: %bb.0, %bb.6
  successors: %bb.5(0x80000000); %bb.5(100.00%)

  %57:gpr = nuw nsw ADDI %49:gpr, -999, debug-location !10; test_addarray.c:7:2
  %45:gpr = SLLI %49:gpr, 2, debug-location !10; test_addarray.c:7:2
  %56:gpr = ADD %23:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
  %55:gpr = ADD %22:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
  %54:gpr = ADD %21:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2

bb.3.vector.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.6(0x04000000), %bb.3(0x7c000000); %bb.6(3.12%), %bb.3(96.88%)

  dead $x0 = PseudoVSETVLI %40:gpr, 83, implicit-def $vl, implicit-def $vtype, debug-location !12; test_addarray.c:9:10
  %41:vrm8 = PseudoVLE32_V_M8 %50:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !12 :: (load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17); test_addarray.c:9:10
  %42:vrm8 = PseudoVLE32_V_M8 %51:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !20 :: (load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21); test_addarray.c:9:17
  %43:vrm8 = PseudoVADD_VV_M8 %42:vrm8, %41:vrm8, $noreg, 5, implicit $vl, implicit $vtype, debug-location !23; test_addarray.c:9:15
  PseudoVSE32_V_M8 %43:vrm8, %52:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !24 :: (store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27); test_addarray.c:9:8
  %53:gpr = nsw ADDI %53:gpr, -64, debug-location !11; test_addarray.c:7:20
  %52:gpr = ADDI %52:gpr, 256, debug-location !11; test_addarray.c:7:20
  %51:gpr = ADDI %51:gpr, 256, debug-location !11; test_addarray.c:7:20
  %50:gpr = ADDI %50:gpr, 256, debug-location !11; test_addarray.c:7:20
  BNE %53:gpr, $x0, %bb.3, debug-location !11; test_addarray.c:7:20

bb.6:
; predecessors: %bb.3
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  PseudoBR %bb.2

bb.4.for.cond.cleanup:
; predecessors: %bb.5

  PseudoRET debug-location !32; test_addarray.c:11:1

bb.5.for.body:
; predecessors: %bb.2, %bb.5
  successors: %bb.4(0x04000000), %bb.5(0x7c000000); %bb.4(3.12%), %bb.5(96.88%)

  %16:gpr = COPY %57:gpr
  %46:gpr = LW %54:gpr, 0, debug-location !12 :: (load (s32) from %ir.lsr.iv8, !tbaa !13); test_addarray.c:9:10
  %47:gpr = LW %55:gpr, 0, debug-location !20 :: (load (s32) from %ir.lsr.iv5, !tbaa !13); test_addarray.c:9:17
  %48:gpr = ADD %47:gpr, %46:gpr, debug-location !23; test_addarray.c:9:15
  SW %48:gpr, %56:gpr, 0, debug-location !24 :: (store (s32) into %ir.lsr.iv2, !tbaa !13); test_addarray.c:9:8
  %57:gpr = ADDI %16:gpr, 1, debug-location !33; test_addarray.c:7:16
  %56:gpr = ADDI %56:gpr, 4, debug-location !33; test_addarray.c:7:16
  %55:gpr = ADDI %55:gpr, 4, debug-location !33; test_addarray.c:7:16
  %54:gpr = ADDI %54:gpr, 4, debug-location !33; test_addarray.c:7:16
  BLTU %57:gpr, %16:gpr, %bb.4, debug-location !10; test_addarray.c:7:2
  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2

# End machine code for function add.

********** MI Scheduling **********
add:%bb.0 entry
  From: %23:gpr = COPY $x12
    To: BNE %36:gpr, $x0, %bb.2, debug-location !10; test_addarray.c:7:2
 RegionInstrs: 16
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GPRC=3
GPRTC=3
GPRJALR=3
GPR=7
Live In: X10 X11 X12 
Live Out: %49 %22 %23 %21 
Live Thru: 
  LiveReg: %49
  LiveReg: %22
  UpdateRegP: SU(7) %29:gpr = ADD %22:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
              to 
  UpdateRegP: SU(12) %34:gpr = SLTU %22:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
              to 
  LiveReg: %23
  UpdateRegP: SU(5) %27:gpr = ADD %23:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
              to 
  UpdateRegP: SU(8) %30:gpr = SLTU %23:gpr, %28:gpr, debug-location !10; test_addarray.c:7:2
              to 
  UpdateRegP: SU(11) %33:gpr = SLTU %23:gpr, %29:gpr, debug-location !10; test_addarray.c:7:2
              to 
  LiveReg: %21
  UpdateRegP: SU(6) %28:gpr = ADD %21:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
              to 
  UpdateRegP: SU(9) %31:gpr = SLTU %21:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
              to 
  LiveReg: %36
Top Pressure:
GPRC=3
GPRTC=3
GPRJALR=3
GPR=3
Bottom Pressure:
GPR=5
AllocationOrder(GPRX0) = [ ]
AllocationOrder(SP) = [ ]
AllocationOrder(FPR32C) = [ $f10_f $f11_f $f12_f $f13_f $f14_f $f15_f $f8_f $f9_f ]
AllocationOrder(GPRC) = [ $x10 $x11 $x12 $x13 $x14 $x15 $x8 $x9 ]
AllocationOrder(VRM8_with_sub_vrm1_0_in_VMV0) = [ $v0m8 ]
AllocationOrder(GPRTC) = [ $x6 $x7 $x10 $x11 $x12 $x13 $x14 $x15 $x16 $x17 $x28 $x29 $x30 $x31 ]
AllocationOrder(VRM8NoV0) = [ $v8m8 $v16m8 $v24m8 ]
AllocationOrder(GPRJALR) = [ $x10 $x11 $x12 $x13 $x14 $x15 $x16 $x17 $x6 $x7 $x28 $x29 $x30 $x31 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 ]
AllocationOrder(FPR16) = [ $f0_h $f1_h $f2_h $f3_h $f4_h $f5_h $f6_h $f7_h $f10_h $f11_h $f12_h $f13_h $f14_h $f15_h $f16_h $f17_h $f28_h $f29_h $f30_h $f31_h $f8_h $f9_h $f18_h $f19_h $f20_h $f21_h $f22_h $f23_h $f24_h $f25_h $f26_h $f27_h ]
AllocationOrder(GPR) = [ $x10 $x11 $x12 $x13 $x14 $x15 $x16 $x17 $x5 $x6 $x7 $x28 $x29 $x30 $x31 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $x1 ]
AllocationOrder(VM) = [ $v25 $v26 $v27 $v28 $v29 $v30 $v31 $v8 $v9 $v10 $v11 $v12 $v13 $v14 $v15 $v16 $v17 $v18 $v19 $v20 $v21 $v22 $v23 $v24 $v0 $v1 $v2 $v3 $v4 $v5 $v6 $v7 ]
Excess PSets: 
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %23:gpr = COPY $x12
  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 4
  Successors:
    SU(11): Data Latency=0 Reg=%23
    SU(8): Data Latency=0 Reg=%23
    SU(5): Data Latency=0 Reg=%23
  Pressure Diff      : GPRC 1    GPRTC 1    GPRJALR 1
  Single Issue       : false;
SU(1):   %22:gpr = COPY $x11
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 4
  Successors:
    SU(12): Data Latency=0 Reg=%22
    SU(7): Data Latency=0 Reg=%22
  Pressure Diff      : GPRC 1    GPRTC 1    GPRJALR 1
  Single Issue       : false;
SU(2):   %21:gpr = COPY $x10
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 4
  Successors:
    SU(9): Data Latency=0 Reg=%21
    SU(6): Data Latency=0 Reg=%21
  Pressure Diff      : GPRC 1    GPRTC 1    GPRJALR 1
  Single Issue       : false;
SU(3):   %25:gpr = LUI 1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(4): Data Latency=1 Reg=%25
  Pressure Diff      : GPR -1
  Single Issue       : false;
SU(4):   %26:gpr = ADDIW %25:gpr, -100
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
    SU(3): Data Latency=1 Reg=%25
  Successors:
    SU(7): Data Latency=1 Reg=%26
    SU(6): Data Latency=1 Reg=%26
    SU(5): Data Latency=1 Reg=%26
  Pressure Diff      : 
  Single Issue       : false;
SU(5):   %27:gpr = ADD %23:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
    SU(4): Data Latency=1 Reg=%26
    SU(0): Data Latency=0 Reg=%23
  Successors:
    SU(12): Data Latency=1 Reg=%27
    SU(9): Data Latency=1 Reg=%27
  Pressure Diff      : 
  Single Issue       : false;
SU(6):   %28:gpr = ADD %21:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
    SU(4): Data Latency=1 Reg=%26
    SU(2): Data Latency=0 Reg=%21
  Successors:
    SU(8): Data Latency=1 Reg=%28
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   %29:gpr = ADD %22:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
    SU(4): Data Latency=1 Reg=%26
    SU(1): Data Latency=0 Reg=%22
  Successors:
    SU(11): Data Latency=1 Reg=%29
  Pressure Diff      : 
  Single Issue       : false;
SU(8):   %30:gpr = SLTU %23:gpr, %28:gpr, debug-location !10; test_addarray.c:7:2
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
    SU(6): Data Latency=1 Reg=%28
    SU(0): Data Latency=0 Reg=%23
  Successors:
    SU(10): Data Latency=1 Reg=%30
  Pressure Diff      : 
  Single Issue       : false;
SU(9):   %31:gpr = SLTU %21:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1 Reg=%27
    SU(2): Data Latency=0 Reg=%21
  Successors:
    SU(10): Data Latency=1 Reg=%31
  Pressure Diff      : 
  Single Issue       : false;
SU(10):   %32:gpr = AND %30:gpr, %31:gpr, debug-location !10; test_addarray.c:7:2
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
    SU(9): Data Latency=1 Reg=%31
    SU(8): Data Latency=1 Reg=%30
  Successors:
    SU(14): Data Latency=1 Reg=%32
  Pressure Diff      : GPR 1
  Single Issue       : false;
SU(11):   %33:gpr = SLTU %23:gpr, %29:gpr, debug-location !10; test_addarray.c:7:2
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
    SU(7): Data Latency=1 Reg=%29
    SU(0): Data Latency=0 Reg=%23
  Successors:
    SU(13): Data Latency=1 Reg=%33
  Pressure Diff      : 
  Single Issue       : false;
SU(12):   %34:gpr = SLTU %22:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1 Reg=%27
    SU(1): Data Latency=0 Reg=%22
  Successors:
    SU(13): Data Latency=1 Reg=%34
  Pressure Diff      : 
  Single Issue       : false;
SU(13):   %35:gpr = AND %33:gpr, %34:gpr, debug-location !10; test_addarray.c:7:2
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
    SU(12): Data Latency=1 Reg=%34
    SU(11): Data Latency=1 Reg=%33
  Successors:
    SU(14): Data Latency=1 Reg=%35
  Pressure Diff      : GPR 1
  Single Issue       : false;
SU(14):   %36:gpr = OR %32:gpr, %35:gpr, debug-location !10; test_addarray.c:7:2
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
    SU(13): Data Latency=1 Reg=%35
    SU(10): Data Latency=1 Reg=%32
  Successors:
    ExitSU: Data Latency=1 Reg=%36
  Pressure Diff      : GPR 1
  Single Issue       : false;
SU(15):   %49:gpr = COPY $x0
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : GPR -1
  Single Issue       : false;
ExitSU:   BNE %36:gpr, $x0, %bb.2, debug-location !10; test_addarray.c:7:2
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 0
  Predecessors:
    SU(14): Data Latency=1 Reg=%36
Critical Path(GS-RR ): 6
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 14 
Queue BotQ.A: 15 
Scheduling SU(15) %49:gpr = COPY $x0
Bottom Pressure:
GPR=4
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Cycle: 1 BotQ.A
Queue BotQ.P: 
Queue BotQ.A: 14 
Scheduling SU(14) %36:gpr = OR %32:gpr, %35:gpr, debug-location !10; test_addarray.c:7:2
Bottom Pressure:
GPR=5
  LiveReg: %32
  UpdateRegP: SU(14) %36:gpr = OR %32:gpr, %35:gpr, debug-location !10; test_addarray.c:7:2
              to 
  LiveReg: %35
  UpdateRegP: SU(14) %36:gpr = OR %32:gpr, %35:gpr, debug-location !10; test_addarray.c:7:2
              to GPR -1
  Ready @1c
  BotQ.A TopLatency SU(14) 5c
  BotQ.A BotLatency SU(14) 1c
  *** Max MOps 1 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 1
  Executed: 2c
  Critical: 1c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 13 10 
  Cand SU(13) ORDER                              
Pick Bot ORDER     
Scheduling SU(13) %35:gpr = AND %33:gpr, %34:gpr, debug-location !10; test_addarray.c:7:2
Bottom Pressure:
GPR=6
  LiveReg: %33
  UpdateRegP: SU(13) %35:gpr = AND %33:gpr, %34:gpr, debug-location !10; test_addarray.c:7:2
              to 
  LiveReg: %34
  UpdateRegP: SU(13) %35:gpr = AND %33:gpr, %34:gpr, debug-location !10; test_addarray.c:7:2
              to GPR -1
  Ready @2c
  BotQ.A BotLatency SU(13) 2c
  *** Max MOps 1 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 2
  Executed: 3c
  Critical: 2c, 2 MOps
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 10 12 11 
  Cand SU(10) ORDER                              
  Cand SU(12) ORDER                              
Pick Bot ORDER     
Scheduling SU(12) %34:gpr = SLTU %22:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
Bottom Pressure:
GPR=6
  LiveReg: %27
  UpdateRegP: SU(9) %31:gpr = SLTU %21:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
              to GPR -1
  UpdateRegP: SU(12) %34:gpr = SLTU %22:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
              to GPR -1
  Ready @3c
  BotQ.A BotLatency SU(12) 3c
  *** Max MOps 1 at cycle 3
Cycle: 4 BotQ.A
BotQ.A @4c
  Retired: 3
  Executed: 4c
  Critical: 3c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 10 11 
  Cand SU(10) ORDER                              
  Cand SU(11) ORDER                              
Pick Bot ORDER     
Scheduling SU(11) %33:gpr = SLTU %23:gpr, %29:gpr, debug-location !10; test_addarray.c:7:2
Bottom Pressure:
GPR=6
  LiveReg: %29
  UpdateRegP: SU(11) %33:gpr = SLTU %23:gpr, %29:gpr, debug-location !10; test_addarray.c:7:2
              to GPR -1
  Ready @4c
  BotQ.A TopLatency SU(11) 3c
  *** Max MOps 1 at cycle 4
Cycle: 5 BotQ.A
BotQ.A @5c
  Retired: 4
  Executed: 5c
  Critical: 4c, 4 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 10 7 
  Cand SU(10) ORDER                              
Pick Bot ORDER     
Scheduling SU(10) %32:gpr = AND %30:gpr, %31:gpr, debug-location !10; test_addarray.c:7:2
Bottom Pressure:
GPR=7
  LiveReg: %30
  UpdateRegP: SU(10) %32:gpr = AND %30:gpr, %31:gpr, debug-location !10; test_addarray.c:7:2
              to 
  LiveReg: %31
  UpdateRegP: SU(10) %32:gpr = AND %30:gpr, %31:gpr, debug-location !10; test_addarray.c:7:2
              to GPR -1
  Ready @5c
  BotQ.A TopLatency SU(10) 4c
  *** Max MOps 1 at cycle 5
Cycle: 6 BotQ.A
BotQ.A @6c
  Retired: 5
  Executed: 6c
  Critical: 5c, 5 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 9 8 
  Cand SU(7) ORDER                              
  Cand SU(9) ORDER                              
Pick Bot ORDER     
Scheduling SU(9) %31:gpr = SLTU %21:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
Bottom Pressure:
GPR=6
  Ready @6c
  *** Max MOps 1 at cycle 6
Cycle: 7 BotQ.A
BotQ.A @7c
  Retired: 6
  Executed: 7c
  Critical: 6c, 6 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 8 5 
  Cand SU(7) ORDER                              
  Cand SU(8) ORDER                              
Pick Bot ORDER     
Scheduling SU(8) %30:gpr = SLTU %23:gpr, %28:gpr, debug-location !10; test_addarray.c:7:2
Bottom Pressure:
GPR=6
  LiveReg: %28
  UpdateRegP: SU(8) %30:gpr = SLTU %23:gpr, %28:gpr, debug-location !10; test_addarray.c:7:2
              to GPR -1
  Ready @7c
  BotQ.A TopLatency SU(8) 3c
  *** Max MOps 1 at cycle 7
Cycle: 8 BotQ.A
BotQ.A @8c
  Retired: 7
  Executed: 8c
  Critical: 7c, 7 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 5 6 
  Cand SU(7) ORDER                              
Pick Bot ORDER     
Scheduling SU(7) %29:gpr = ADD %22:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
Bottom Pressure:
GPR=6
  LiveReg: %26
  UpdateRegP: SU(5) %27:gpr = ADD %23:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
              to GPR -1
  UpdateRegP: SU(6) %28:gpr = ADD %21:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
              to GPR -1
  UpdateRegP: SU(7) %29:gpr = ADD %22:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
              to GPR -1
  Ready @8c
  BotQ.A BotLatency SU(7) 4c
  *** Max MOps 1 at cycle 8
Cycle: 9 BotQ.A
BotQ.A @9c
  Retired: 8
  Executed: 9c
  Critical: 8c, 8 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 5 1 
  Cand SU(6) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(6) %28:gpr = ADD %21:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
Bottom Pressure:
GPR=5
  Ready @9c
  BotQ.A TopLatency SU(6) 2c
  *** Max MOps 1 at cycle 9
Cycle: 10 BotQ.A
BotQ.A @10c
  Retired: 9
  Executed: 10c
  Critical: 9c, 9 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 5 2 
  Cand SU(1) ORDER                              
  Cand SU(5) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(5) %27:gpr = ADD %23:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
Bottom Pressure:
GPR=4
  Ready @10c
  BotQ.A TopLatency SU(5) 2c
  *** Max MOps 1 at cycle 10
Cycle: 11 BotQ.A
BotQ.A @11c
  Retired: 10
  Executed: 11c
  Critical: 10c, 10 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 4 0 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
  Cand SU(4) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(4) %26:gpr = ADDIW %25:gpr, -100
Bottom Pressure:
GPR=4
  LiveReg: %25
  UpdateRegP: SU(4) %26:gpr = ADDIW %25:gpr, -100
              to GPR -1
  Ready @11c
  BotQ.A BotLatency SU(4) 5c
  *** Max MOps 1 at cycle 11
Cycle: 12 BotQ.A
BotQ.A @12c
  Retired: 11
  Executed: 12c
  Critical: 11c, 11 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 0 3 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) %25:gpr = LUI 1
Bottom Pressure:
GPR=3
  Ready @12c
  BotQ.A BotLatency SU(3) 6c
  *** Max MOps 1 at cycle 12
Cycle: 13 BotQ.A
BotQ.A @13c
  Retired: 12
  Executed: 13c
  Critical: 12c, 12 MOps
  ExpectedLatency: 6c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 0 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %21:gpr = COPY $x10
Bottom Pressure:
GPRC=1
GPRTC=1
GPRJALR=1
GPR=3
  Ready @13c
BotQ.A @13c
  Retired: 12
  Executed: 13c
  Critical: 12c, 12 MOps
  ExpectedLatency: 6c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %22:gpr = COPY $x11
Bottom Pressure:
GPRC=2
GPRTC=2
GPRJALR=2
GPR=3
  Ready @13c
BotQ.A @13c
  Retired: 12
  Executed: 13c
  Critical: 12c, 12 MOps
  ExpectedLatency: 6c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %23:gpr = COPY $x12
Bottom Pressure:
GPRC=3
GPRTC=3
GPRJALR=3
GPR=3
  Ready @13c
BotQ.A @13c
  Retired: 12
  Executed: 13c
  Critical: 12c, 12 MOps
  ExpectedLatency: 6c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %23:gpr = COPY $x12
SU(1):   %22:gpr = COPY $x11
SU(2):   %21:gpr = COPY $x10
SU(3):   %25:gpr = LUI 1
SU(4):   %26:gpr = ADDIW %25:gpr, -100
SU(5):   %27:gpr = ADD %23:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
SU(6):   %28:gpr = ADD %21:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
SU(7):   %29:gpr = ADD %22:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
SU(8):   %30:gpr = SLTU %23:gpr, %28:gpr, debug-location !10; test_addarray.c:7:2
SU(9):   %31:gpr = SLTU %21:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
SU(10):   %32:gpr = AND %30:gpr, %31:gpr, debug-location !10; test_addarray.c:7:2
SU(11):   %33:gpr = SLTU %23:gpr, %29:gpr, debug-location !10; test_addarray.c:7:2
SU(12):   %34:gpr = SLTU %22:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
SU(13):   %35:gpr = AND %33:gpr, %34:gpr, debug-location !10; test_addarray.c:7:2
SU(14):   %36:gpr = OR %32:gpr, %35:gpr, debug-location !10; test_addarray.c:7:2
SU(15):   %49:gpr = COPY $x0

********** MI Scheduling **********
add:%bb.1 vector.body.preheader
  From: %49:gpr = ADDI $x0, 960
    To: PseudoBR %bb.3, debug-location !10; test_addarray.c:7:2
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GPR=9
Live In: %23 %22 %21 
Live Out: %53 %52 %23 %51 %22 %50 %21 %40 %49 
Live Thru: GPR=3
  LiveReg: %53
  LiveReg: %52
  LiveReg: %23
  UpdateRegP: SU(4) %52:gpr = COPY %23:gpr
              to GPR -1
  LiveReg: %51
  LiveReg: %22
  UpdateRegP: SU(3) %51:gpr = COPY %22:gpr
              to GPR -1
  LiveReg: %50
  LiveReg: %21
  UpdateRegP: SU(2) %50:gpr = COPY %21:gpr
              to GPR -1
  LiveReg: %40
  LiveReg: %49
Top Pressure:
GPR=3
Bottom Pressure:
GPR=9
Excess PSets: 
SU(0):   %49:gpr = ADDI $x0, 960
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : GPR -1
  Single Issue       : false;
SU(1):   %40:gpr = ADDI $x0, 64
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : GPR -1
  Single Issue       : false;
SU(2):   %50:gpr = COPY %21:gpr
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : GPR -1
  Single Issue       : false;
SU(3):   %51:gpr = COPY %22:gpr
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : GPR -1
  Single Issue       : false;
SU(4):   %52:gpr = COPY %23:gpr
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : GPR -1
  Single Issue       : false;
SU(5):   %53:gpr = ADDI $x0, 960
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : GPR -1
  Single Issue       : false;
ExitSU:   PseudoBR %bb.3, debug-location !10; test_addarray.c:7:2
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 4 3 2 1 0 
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %53:gpr = ADDI $x0, 960
Bottom Pressure:
GPR=8
  Ready @0c
  *** Max MOps 1 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 4 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %52:gpr = COPY %23:gpr
Bottom Pressure:
GPR=7
  Ready @1c
BotQ.A @1c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 3 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %51:gpr = COPY %22:gpr
Bottom Pressure:
GPR=6
  Ready @1c
BotQ.A @1c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %50:gpr = COPY %21:gpr
Bottom Pressure:
GPR=5
  Ready @1c
BotQ.A @1c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %40:gpr = ADDI $x0, 64
Bottom Pressure:
GPR=4
  Ready @1c
  *** Max MOps 1 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 2
  Executed: 2c
  Critical: 2c, 2 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %49:gpr = ADDI $x0, 960
Bottom Pressure:
GPR=3
  Ready @2c
  *** Max MOps 1 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 3
  Executed: 3c
  Critical: 3c, 3 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.1 ***
SU(0):   %49:gpr = ADDI $x0, 960
SU(1):   %40:gpr = ADDI $x0, 64
SU(2):   %50:gpr = COPY %21:gpr
SU(3):   %51:gpr = COPY %22:gpr
SU(4):   %52:gpr = COPY %23:gpr
SU(5):   %53:gpr = ADDI $x0, 960

********** MI Scheduling **********
add:%bb.2 for.body.preheader
  From: %57:gpr = nuw nsw ADDI %49:gpr, -999, debug-location !10; test_addarray.c:7:2
    To: PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GPR=5
Live In: %21 %22 %23 %49 
Live Out: %54 %55 %56 %57 
Live Thru: 
  LiveReg: %54
  LiveReg: %55
  LiveReg: %56
  LiveReg: %57
Top Pressure:
GPR=4
Bottom Pressure:
GPR=4
Excess PSets: 
SU(0):   %57:gpr = nuw nsw ADDI %49:gpr, -999, debug-location !10; test_addarray.c:7:2
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : 
  Single Issue       : false;
SU(1):   %45:gpr = SLLI %49:gpr, 2, debug-location !10; test_addarray.c:7:2
  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(4): Data Latency=1 Reg=%45
    SU(3): Data Latency=1 Reg=%45
    SU(2): Data Latency=1 Reg=%45
  Pressure Diff      : 
  Single Issue       : false;
SU(2):   %56:gpr = ADD %23:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%45
  Pressure Diff      : GPR 1
  Single Issue       : false;
SU(3):   %55:gpr = ADD %22:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%45
  Pressure Diff      : GPR 1
  Single Issue       : false;
SU(4):   %54:gpr = ADD %21:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%45
  Pressure Diff      : GPR 1
  Single Issue       : false;
ExitSU:   PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 0 
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %54:gpr = ADD %21:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
Bottom Pressure:
GPR=5
  LiveReg: %21
  UpdateRegP: SU(4) %54:gpr = ADD %21:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
              to 
  LiveReg: %45
  UpdateRegP: SU(2) %56:gpr = ADD %23:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
              to 
  UpdateRegP: SU(3) %55:gpr = ADD %22:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
              to 
  UpdateRegP: SU(4) %54:gpr = ADD %21:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
              to GPR -1
  Ready @0c
  BotQ.A TopLatency SU(4) 1c
  *** Max MOps 1 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 
  Cand SU(0) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %55:gpr = ADD %22:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
Bottom Pressure:
GPR=5
  LiveReg: %22
  UpdateRegP: SU(3) %55:gpr = ADD %22:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
              to GPR -1
  Ready @1c
  BotQ.A TopLatency SU(3) 1c
  *** Max MOps 1 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 2
  Executed: 2c
  Critical: 2c, 2 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 
  Cand SU(0) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %56:gpr = ADD %23:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
Bottom Pressure:
GPR=5
  LiveReg: %23
  UpdateRegP: SU(2) %56:gpr = ADD %23:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
              to GPR -1
  Ready @2c
  BotQ.A TopLatency SU(2) 1c
  *** Max MOps 1 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 3
  Executed: 3c
  Critical: 3c, 3 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %45:gpr = SLLI %49:gpr, 2, debug-location !10; test_addarray.c:7:2
Bottom Pressure:
GPR=5
  LiveReg: %49
  UpdateRegP: SU(0) %57:gpr = nuw nsw ADDI %49:gpr, -999, debug-location !10; test_addarray.c:7:2
              to GPR -1
  UpdateRegP: SU(1) %45:gpr = SLLI %49:gpr, 2, debug-location !10; test_addarray.c:7:2
              to GPR -1
  Ready @3c
  BotQ.A BotLatency SU(1) 1c
  *** Max MOps 1 at cycle 3
Cycle: 4 BotQ.A
BotQ.A @4c
  Retired: 4
  Executed: 4c
  Critical: 4c, 4 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %57:gpr = nuw nsw ADDI %49:gpr, -999, debug-location !10; test_addarray.c:7:2
Bottom Pressure:
GPR=4
  Ready @4c
  *** Max MOps 1 at cycle 4
Cycle: 5 BotQ.A
BotQ.A @5c
  Retired: 5
  Executed: 5c
  Critical: 5c, 5 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.2 ***
SU(0):   %57:gpr = nuw nsw ADDI %49:gpr, -999, debug-location !10; test_addarray.c:7:2
SU(1):   %45:gpr = SLLI %49:gpr, 2, debug-location !10; test_addarray.c:7:2
SU(2):   %56:gpr = ADD %23:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
SU(3):   %55:gpr = ADD %22:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
SU(4):   %54:gpr = ADD %21:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2

********** MI Scheduling **********
add:%bb.3 vector.body
  From: dead $x0 = PseudoVSETVLI %40:gpr, 83, implicit-def $vl, implicit-def $vtype, debug-location !12; test_addarray.c:9:10
    To: BNE %53:gpr, $x0, %bb.3, debug-location !11; test_addarray.c:7:20
 RegionInstrs: 9
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Global memory object and new barrier chain: SU(0).
Max Pressure: GPR=5
VM=16
Live In: %53 %50 %51 %52 %40 
Live Out: %53 %50 %51 %52 %40 
Live Thru: GPR=5
  LiveReg: %53
  LiveReg: %50
  LiveReg: %51
  LiveReg: %52
  LiveReg: %40
  UpdateRegP: SU(0) dead $x0 = PseudoVSETVLI %40:gpr, 83, implicit-def $vl, implicit-def $vtype, debug-location !12; test_addarray.c:9:10
              to 
Top Pressure:
GPR=5
Bottom Pressure:
GPR=5
Excess PSets: 
SU(0):   dead $x0 = PseudoVSETVLI %40:gpr, 83, implicit-def $vl, implicit-def $vtype, debug-location !12; test_addarray.c:9:10
  # preds left       : 0
  # succs left       : 11
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(4): Data Latency=0 Reg=$vl
    SU(3): Data Latency=0 Reg=$vl
    SU(2): Data Latency=0 Reg=$vl
    SU(1): Data Latency=0 Reg=$vl
    SU(4): Data Latency=0 Reg=$vtype
    SU(3): Data Latency=0 Reg=$vtype
    SU(2): Data Latency=0 Reg=$vtype
    SU(1): Data Latency=0 Reg=$vtype
    SU(4): Ord  Latency=0 Barrier
    SU(2): Ord  Latency=0 Barrier
    SU(1): Ord  Latency=0 Barrier
  Pressure Diff      : 
  Single Issue       : false;
SU(1):   %41:vrm8 = PseudoVLE32_V_M8 %50:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !12 :: (load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17); test_addarray.c:9:10
  # preds left       : 3
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Predecessors:
    SU(0): Data Latency=0 Reg=$vl
    SU(0): Data Latency=0 Reg=$vtype
    SU(0): Ord  Latency=0 Barrier
  Successors:
    SU(3): Data Latency=4 Reg=%41
    SU(8): Anti Latency=0
    SU(4): Ord  Latency=0 Memory
  Pressure Diff      : GPR 1    VM -8
  Single Issue       : false;
SU(2):   %42:vrm8 = PseudoVLE32_V_M8 %51:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !20 :: (load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21); test_addarray.c:9:17
  # preds left       : 3
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Predecessors:
    SU(0): Data Latency=0 Reg=$vl
    SU(0): Data Latency=0 Reg=$vtype
    SU(0): Ord  Latency=0 Barrier
  Successors:
    SU(3): Data Latency=4 Reg=%42
    SU(7): Anti Latency=0
    SU(4): Ord  Latency=0 Memory
  Pressure Diff      : GPR 1    VM -8
  Single Issue       : false;
SU(3):   %43:vrm8 = PseudoVADD_VV_M8 %42:vrm8, %41:vrm8, $noreg, 5, implicit $vl, implicit $vtype, debug-location !23; test_addarray.c:9:15
  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(2): Data Latency=4 Reg=%42
    SU(1): Data Latency=4 Reg=%41
    SU(0): Data Latency=0 Reg=$vl
    SU(0): Data Latency=0 Reg=$vtype
  Successors:
    SU(4): Data Latency=1 Reg=%43
  Pressure Diff      : VM 8
  Single Issue       : false;
SU(4):   PseudoVSE32_V_M8 %43:vrm8, %52:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !24 :: (store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27); test_addarray.c:9:8
  # preds left       : 6
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(3): Data Latency=1 Reg=%43
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Data Latency=0 Reg=$vl
    SU(0): Data Latency=0 Reg=$vtype
    SU(0): Ord  Latency=0 Barrier
  Successors:
    SU(6): Anti Latency=0
  Pressure Diff      : GPR 1    VM 8
  Single Issue       : false;
SU(5):   %53:gpr = nsw ADDI %53:gpr, -64, debug-location !11; test_addarray.c:7:20
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Data Latency=1 Reg=%53
  Pressure Diff      : 
  Single Issue       : false;
SU(6):   %52:gpr = ADDI %52:gpr, 256, debug-location !11; test_addarray.c:7:20
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(4): Anti Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   %51:gpr = ADDI %51:gpr, 256, debug-location !11; test_addarray.c:7:20
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(2): Anti Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(8):   %50:gpr = ADDI %50:gpr, 256, debug-location !11; test_addarray.c:7:20
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Anti Latency=0
  Pressure Diff      : 
  Single Issue       : false;
ExitSU:   BNE %53:gpr, $x0, %bb.3, debug-location !11; test_addarray.c:7:20
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(5): Data Latency=1 Reg=%53
Critical Path(GS-RR ): 5
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 5 
Queue BotQ.A: 8 7 6 
  Cand SU(8) ORDER                              
Pick Bot ORDER     
Scheduling SU(8) %50:gpr = ADDI %50:gpr, 256, debug-location !11; test_addarray.c:7:20
Bottom Pressure:
GPR=5
  LiveReg: %50
  UpdateRegP: SU(1) %41:vrm8 = PseudoVLE32_V_M8 %50:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !12 :: (load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17); test_addarray.c:9:10
              to VM -8
  UpdateRegP: SU(8) %50:gpr = ADDI %50:gpr, 256, debug-location !11; test_addarray.c:7:20
              to GPR -1
  Ready @0c
  *** Max MOps 1 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 7 5 
  Cand SU(6) ORDER                              
  Cand SU(7) ORDER                              
Pick Bot ORDER     
Scheduling SU(7) %51:gpr = ADDI %51:gpr, 256, debug-location !11; test_addarray.c:7:20
Bottom Pressure:
GPR=5
  LiveReg: %51
  UpdateRegP: SU(2) %42:vrm8 = PseudoVLE32_V_M8 %51:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !20 :: (load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21); test_addarray.c:9:17
              to VM -8
  UpdateRegP: SU(7) %51:gpr = ADDI %51:gpr, 256, debug-location !11; test_addarray.c:7:20
              to GPR -1
  Ready @1c
  *** Max MOps 1 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 2
  Executed: 2c
  Critical: 2c, 2 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 5 
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) %52:gpr = ADDI %52:gpr, 256, debug-location !11; test_addarray.c:7:20
Bottom Pressure:
GPR=5
  LiveReg: %52
  UpdateRegP: SU(4) PseudoVSE32_V_M8 %43:vrm8, %52:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !24 :: (store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27); test_addarray.c:9:8
              to VM 8
  UpdateRegP: SU(6) %52:gpr = ADDI %52:gpr, 256, debug-location !11; test_addarray.c:7:20
              to GPR -1
  Ready @2c
  BotQ.A TopLatency SU(6) 5c
  *** Max MOps 1 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 3
  Executed: 3c
  Critical: 3c, 3 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 4 
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %53:gpr = nsw ADDI %53:gpr, -64, debug-location !11; test_addarray.c:7:20
Bottom Pressure:
GPR=5
  LiveReg: %53
  UpdateRegP: SU(5) %53:gpr = nsw ADDI %53:gpr, -64, debug-location !11; test_addarray.c:7:20
              to GPR -1
  Ready @3c
  BotQ.A BotLatency SU(5) 1c
  *** Max MOps 1 at cycle 3
Cycle: 4 BotQ.A
BotQ.A @4c
  Retired: 4
  Executed: 4c
  Critical: 4c, 4 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) PseudoVSE32_V_M8 %43:vrm8, %52:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !24 :: (store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27); test_addarray.c:9:8
Bottom Pressure:
GPR=5
VM=8
  LiveReg: %43
  UpdateRegP: SU(4) PseudoVSE32_V_M8 %43:vrm8, %52:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !24 :: (store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27); test_addarray.c:9:8
              to 
  Ready @4c
  BotQ.A TopLatency SU(4) 5c
  *** Max MOps 1 at cycle 4
Cycle: 5 BotQ.A
BotQ.A @5c
  Retired: 5
  Executed: 5c
  Critical: 5c, 5 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) %43:vrm8 = PseudoVADD_VV_M8 %42:vrm8, %41:vrm8, $noreg, 5, implicit $vl, implicit $vtype, debug-location !23; test_addarray.c:9:15
Bottom Pressure:
GPR=5
VM=16
  LiveReg: %42
  UpdateRegP: SU(3) %43:vrm8 = PseudoVADD_VV_M8 %42:vrm8, %41:vrm8, $noreg, 5, implicit $vl, implicit $vtype, debug-location !23; test_addarray.c:9:15
              to 
  LiveReg: %41
  UpdateRegP: SU(3) %43:vrm8 = PseudoVADD_VV_M8 %42:vrm8, %41:vrm8, $noreg, 5, implicit $vl, implicit $vtype, debug-location !23; test_addarray.c:9:15
              to VM -8
  Ready @5c
  *** Max MOps 1 at cycle 5
Cycle: 6 BotQ.A
BotQ.A @6c
  Retired: 6
  Executed: 6c
  Critical: 6c, 6 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Cycle: 9 BotQ.A
Queue BotQ.P: 
Queue BotQ.A: 2 1 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %42:vrm8 = PseudoVLE32_V_M8 %51:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !20 :: (load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21); test_addarray.c:9:17
Bottom Pressure:
GPR=5
VM=8
  Ready @9c
  BotQ.A BotLatency SU(2) 5c
  *** Max MOps 1 at cycle 9
Cycle: 10 BotQ.A
BotQ.A @10c
  Retired: 7
  Executed: 10c
  Critical: 7c, 7 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %41:vrm8 = PseudoVLE32_V_M8 %50:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !12 :: (load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17); test_addarray.c:9:10
Bottom Pressure:
GPR=5
  Ready @10c
  *** Max MOps 1 at cycle 10
Cycle: 11 BotQ.A
BotQ.A @11c
  Retired: 8
  Executed: 11c
  Critical: 8c, 8 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) dead $x0 = PseudoVSETVLI %40:gpr, 83, implicit-def $vl, implicit-def $vtype, debug-location !12; test_addarray.c:9:10
Bottom Pressure:
GPR=5
  Ready @11c
  *** Max MOps 1 at cycle 11
Cycle: 12 BotQ.A
BotQ.A @12c
  Retired: 9
  Executed: 12c
  Critical: 9c, 9 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.3 ***
SU(0):   dead $x0 = PseudoVSETVLI %40:gpr, 83, implicit-def $vl, implicit-def $vtype, debug-location !12; test_addarray.c:9:10
SU(1):   %41:vrm8 = PseudoVLE32_V_M8 %50:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !12 :: (load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17); test_addarray.c:9:10
SU(2):   %42:vrm8 = PseudoVLE32_V_M8 %51:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !20 :: (load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21); test_addarray.c:9:17
SU(3):   %43:vrm8 = PseudoVADD_VV_M8 %42:vrm8, %41:vrm8, $noreg, 5, implicit $vl, implicit $vtype, debug-location !23; test_addarray.c:9:15
SU(4):   PseudoVSE32_V_M8 %43:vrm8, %52:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !24 :: (store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27); test_addarray.c:9:8
SU(5):   %53:gpr = nsw ADDI %53:gpr, -64, debug-location !11; test_addarray.c:7:20
SU(6):   %52:gpr = ADDI %52:gpr, 256, debug-location !11; test_addarray.c:7:20
SU(7):   %51:gpr = ADDI %51:gpr, 256, debug-location !11; test_addarray.c:7:20
SU(8):   %50:gpr = ADDI %50:gpr, 256, debug-location !11; test_addarray.c:7:20

********** MI Scheduling **********
add:%bb.5 for.body
  From: %16:gpr = COPY %57:gpr
    To: BLTU %57:gpr, %16:gpr, %bb.4, debug-location !10; test_addarray.c:7:2
 RegionInstrs: 9
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GPR=6
Live In: %57 %54 %55 %56 
Live Out: %57 %54 %55 %56 
Live Thru: GPR=3
  LiveReg: %57
  LiveReg: %54
  LiveReg: %55
  LiveReg: %56
  LiveReg: %16
  UpdateRegP: SU(5) %57:gpr = ADDI %16:gpr, 1, debug-location !33; test_addarray.c:7:16
              to GPR -1
Top Pressure:
GPR=4
Bottom Pressure:
GPR=5
Excess PSets: 
SU(0):   %16:gpr = COPY %57:gpr
  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Data Latency=0 Reg=%16
    SU(5): Data Latency=0 Reg=%16
    SU(5): Anti Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(1):   %46:gpr = LW %54:gpr, 0, debug-location !12 :: (load (s32) from %ir.lsr.iv8, !tbaa !13); test_addarray.c:9:10
  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
    SU(3): Data Latency=4 Reg=%46
    SU(8): Anti Latency=0
    SU(4): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(2):   %47:gpr = LW %55:gpr, 0, debug-location !20 :: (load (s32) from %ir.lsr.iv5, !tbaa !13); test_addarray.c:9:17
  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
    SU(3): Data Latency=4 Reg=%47
    SU(7): Anti Latency=0
    SU(4): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(3):   %48:gpr = ADD %47:gpr, %46:gpr, debug-location !23; test_addarray.c:9:15
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(2): Data Latency=4 Reg=%47
    SU(1): Data Latency=4 Reg=%46
  Successors:
    SU(4): Data Latency=1 Reg=%48
  Pressure Diff      : GPR 1
  Single Issue       : false;
SU(4):   SW %48:gpr, %56:gpr, 0, debug-location !24 :: (store (s32) into %ir.lsr.iv2, !tbaa !13); test_addarray.c:9:8
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(3): Data Latency=1 Reg=%48
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(6): Anti Latency=0
  Pressure Diff      : GPR 2
  Single Issue       : false;
SU(5):   %57:gpr = ADDI %16:gpr, 1, debug-location !33; test_addarray.c:7:16
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%16
    SU(0): Anti Latency=0
  Successors:
    ExitSU: Data Latency=1 Reg=%57
  Pressure Diff      : GPR -1
  Single Issue       : false;
SU(6):   %56:gpr = ADDI %56:gpr, 4, debug-location !33; test_addarray.c:7:16
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(4): Anti Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   %55:gpr = ADDI %55:gpr, 4, debug-location !33; test_addarray.c:7:16
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(2): Anti Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(8):   %54:gpr = ADDI %54:gpr, 4, debug-location !33; test_addarray.c:7:16
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Anti Latency=0
  Pressure Diff      : 
  Single Issue       : false;
ExitSU:   BLTU %57:gpr, %16:gpr, %bb.4, debug-location !10; test_addarray.c:7:2
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(5): Data Latency=1 Reg=%57
    SU(0): Data Latency=0 Reg=%16
Critical Path(GS-RR ): 5
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 5 
Queue BotQ.A: 8 7 6 
  Cand SU(8) ORDER                              
Pick Bot ORDER     
Scheduling SU(8) %54:gpr = ADDI %54:gpr, 4, debug-location !33; test_addarray.c:7:16
Bottom Pressure:
GPR=5
  LiveReg: %54
  UpdateRegP: SU(1) %46:gpr = LW %54:gpr, 0, debug-location !12 :: (load (s32) from %ir.lsr.iv8, !tbaa !13); test_addarray.c:9:10
              to GPR -1
  UpdateRegP: SU(8) %54:gpr = ADDI %54:gpr, 4, debug-location !33; test_addarray.c:7:16
              to GPR -1
  Ready @0c
  *** Max MOps 1 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 7 5 
  Cand SU(6) ORDER                              
  Cand SU(7) ORDER                              
Pick Bot ORDER     
Scheduling SU(7) %55:gpr = ADDI %55:gpr, 4, debug-location !33; test_addarray.c:7:16
Bottom Pressure:
GPR=5
  LiveReg: %55
  UpdateRegP: SU(2) %47:gpr = LW %55:gpr, 0, debug-location !20 :: (load (s32) from %ir.lsr.iv5, !tbaa !13); test_addarray.c:9:17
              to GPR -1
  UpdateRegP: SU(7) %55:gpr = ADDI %55:gpr, 4, debug-location !33; test_addarray.c:7:16
              to GPR -1
  Ready @1c
  *** Max MOps 1 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 2
  Executed: 2c
  Critical: 2c, 2 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 5 
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) %56:gpr = ADDI %56:gpr, 4, debug-location !33; test_addarray.c:7:16
Bottom Pressure:
GPR=5
  LiveReg: %56
  UpdateRegP: SU(4) SW %48:gpr, %56:gpr, 0, debug-location !24 :: (store (s32) into %ir.lsr.iv2, !tbaa !13); test_addarray.c:9:8
              to GPR 1
  UpdateRegP: SU(6) %56:gpr = ADDI %56:gpr, 4, debug-location !33; test_addarray.c:7:16
              to GPR -1
  Ready @2c
  BotQ.A TopLatency SU(6) 5c
  *** Max MOps 1 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 3
  Executed: 3c
  Critical: 3c, 3 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 4 
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %57:gpr = ADDI %16:gpr, 1, debug-location !33; test_addarray.c:7:16
Bottom Pressure:
GPR=4
  Ready @3c
  BotQ.A BotLatency SU(5) 1c
  *** Max MOps 1 at cycle 3
Cycle: 4 BotQ.A
BotQ.A @4c
  Retired: 4
  Executed: 4c
  Critical: 4c, 4 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 0 
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) SW %48:gpr, %56:gpr, 0, debug-location !24 :: (store (s32) into %ir.lsr.iv2, !tbaa !13); test_addarray.c:9:8
Bottom Pressure:
GPR=5
  LiveReg: %48
  UpdateRegP: SU(4) SW %48:gpr, %56:gpr, 0, debug-location !24 :: (store (s32) into %ir.lsr.iv2, !tbaa !13); test_addarray.c:9:8
              to 
  Ready @4c
  BotQ.A TopLatency SU(4) 5c
  *** Max MOps 1 at cycle 4
Cycle: 5 BotQ.A
BotQ.A @5c
  Retired: 5
  Executed: 5c
  Critical: 5c, 5 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 
  Cand SU(0) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %48:gpr = ADD %47:gpr, %46:gpr, debug-location !23; test_addarray.c:9:15
Bottom Pressure:
GPR=6
  LiveReg: %47
  UpdateRegP: SU(3) %48:gpr = ADD %47:gpr, %46:gpr, debug-location !23; test_addarray.c:9:15
              to 
  LiveReg: %46
  UpdateRegP: SU(3) %48:gpr = ADD %47:gpr, %46:gpr, debug-location !23; test_addarray.c:9:15
              to GPR -1
  Ready @5c
  *** Max MOps 1 at cycle 5
Cycle: 6 BotQ.A
BotQ.A @6c
  Retired: 6
  Executed: 6c
  Critical: 6c, 6 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 2 1 
Queue BotQ.A: 0 
Scheduling SU(0) %16:gpr = COPY %57:gpr
handleMove 1072B -> 1160B: %16:gpr = COPY %57:gpr
     %16:	[1072r,1328r:0)  0@1072r
        -->	[1160r,1328r:0)  0@1160r
     %57:	[496r,656B:0)[1056B,1072r:2)[1200r,1360B:1)  0@496r 1@1200r 2@1056B-phi
        -->	[496r,656B:0)[1056B,1160r:2)[1200r,1360B:1)  0@496r 1@1200r 2@1056B-phi
Bottom Pressure:
GPR=6
  LiveReg: %57
  UpdateRegP: SU(0) %16:gpr = COPY %57:gpr
              to GPR -1
  Ready @6c
BotQ.A @6c
  Retired: 6
  Executed: 6c
  Critical: 6c, 6 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Cycle: 7 BotQ.A
Cycle: 9 BotQ.A
Queue BotQ.P: 
Queue BotQ.A: 2 1 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %47:gpr = LW %55:gpr, 0, debug-location !20 :: (load (s32) from %ir.lsr.iv5, !tbaa !13); test_addarray.c:9:17
Bottom Pressure:
GPR=5
  Ready @9c
  BotQ.A BotLatency SU(2) 5c
  *** Max MOps 1 at cycle 9
Cycle: 10 BotQ.A
BotQ.A @10c
  Retired: 7
  Executed: 10c
  Critical: 7c, 7 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %46:gpr = LW %54:gpr, 0, debug-location !12 :: (load (s32) from %ir.lsr.iv8, !tbaa !13); test_addarray.c:9:10
Bottom Pressure:
GPR=4
  Ready @10c
  *** Max MOps 1 at cycle 10
Cycle: 11 BotQ.A
BotQ.A @11c
  Retired: 8
  Executed: 11c
  Critical: 8c, 8 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.5 ***
SU(1):   %46:gpr = LW %54:gpr, 0, debug-location !12 :: (load (s32) from %ir.lsr.iv8, !tbaa !13); test_addarray.c:9:10
SU(2):   %47:gpr = LW %55:gpr, 0, debug-location !20 :: (load (s32) from %ir.lsr.iv5, !tbaa !13); test_addarray.c:9:17
SU(0):   %16:gpr = COPY %57:gpr
SU(3):   %48:gpr = ADD %47:gpr, %46:gpr, debug-location !23; test_addarray.c:9:15
SU(4):   SW %48:gpr, %56:gpr, 0, debug-location !24 :: (store (s32) into %ir.lsr.iv2, !tbaa !13); test_addarray.c:9:8
SU(5):   %57:gpr = ADDI %16:gpr, 1, debug-location !33; test_addarray.c:7:16
SU(6):   %56:gpr = ADDI %56:gpr, 4, debug-location !33; test_addarray.c:7:16
SU(7):   %55:gpr = ADDI %55:gpr, 4, debug-location !33; test_addarray.c:7:16
SU(8):   %54:gpr = ADDI %54:gpr, 4, debug-location !33; test_addarray.c:7:16

********** INTERVALS **********
X10 [0B,48r:0)  0@0B-phi
X11 [0B,32r:0)  0@0B-phi
X12 [0B,16r:0)  0@0B-phi
%16 [1160r,1328r:0)  0@1160r weight:0.000000e+00
%21 [48r,560r:0)[656B,1024B:0)  0@48r weight:0.000000e+00
%22 [32r,544r:0)[656B,1024B:0)  0@32r weight:0.000000e+00
%23 [16r,528r:0)[656B,1024B:0)  0@16r weight:0.000000e+00
%25 [64r,80r:0)  0@64r weight:0.000000e+00
%26 [80r,128r:0)  0@80r weight:0.000000e+00
%27 [96r,208r:0)  0@96r weight:0.000000e+00
%28 [112r,144r:0)  0@112r weight:0.000000e+00
%29 [128r,192r:0)  0@128r weight:0.000000e+00
%30 [144r,176r:0)  0@144r weight:0.000000e+00
%31 [160r,176r:0)  0@160r weight:0.000000e+00
%32 [176r,240r:0)  0@176r weight:0.000000e+00
%33 [192r,224r:0)  0@192r weight:0.000000e+00
%34 [208r,224r:0)  0@208r weight:0.000000e+00
%35 [224r,240r:0)  0@224r weight:0.000000e+00
%36 [240r,304r:0)  0@240r weight:0.000000e+00
%40 [368r,464B:0)[656B,976B:0)  0@368r weight:0.000000e+00
%41 [752r,784r:0)  0@752r weight:0.000000e+00
%42 [768r,784r:0)  0@768r weight:0.000000e+00
%43 [784r,800r:0)  0@784r weight:0.000000e+00
%45 [512r,560r:0)  0@512r weight:0.000000e+00
%46 [1136r,1168r:0)  0@1136r weight:0.000000e+00
%47 [1152r,1168r:0)  0@1152r weight:0.000000e+00
%48 [1168r,1184r:0)  0@1168r weight:0.000000e+00
%49 [288r,336B:0)[352r,464B:1)[464B,512r:2)[656B,1024B:1)  0@288r 1@352r 2@464B-phi weight:0.000000e+00
%50 [384r,464B:0)[656B,864r:1)[864r,976B:2)  0@384r 1@656B-phi 2@864r weight:0.000000e+00
%51 [400r,464B:0)[656B,848r:1)[848r,976B:2)  0@400r 1@656B-phi 2@848r weight:0.000000e+00
%52 [416r,464B:0)[656B,832r:1)[832r,976B:2)  0@416r 1@656B-phi 2@832r weight:0.000000e+00
%53 [432r,464B:0)[656B,816r:1)[816r,976B:2)  0@432r 1@656B-phi 2@816r weight:0.000000e+00
%54 [560r,656B:0)[1056B,1248r:1)[1248r,1360B:2)  0@560r 1@1056B-phi 2@1248r weight:0.000000e+00
%55 [544r,656B:0)[1056B,1232r:1)[1232r,1360B:2)  0@544r 1@1056B-phi 2@1232r weight:0.000000e+00
%56 [528r,656B:0)[1056B,1216r:1)[1216r,1360B:2)  0@528r 1@1056B-phi 2@1216r weight:0.000000e+00
%57 [496r,656B:0)[1056B,1160r:2)[1200r,1360B:1)  0@496r 1@1200r 2@1056B-phi weight:0.000000e+00
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function add: NoPHIs, TracksLiveness, TiedOpsRewritten
Function Live Ins: $x10 in %21, $x11 in %22, $x12 in %23

0B	bb.0.entry:
	  successors: %bb.2(0x40000000), %bb.1(0x40000000); %bb.2(50.00%), %bb.1(50.00%)
	  liveins: $x10, $x11, $x12
16B	  %23:gpr = COPY $x12
32B	  %22:gpr = COPY $x11
48B	  %21:gpr = COPY $x10
64B	  %25:gpr = LUI 1
80B	  %26:gpr = ADDIW %25:gpr, -100
96B	  %27:gpr = ADD %23:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
112B	  %28:gpr = ADD %21:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
128B	  %29:gpr = ADD %22:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
144B	  %30:gpr = SLTU %23:gpr, %28:gpr, debug-location !10; test_addarray.c:7:2
160B	  %31:gpr = SLTU %21:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
176B	  %32:gpr = AND %30:gpr, %31:gpr, debug-location !10; test_addarray.c:7:2
192B	  %33:gpr = SLTU %23:gpr, %29:gpr, debug-location !10; test_addarray.c:7:2
208B	  %34:gpr = SLTU %22:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
224B	  %35:gpr = AND %33:gpr, %34:gpr, debug-location !10; test_addarray.c:7:2
240B	  %36:gpr = OR %32:gpr, %35:gpr, debug-location !10; test_addarray.c:7:2
288B	  %49:gpr = COPY $x0
304B	  BNE %36:gpr, $x0, %bb.2, debug-location !10; test_addarray.c:7:2
320B	  PseudoBR %bb.1, debug-location !10; test_addarray.c:7:2

336B	bb.1.vector.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

352B	  %49:gpr = ADDI $x0, 960
368B	  %40:gpr = ADDI $x0, 64
384B	  %50:gpr = COPY %21:gpr
400B	  %51:gpr = COPY %22:gpr
416B	  %52:gpr = COPY %23:gpr
432B	  %53:gpr = ADDI $x0, 960
448B	  PseudoBR %bb.3, debug-location !10; test_addarray.c:7:2

464B	bb.2.for.body.preheader:
	; predecessors: %bb.0, %bb.6
	  successors: %bb.5(0x80000000); %bb.5(100.00%)

496B	  %57:gpr = nuw nsw ADDI %49:gpr, -999, debug-location !10; test_addarray.c:7:2
512B	  %45:gpr = SLLI %49:gpr, 2, debug-location !10; test_addarray.c:7:2
528B	  %56:gpr = ADD %23:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
544B	  %55:gpr = ADD %22:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
560B	  %54:gpr = ADD %21:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
640B	  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2

656B	bb.3.vector.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.6(0x04000000), %bb.3(0x7c000000); %bb.6(3.12%), %bb.3(96.88%)

736B	  dead $x0 = PseudoVSETVLI %40:gpr, 83, implicit-def $vl, implicit-def $vtype, debug-location !12; test_addarray.c:9:10
752B	  %41:vrm8 = PseudoVLE32_V_M8 %50:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !12 :: (load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17); test_addarray.c:9:10
768B	  %42:vrm8 = PseudoVLE32_V_M8 %51:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !20 :: (load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21); test_addarray.c:9:17
784B	  %43:vrm8 = PseudoVADD_VV_M8 %42:vrm8, %41:vrm8, $noreg, 5, implicit $vl, implicit $vtype, debug-location !23; test_addarray.c:9:15
800B	  PseudoVSE32_V_M8 %43:vrm8, %52:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !24 :: (store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27); test_addarray.c:9:8
816B	  %53:gpr = nsw ADDI %53:gpr, -64, debug-location !11; test_addarray.c:7:20
832B	  %52:gpr = ADDI %52:gpr, 256, debug-location !11; test_addarray.c:7:20
848B	  %51:gpr = ADDI %51:gpr, 256, debug-location !11; test_addarray.c:7:20
864B	  %50:gpr = ADDI %50:gpr, 256, debug-location !11; test_addarray.c:7:20
960B	  BNE %53:gpr, $x0, %bb.3, debug-location !11; test_addarray.c:7:20

976B	bb.6:
	; predecessors: %bb.3
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

1008B	  PseudoBR %bb.2

1024B	bb.4.for.cond.cleanup:
	; predecessors: %bb.5

1040B	  PseudoRET debug-location !32; test_addarray.c:11:1

1056B	bb.5.for.body:
	; predecessors: %bb.2, %bb.5
	  successors: %bb.4(0x04000000), %bb.5(0x7c000000); %bb.4(3.12%), %bb.5(96.88%)

1136B	  %46:gpr = LW %54:gpr, 0, debug-location !12 :: (load (s32) from %ir.lsr.iv8, !tbaa !13); test_addarray.c:9:10
1152B	  %47:gpr = LW %55:gpr, 0, debug-location !20 :: (load (s32) from %ir.lsr.iv5, !tbaa !13); test_addarray.c:9:17
1160B	  %16:gpr = COPY %57:gpr
1168B	  %48:gpr = ADD %47:gpr, %46:gpr, debug-location !23; test_addarray.c:9:15
1184B	  SW %48:gpr, %56:gpr, 0, debug-location !24 :: (store (s32) into %ir.lsr.iv2, !tbaa !13); test_addarray.c:9:8
1200B	  %57:gpr = ADDI %16:gpr, 1, debug-location !33; test_addarray.c:7:16
1216B	  %56:gpr = ADDI %56:gpr, 4, debug-location !33; test_addarray.c:7:16
1232B	  %55:gpr = ADDI %55:gpr, 4, debug-location !33; test_addarray.c:7:16
1248B	  %54:gpr = ADDI %54:gpr, 4, debug-location !33; test_addarray.c:7:16
1328B	  BLTU %57:gpr, %16:gpr, %bb.4, debug-location !10; test_addarray.c:7:2
1344B	  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2

# End machine code for function add.


block-frequency: add
====================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[vector.body.preheader]
 - 2: BB3[vector.body]
 - 3: BB6
 - 4: BB2[for.body.preheader]
 - 5: BB5[for.body]
 - 6: BB4[for.cond.cleanup]
loop-detection
 - loop = BB5[for.body]
 - loop = BB3[vector.body]
compute-mass-in-loop: BB3[vector.body]*
 - node: BB3[vector.body]
  => [  exit  ] weight = 67108864, succ = BB6
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB3[vector.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB6
compute-loop-scale: BB3[vector.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB3[vector.body]*
 - node: BB3[vector.body]
compute-mass-in-loop: BB5[for.body]*
 - node: BB5[for.body]
  => [  exit  ] weight = 67108864, succ = BB4[for.cond.cleanup]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB5[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB4[for.cond.cleanup]
compute-loop-scale: BB5[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB5[for.body]*
 - node: BB5[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1073741824, succ = BB2[for.body.preheader]
  => [ local  ] weight = 1073741824, succ = BB1[vector.body.preheader]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB1[vector.body.preheader]
  => assign 8000000000000000 (0000000000000000) to BB2[for.body.preheader]
 - node: BB1[vector.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB3[vector.body]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB3[vector.body]
 - node: BB3[vector.body]
  => [ local  ] weight = 576460752303423488, succ = BB6
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB6
 - node: BB6
  => [ local  ] weight = 2147483648, succ = BB2[for.body.preheader]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB2[for.body.preheader]
 - node: BB2[for.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB5[for.body]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB5[for.body]
 - node: BB5[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB4[for.cond.cleanup]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB4[for.cond.cleanup]
 - node: BB4[for.cond.cleanup]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB5[for.body]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB5[for.body]: 1.0 => 32.0
unwrap-loop-package: BB3[vector.body]*: mass = 7fffffffffffffff, scale = 32.0
  => combined-scale = 16.0
 - BB3[vector.body]: 1.0 => 16.0
float-to-int: min = 0.5, max = 32.0, factor = 16.0
 - BB0[entry]: float = 1.0, scaled = 16.0, int = 16
 - BB1[vector.body.preheader]: float = 0.5, scaled = 8.0, int = 8
 - BB3[vector.body]: float = 16.0, scaled = 256.0, int = 255
 - BB6: float = 0.5, scaled = 8.0, int = 8
 - BB2[for.body.preheader]: float = 1.0, scaled = 16.0, int = 16
 - BB5[for.body]: float = 32.0, scaled = 512.0, int = 511
 - BB4[for.cond.cleanup]: float = 1.0, scaled = 16.0, int = 16
block-frequency-info: add
 - BB0[entry]: float = 1.0, int = 16
 - BB1[vector.body.preheader]: float = 0.5, int = 8
 - BB2[for.body.preheader]: float = 1.0, int = 16
 - BB3[vector.body]: float = 16.0, int = 255
 - BB6: float = 0.5, int = 8
 - BB4[for.cond.cleanup]: float = 1.0, int = 16
 - BB5[for.body]: float = 32.0, int = 511

********** COMPUTING LIVE DEBUG VARIABLES: add **********
********** DEBUG VARIABLES **********
********** DEBUG LABELS **********
********** GREEDY REGISTER ALLOCATION **********
********** Function: add
********** Compute Spill Weights **********
********** Function: add
********** INTERVALS **********
X10 [0B,48r:0)  0@0B-phi
X11 [0B,32r:0)  0@0B-phi
X12 [0B,16r:0)  0@0B-phi
%16 [1160r,1328r:0)  0@1160r weight:1.703708e-01
%21 [48r,560r:0)[656B,1024B:0)  0@48r weight:3.550781e-03
%22 [32r,544r:0)[656B,1024B:0)  0@32r weight:3.550781e-03
%23 [16r,528r:0)[656B,1024B:0)  0@16r weight:4.339844e-03
%25 [64r,80r:0)  0@64r weight:INF
%26 [80r,128r:0)  0@80r weight:8.928572e-03
%27 [96r,208r:0)  0@96r weight:5.859375e-03
%28 [112r,144r:0)  0@112r weight:4.629630e-03
%29 [128r,192r:0)  0@128r weight:4.310345e-03
%30 [144r,176r:0)  0@144r weight:4.629630e-03
%31 [160r,176r:0)  0@160r weight:INF
%32 [176r,240r:0)  0@176r weight:4.310345e-03
%33 [192r,224r:0)  0@192r weight:4.629630e-03
%34 [208r,224r:0)  0@208r weight:INF
%35 [224r,240r:0)  0@224r weight:INF
%36 [240r,304r:0)  0@240r weight:4.310345e-03
%40 [368r,464B:0)[656B,976B:0)  0@368r weight:1.009674e-02
%41 [752r,784r:0)  0@752r weight:7.378472e-02
%42 [768r,784r:0)  0@768r weight:INF
%43 [784r,800r:0)  0@784r weight:INF
%45 [512r,560r:0)  0@512r weight:8.928572e-03
%46 [1136r,1168r:0)  0@1136r weight:1.478588e-01
%47 [1152r,1168r:0)  0@1152r weight:1.535457e-01
%48 [1168r,1184r:0)  0@1168r weight:INF
%49 [288r,336B:0)[352r,464B:1)[464B,512r:2)[656B,1024B:1)  0@288r 1@352r 2@464B-phi weight:3.593429e-03
%50 [384r,464B:0)[656B,864r:1)[864r,976B:2)  0@384r 1@656B-phi 2@864r weight:1.418335e-01
%51 [400r,464B:0)[656B,848r:1)[848r,976B:2)  0@400r 1@656B-phi 2@848r weight:1.447355e-01
%52 [416r,464B:0)[656B,832r:1)[832r,976B:2)  0@416r 1@656B-phi 2@832r weight:1.477586e-01
%53 [432r,464B:0)[656B,816r:1)[816r,976B:2)  0@432r 1@656B-phi 2@816r weight:1.494167e-01
%54 [560r,656B:0)[1056B,1248r:1)[1248r,1360B:2)  0@560r 1@1056B-phi 2@1248r weight:2.814066e-01
%55 [544r,656B:0)[1056B,1232r:1)[1232r,1360B:2)  0@544r 1@1056B-phi 2@1232r weight:2.758753e-01
%56 [528r,656B:0)[1056B,1216r:1)[1216r,1360B:2)  0@528r 1@1056B-phi 2@1216r weight:2.705572e-01
%57 [496r,656B:0)[1056B,1160r:2)[1200r,1360B:1)  0@496r 1@1200r 2@1056B-phi weight:1.974384e-01
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function add: NoPHIs, TracksLiveness, TiedOpsRewritten
Function Live Ins: $x10 in %21, $x11 in %22, $x12 in %23

0B	bb.0.entry:
	  successors: %bb.2(0x40000000), %bb.1(0x40000000); %bb.2(50.00%), %bb.1(50.00%)
	  liveins: $x10, $x11, $x12
16B	  %23:gpr = COPY $x12
32B	  %22:gpr = COPY $x11
48B	  %21:gpr = COPY $x10
64B	  %25:gpr = LUI 1
80B	  %26:gpr = ADDIW %25:gpr, -100
96B	  %27:gpr = ADD %23:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
112B	  %28:gpr = ADD %21:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
128B	  %29:gpr = ADD %22:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
144B	  %30:gpr = SLTU %23:gpr, %28:gpr, debug-location !10; test_addarray.c:7:2
160B	  %31:gpr = SLTU %21:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
176B	  %32:gpr = AND %30:gpr, %31:gpr, debug-location !10; test_addarray.c:7:2
192B	  %33:gpr = SLTU %23:gpr, %29:gpr, debug-location !10; test_addarray.c:7:2
208B	  %34:gpr = SLTU %22:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
224B	  %35:gpr = AND %33:gpr, %34:gpr, debug-location !10; test_addarray.c:7:2
240B	  %36:gpr = OR %32:gpr, %35:gpr, debug-location !10; test_addarray.c:7:2
288B	  %49:gpr = COPY $x0
304B	  BNE %36:gpr, $x0, %bb.2, debug-location !10; test_addarray.c:7:2
320B	  PseudoBR %bb.1, debug-location !10; test_addarray.c:7:2

336B	bb.1.vector.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

352B	  %49:gpr = ADDI $x0, 960
368B	  %40:gpr = ADDI $x0, 64
384B	  %50:gpr = COPY %21:gpr
400B	  %51:gpr = COPY %22:gpr
416B	  %52:gpr = COPY %23:gpr
432B	  %53:gpr = ADDI $x0, 960
448B	  PseudoBR %bb.3, debug-location !10; test_addarray.c:7:2

464B	bb.2.for.body.preheader:
	; predecessors: %bb.0, %bb.6
	  successors: %bb.5(0x80000000); %bb.5(100.00%)

496B	  %57:gpr = nuw nsw ADDI %49:gpr, -999, debug-location !10; test_addarray.c:7:2
512B	  %45:gpr = SLLI %49:gpr, 2, debug-location !10; test_addarray.c:7:2
528B	  %56:gpr = ADD %23:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
544B	  %55:gpr = ADD %22:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
560B	  %54:gpr = ADD %21:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
640B	  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2

656B	bb.3.vector.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.6(0x04000000), %bb.3(0x7c000000); %bb.6(3.12%), %bb.3(96.88%)

736B	  dead $x0 = PseudoVSETVLI %40:gpr, 83, implicit-def $vl, implicit-def $vtype, debug-location !12; test_addarray.c:9:10
752B	  %41:vrm8 = PseudoVLE32_V_M8 %50:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !12 :: (load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17); test_addarray.c:9:10
768B	  %42:vrm8 = PseudoVLE32_V_M8 %51:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !20 :: (load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21); test_addarray.c:9:17
784B	  %43:vrm8 = PseudoVADD_VV_M8 %42:vrm8, %41:vrm8, $noreg, 5, implicit $vl, implicit $vtype, debug-location !23; test_addarray.c:9:15
800B	  PseudoVSE32_V_M8 %43:vrm8, %52:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !24 :: (store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27); test_addarray.c:9:8
816B	  %53:gpr = nsw ADDI %53:gpr, -64, debug-location !11; test_addarray.c:7:20
832B	  %52:gpr = ADDI %52:gpr, 256, debug-location !11; test_addarray.c:7:20
848B	  %51:gpr = ADDI %51:gpr, 256, debug-location !11; test_addarray.c:7:20
864B	  %50:gpr = ADDI %50:gpr, 256, debug-location !11; test_addarray.c:7:20
960B	  BNE %53:gpr, $x0, %bb.3, debug-location !11; test_addarray.c:7:20

976B	bb.6:
	; predecessors: %bb.3
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

1008B	  PseudoBR %bb.2

1024B	bb.4.for.cond.cleanup:
	; predecessors: %bb.5

1040B	  PseudoRET debug-location !32; test_addarray.c:11:1

1056B	bb.5.for.body:
	; predecessors: %bb.2, %bb.5
	  successors: %bb.4(0x04000000), %bb.5(0x7c000000); %bb.4(3.12%), %bb.5(96.88%)

1136B	  %46:gpr = LW %54:gpr, 0, debug-location !12 :: (load (s32) from %ir.lsr.iv8, !tbaa !13); test_addarray.c:9:10
1152B	  %47:gpr = LW %55:gpr, 0, debug-location !20 :: (load (s32) from %ir.lsr.iv5, !tbaa !13); test_addarray.c:9:17
1160B	  %16:gpr = COPY %57:gpr
1168B	  %48:gpr = ADD %47:gpr, %46:gpr, debug-location !23; test_addarray.c:9:15
1184B	  SW %48:gpr, %56:gpr, 0, debug-location !24 :: (store (s32) into %ir.lsr.iv2, !tbaa !13); test_addarray.c:9:8
1200B	  %57:gpr = ADDI %16:gpr, 1, debug-location !33; test_addarray.c:7:16
1216B	  %56:gpr = ADDI %56:gpr, 4, debug-location !33; test_addarray.c:7:16
1232B	  %55:gpr = ADDI %55:gpr, 4, debug-location !33; test_addarray.c:7:16
1248B	  %54:gpr = ADDI %54:gpr, 4, debug-location !33; test_addarray.c:7:16
1328B	  BLTU %57:gpr, %16:gpr, %bb.4, debug-location !10; test_addarray.c:7:2
1344B	  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2

# End machine code for function add.

Enqueuing %16
Enqueuing %21
Enqueuing %22
Enqueuing %23
Enqueuing %25
Enqueuing %26
Enqueuing %27
Enqueuing %28
Enqueuing %29
Enqueuing %30
Enqueuing %31
Enqueuing %32
Enqueuing %33
Enqueuing %34
Enqueuing %35
Enqueuing %36
Enqueuing %40
Enqueuing %41
Enqueuing %42
Enqueuing %43
Enqueuing %45
Enqueuing %46
Enqueuing %47
Enqueuing %48
Enqueuing %49
Enqueuing %50
Enqueuing %51
Enqueuing %52
Enqueuing %53
Enqueuing %54
Enqueuing %55
Enqueuing %56
Enqueuing %57

selectOrSplit GPR:%21 [48r,560r:0)[656B,1024B:0)  0@48r weight:3.550781e-03 w=3.550781e-03
AllocationOrder(GPR) = [ $x10 $x11 $x12 $x13 $x14 $x15 $x16 $x17 $x5 $x6 $x7 $x28 $x29 $x30 $x31 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $x1 ]
hints: $x10
assigning %21 to $x10: X10 [48r,560r:0)[656B,1024B:0)  0@48r

selectOrSplit GPR:%22 [32r,544r:0)[656B,1024B:0)  0@32r weight:3.550781e-03 w=3.550781e-03
hints: $x11
assigning %22 to $x11: X11 [32r,544r:0)[656B,1024B:0)  0@32r

selectOrSplit GPR:%23 [16r,528r:0)[656B,1024B:0)  0@16r weight:4.339844e-03 w=4.339844e-03
hints: $x12
assigning %23 to $x12: X12 [16r,528r:0)[656B,1024B:0)  0@16r

selectOrSplit GPR:%49 [288r,336B:0)[352r,464B:1)[464B,512r:2)[656B,1024B:1)  0@288r 1@352r 2@464B-phi weight:3.593429e-03 w=3.593429e-03
assigning %49 to $x13: X13 [288r,336B:0)[352r,464B:1)[464B,512r:2)[656B,1024B:1)  0@288r 1@352r 2@464B-phi

selectOrSplit GPR:%56 [528r,656B:0)[1056B,1216r:1)[1216r,1360B:2)  0@528r 1@1056B-phi 2@1216r weight:2.705572e-01 w=2.705572e-01
assigning %56 to $x12: X12 [528r,656B:0)[1056B,1216r:1)[1216r,1360B:2)  0@528r 1@1056B-phi 2@1216r

selectOrSplit GPR:%57 [496r,656B:0)[1056B,1160r:2)[1200r,1360B:1)  0@496r 1@1200r 2@1056B-phi weight:1.974384e-01 w=1.974384e-01
assigning %57 to $x14: X14 [496r,656B:0)[1056B,1160r:2)[1200r,1360B:1)  0@496r 1@1200r 2@1056B-phi

selectOrSplit GPR:%40 [368r,464B:0)[656B,976B:0)  0@368r weight:1.009674e-02 w=1.009674e-02
assigning %40 to $x14: X14 [368r,464B:0)[656B,976B:0)  0@368r

selectOrSplit GPR:%55 [544r,656B:0)[1056B,1232r:1)[1232r,1360B:2)  0@544r 1@1056B-phi 2@1232r weight:2.758753e-01 w=2.758753e-01
assigning %55 to $x11: X11 [544r,656B:0)[1056B,1232r:1)[1232r,1360B:2)  0@544r 1@1056B-phi 2@1232r

selectOrSplit GPR:%50 [384r,464B:0)[656B,864r:1)[864r,976B:2)  0@384r 1@656B-phi 2@864r weight:1.418335e-01 w=1.418335e-01
hints: $x10
assigning %50 to $x15: X15 [384r,464B:0)[656B,864r:1)[864r,976B:2)  0@384r 1@656B-phi 2@864r

selectOrSplit GPR:%54 [560r,656B:0)[1056B,1248r:1)[1248r,1360B:2)  0@560r 1@1056B-phi 2@1248r weight:2.814066e-01 w=2.814066e-01
assigning %54 to $x10: X10 [560r,656B:0)[1056B,1248r:1)[1248r,1360B:2)  0@560r 1@1056B-phi 2@1248r

selectOrSplit GPR:%51 [400r,464B:0)[656B,848r:1)[848r,976B:2)  0@400r 1@656B-phi 2@848r weight:1.447355e-01 w=1.447355e-01
hints: $x11
$x16 is available at cost 
Only trying the first 17 regs.
should evict: %49 [288r,336B:0)[352r,464B:1)[464B,512r:2)[656B,1024B:1)  0@288r 1@352r 2@464B-phi weight:3.593429e-03 w= 3.593429e-03
$x8 would clobber CSR $x8
$x9 would clobber CSR $x9
evicting $x13 interference: Cascade 1
unassigning %49 from $x13: X13
assigning %51 to $x13: X13 [400r,464B:0)[656B,848r:1)[848r,976B:2)  0@400r 1@656B-phi 2@848r
queuing new interval: %49 [288r,336B:0)[352r,464B:1)[464B,512r:2)[656B,1024B:1)  0@288r 1@352r 2@464B-phi weight:3.593429e-03
Enqueuing %49

selectOrSplit GPR:%49 [288r,336B:0)[352r,464B:1)[464B,512r:2)[656B,1024B:1)  0@288r 1@352r 2@464B-phi weight:3.593429e-03 w=3.593429e-03
$x16 is available at cost 
Only trying the first 17 regs.
$x8 would clobber CSR $x8
$x9 would clobber CSR $x9
assigning %49 to $x16: X16 [288r,336B:0)[352r,464B:1)[464B,512r:2)[656B,1024B:1)  0@288r 1@352r 2@464B-phi

selectOrSplit GPR:%52 [416r,464B:0)[656B,832r:1)[832r,976B:2)  0@416r 1@656B-phi 2@832r weight:1.477586e-01 w=1.477586e-01
hints: $x12
$x17 is available at cost 
Only trying the first 17 regs.
should evict: %51 [400r,464B:0)[656B,848r:1)[848r,976B:2)  0@400r 1@656B-phi 2@848r weight:1.447355e-01 w= 1.447355e-01
should evict: %40 [368r,464B:0)[656B,976B:0)  0@368r weight:1.009674e-02 w= 1.009674e-02
$x8 would clobber CSR $x8
$x9 would clobber CSR $x9
evicting $x14 interference: Cascade 2
unassigning %40 from $x14: X14
assigning %52 to $x14: X14 [416r,464B:0)[656B,832r:1)[832r,976B:2)  0@416r 1@656B-phi 2@832r
queuing new interval: %40 [368r,464B:0)[656B,976B:0)  0@368r weight:1.009674e-02
Enqueuing %40

selectOrSplit GPR:%40 [368r,464B:0)[656B,976B:0)  0@368r weight:1.009674e-02 w=1.009674e-02
$x17 is available at cost 
Only trying the first 17 regs.
$x8 would clobber CSR $x8
$x9 would clobber CSR $x9
assigning %40 to $x17: X17 [368r,464B:0)[656B,976B:0)  0@368r

selectOrSplit GPR:%53 [432r,464B:0)[656B,816r:1)[816r,976B:2)  0@432r 1@656B-phi 2@816r weight:1.494167e-01 w=1.494167e-01
$x5 is available at cost 
Only trying the first 17 regs.
should evict: %51 [400r,464B:0)[656B,848r:1)[848r,976B:2)  0@400r 1@656B-phi 2@848r weight:1.447355e-01 w= 1.447355e-01
should evict: %50 [384r,464B:0)[656B,864r:1)[864r,976B:2)  0@384r 1@656B-phi 2@864r weight:1.418335e-01 w= 1.418335e-01
$x8 would clobber CSR $x8
$x9 would clobber CSR $x9
evicting $x15 interference: Cascade 3
unassigning %50 from $x15: X15
assigning %53 to $x15: X15 [432r,464B:0)[656B,816r:1)[816r,976B:2)  0@432r 1@656B-phi 2@816r
queuing new interval: %50 [384r,464B:0)[656B,864r:1)[864r,976B:2)  0@384r 1@656B-phi 2@864r weight:1.418335e-01
Enqueuing %50

selectOrSplit GPR:%50 [384r,464B:0)[656B,864r:1)[864r,976B:2)  0@384r 1@656B-phi 2@864r weight:1.418335e-01 w=1.418335e-01
hints: $x10
$x5 is available at cost 
Only trying the first 17 regs.
$x8 would clobber CSR $x8
$x9 would clobber CSR $x9
assigning %50 to $x5: X5 [384r,464B:0)[656B,864r:1)[864r,976B:2)  0@384r 1@656B-phi 2@864r

selectOrSplit GPR:%25 [64r,80r:0)  0@64r weight:INF w=INF
assigning %25 to $x13: X13 [64r,80r:0)  0@64r

selectOrSplit GPR:%26 [80r,128r:0)  0@80r weight:8.928572e-03 w=8.928572e-03
assigning %26 to $x13: X13 [80r,128r:0)  0@80r

selectOrSplit GPR:%27 [96r,208r:0)  0@96r weight:5.859375e-03 w=5.859375e-03
assigning %27 to $x14: X14 [96r,208r:0)  0@96r

selectOrSplit GPR:%28 [112r,144r:0)  0@112r weight:4.629630e-03 w=4.629630e-03
assigning %28 to $x15: X15 [112r,144r:0)  0@112r

selectOrSplit GPR:%29 [128r,192r:0)  0@128r weight:4.310345e-03 w=4.310345e-03
assigning %29 to $x13: X13 [128r,192r:0)  0@128r

selectOrSplit GPR:%30 [144r,176r:0)  0@144r weight:4.629630e-03 w=4.629630e-03
assigning %30 to $x15: X15 [144r,176r:0)  0@144r

selectOrSplit GPR:%31 [160r,176r:0)  0@160r weight:INF w=INF
$x16 is available at cost 
Only trying the first 17 regs.
$x8 would clobber CSR $x8
$x9 would clobber CSR $x9
evicting $x13 interference: Cascade 4
unassigning %29 from $x13: X13
assigning %31 to $x13: X13 [160r,176r:0)  0@160r
queuing new interval: %29 [128r,192r:0)  0@128r weight:4.310345e-03
Enqueuing %29

selectOrSplit GPR:%29 [128r,192r:0)  0@128r weight:4.310345e-03 w=4.310345e-03
$x16 is available at cost 
Only trying the first 17 regs.
$x8 would clobber CSR $x8
$x9 would clobber CSR $x9
assigning %29 to $x16: X16 [128r,192r:0)  0@128r

selectOrSplit GPR:%32 [176r,240r:0)  0@176r weight:4.310345e-03 w=4.310345e-03
assigning %32 to $x13: X13 [176r,240r:0)  0@176r

selectOrSplit GPR:%33 [192r,224r:0)  0@192r weight:4.629630e-03 w=4.629630e-03
assigning %33 to $x15: X15 [192r,224r:0)  0@192r

selectOrSplit GPR:%34 [208r,224r:0)  0@208r weight:INF w=INF
assigning %34 to $x14: X14 [208r,224r:0)  0@208r

selectOrSplit GPR:%35 [224r,240r:0)  0@224r weight:INF w=INF
assigning %35 to $x14: X14 [224r,240r:0)  0@224r

selectOrSplit GPR:%36 [240r,304r:0)  0@240r weight:4.310345e-03 w=4.310345e-03
assigning %36 to $x13: X13 [240r,304r:0)  0@240r

selectOrSplit GPR:%45 [512r,560r:0)  0@512r weight:8.928572e-03 w=8.928572e-03
assigning %45 to $x13: X13 [512r,560r:0)  0@512r

selectOrSplit VRM8:%41 [752r,784r:0)  0@752r weight:7.378472e-02 w=7.378472e-02
AllocationOrder(VRM8) = [ $v8m8 $v16m8 $v24m8 $v0m8 ]
assigning %41 to $v8m8: V8 [752r,784r:0)  0@752r V9 [752r,784r:0)  0@752r V10 [752r,784r:0)  0@752r V11 [752r,784r:0)  0@752r V12 [752r,784r:0)  0@752r V13 [752r,784r:0)  0@752r V14 [752r,784r:0)  0@752r V15 [752r,784r:0)  0@752r

selectOrSplit VRM8:%42 [768r,784r:0)  0@768r weight:INF w=INF
assigning %42 to $v16m8: V16 [768r,784r:0)  0@768r V17 [768r,784r:0)  0@768r V18 [768r,784r:0)  0@768r V19 [768r,784r:0)  0@768r V20 [768r,784r:0)  0@768r V21 [768r,784r:0)  0@768r V22 [768r,784r:0)  0@768r V23 [768r,784r:0)  0@768r

selectOrSplit VRM8:%43 [784r,800r:0)  0@784r weight:INF w=INF
assigning %43 to $v8m8: V8 [784r,800r:0)  0@784r V9 [784r,800r:0)  0@784r V10 [784r,800r:0)  0@784r V11 [784r,800r:0)  0@784r V12 [784r,800r:0)  0@784r V13 [784r,800r:0)  0@784r V14 [784r,800r:0)  0@784r V15 [784r,800r:0)  0@784r

selectOrSplit GPR:%46 [1136r,1168r:0)  0@1136r weight:1.478588e-01 w=1.478588e-01
assigning %46 to $x13: X13 [1136r,1168r:0)  0@1136r

selectOrSplit GPR:%47 [1152r,1168r:0)  0@1152r weight:1.535457e-01 w=1.535457e-01
assigning %47 to $x15: X15 [1152r,1168r:0)  0@1152r

selectOrSplit GPR:%16 [1160r,1328r:0)  0@1160r weight:1.703708e-01 w=1.703708e-01
hints: $x14
$x16 is available at cost 
Only trying the first 17 regs.
should evict: %46 [1136r,1168r:0)  0@1136r weight:1.478588e-01 w= 1.478588e-01
can reassign: %46 [1136r,1168r:0)  0@1136r weight:1.478588e-01 from $x13 to $x16
$x8 would clobber CSR $x8
$x9 would clobber CSR $x9
evicting $x13 interference: Cascade 5
unassigning %46 from $x13: X13
assigning %16 to $x13: X13 [1160r,1328r:0)  0@1160r
queuing new interval: %46 [1136r,1168r:0)  0@1136r weight:1.478588e-01
Enqueuing %46

selectOrSplit GPR:%46 [1136r,1168r:0)  0@1136r weight:1.478588e-01 w=1.478588e-01
$x16 is available at cost 
Only trying the first 17 regs.
$x8 would clobber CSR $x8
$x9 would clobber CSR $x9
assigning %46 to $x16: X16 [1136r,1168r:0)  0@1136r

selectOrSplit GPR:%48 [1168r,1184r:0)  0@1168r weight:INF w=INF
assigning %48 to $x14: X14 [1168r,1184r:0)  0@1168r
********** REWRITE VIRTUAL REGISTERS **********
********** Function: add
********** REGISTER MAP **********
[%16 -> $x13] GPR
[%21 -> $x10] GPR
[%22 -> $x11] GPR
[%23 -> $x12] GPR
[%25 -> $x13] GPR
[%26 -> $x13] GPR
[%27 -> $x14] GPR
[%28 -> $x15] GPR
[%29 -> $x16] GPR
[%30 -> $x15] GPR
[%31 -> $x13] GPR
[%32 -> $x13] GPR
[%33 -> $x15] GPR
[%34 -> $x14] GPR
[%35 -> $x14] GPR
[%36 -> $x13] GPR
[%40 -> $x17] GPR
[%41 -> $v8m8] VRM8
[%42 -> $v16m8] VRM8
[%43 -> $v8m8] VRM8
[%45 -> $x13] GPR
[%46 -> $x16] GPR
[%47 -> $x15] GPR
[%48 -> $x14] GPR
[%49 -> $x16] GPR
[%50 -> $x5] GPR
[%51 -> $x13] GPR
[%52 -> $x14] GPR
[%53 -> $x15] GPR
[%54 -> $x10] GPR
[%55 -> $x11] GPR
[%56 -> $x12] GPR
[%57 -> $x14] GPR

0B	bb.0.entry:
	  successors: %bb.2(0x40000000), %bb.1(0x40000000); %bb.2(50.00%), %bb.1(50.00%)
	  liveins: $x10, $x11, $x12
16B	  %23:gpr = COPY $x12
32B	  %22:gpr = COPY $x11
48B	  %21:gpr = COPY $x10
64B	  %25:gpr = LUI 1
80B	  %26:gpr = ADDIW killed %25:gpr, -100
96B	  %27:gpr = ADD %23:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
112B	  %28:gpr = ADD %21:gpr, %26:gpr, debug-location !10; test_addarray.c:7:2
128B	  %29:gpr = ADD %22:gpr, killed %26:gpr, debug-location !10; test_addarray.c:7:2
144B	  %30:gpr = SLTU %23:gpr, killed %28:gpr, debug-location !10; test_addarray.c:7:2
160B	  %31:gpr = SLTU %21:gpr, %27:gpr, debug-location !10; test_addarray.c:7:2
176B	  %32:gpr = AND killed %30:gpr, killed %31:gpr, debug-location !10; test_addarray.c:7:2
192B	  %33:gpr = SLTU %23:gpr, killed %29:gpr, debug-location !10; test_addarray.c:7:2
208B	  %34:gpr = SLTU %22:gpr, killed %27:gpr, debug-location !10; test_addarray.c:7:2
224B	  %35:gpr = AND killed %33:gpr, killed %34:gpr, debug-location !10; test_addarray.c:7:2
240B	  %36:gpr = OR killed %32:gpr, killed %35:gpr, debug-location !10; test_addarray.c:7:2
288B	  %49:gpr = COPY $x0
304B	  BNE killed %36:gpr, $x0, %bb.2, debug-location !10; test_addarray.c:7:2
320B	  PseudoBR %bb.1, debug-location !10; test_addarray.c:7:2
> renamable $x12 = COPY $x12
Identity copy: renamable $x12 = COPY $x12
  deleted.
> renamable $x11 = COPY $x11
Identity copy: renamable $x11 = COPY $x11
  deleted.
> renamable $x10 = COPY $x10
Identity copy: renamable $x10 = COPY $x10
  deleted.
> renamable $x13 = LUI 1
> renamable $x13 = ADDIW killed renamable $x13, -100
> renamable $x14 = ADD renamable $x12, renamable $x13, debug-location !10; test_addarray.c:7:2
> renamable $x15 = ADD renamable $x10, renamable $x13, debug-location !10; test_addarray.c:7:2
> renamable $x16 = ADD renamable $x11, killed renamable $x13, debug-location !10; test_addarray.c:7:2
> renamable $x15 = SLTU renamable $x12, killed renamable $x15, debug-location !10; test_addarray.c:7:2
> renamable $x13 = SLTU renamable $x10, renamable $x14, debug-location !10; test_addarray.c:7:2
> renamable $x13 = AND killed renamable $x15, killed renamable $x13, debug-location !10; test_addarray.c:7:2
> renamable $x15 = SLTU renamable $x12, killed renamable $x16, debug-location !10; test_addarray.c:7:2
> renamable $x14 = SLTU renamable $x11, killed renamable $x14, debug-location !10; test_addarray.c:7:2
> renamable $x14 = AND killed renamable $x15, killed renamable $x14, debug-location !10; test_addarray.c:7:2
> renamable $x13 = OR killed renamable $x13, killed renamable $x14, debug-location !10; test_addarray.c:7:2
> renamable $x16 = COPY $x0
> BNE killed renamable $x13, $x0, %bb.2, debug-location !10; test_addarray.c:7:2
> PseudoBR %bb.1, debug-location !10; test_addarray.c:7:2
336B	bb.1.vector.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)
	  liveins: $x10, $x11, $x12
352B	  %49:gpr = ADDI $x0, 960
368B	  %40:gpr = ADDI $x0, 64
384B	  %50:gpr = COPY %21:gpr
400B	  %51:gpr = COPY %22:gpr
416B	  %52:gpr = COPY %23:gpr
432B	  %53:gpr = ADDI $x0, 960
448B	  PseudoBR %bb.3, debug-location !10; test_addarray.c:7:2
> renamable $x16 = ADDI $x0, 960
> renamable $x17 = ADDI $x0, 64
> renamable $x5 = COPY renamable $x10
> renamable $x13 = COPY renamable $x11
> renamable $x14 = COPY renamable $x12
> renamable $x15 = ADDI $x0, 960
> PseudoBR %bb.3, debug-location !10; test_addarray.c:7:2
464B	bb.2.for.body.preheader:
	; predecessors: %bb.0, %bb.6
	  successors: %bb.5(0x80000000); %bb.5(100.00%)
	  liveins: $x10, $x11, $x12, $x16
496B	  %57:gpr = nuw nsw ADDI %49:gpr, -999, debug-location !10; test_addarray.c:7:2
512B	  %45:gpr = SLLI killed %49:gpr, 2, debug-location !10; test_addarray.c:7:2
528B	  %56:gpr = ADD killed %23:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
544B	  %55:gpr = ADD killed %22:gpr, %45:gpr, debug-location !10; test_addarray.c:7:2
560B	  %54:gpr = ADD killed %21:gpr, killed %45:gpr, debug-location !10; test_addarray.c:7:2
640B	  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2
> renamable $x14 = nuw nsw ADDI renamable $x16, -999, debug-location !10; test_addarray.c:7:2
> renamable $x13 = SLLI killed renamable $x16, 2, debug-location !10; test_addarray.c:7:2
> renamable $x12 = ADD killed renamable $x12, renamable $x13, debug-location !10; test_addarray.c:7:2
> renamable $x11 = ADD killed renamable $x11, renamable $x13, debug-location !10; test_addarray.c:7:2
> renamable $x10 = ADD killed renamable $x10, killed renamable $x13, debug-location !10; test_addarray.c:7:2
> PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2
656B	bb.3.vector.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.6(0x04000000), %bb.3(0x7c000000); %bb.6(3.12%), %bb.3(96.88%)
	  liveins: $x5, $x10, $x11, $x12, $x13, $x14, $x15, $x16, $x17
736B	  dead $x0 = PseudoVSETVLI %40:gpr, 83, implicit-def $vl, implicit-def $vtype, debug-location !12; test_addarray.c:9:10
752B	  %41:vrm8 = PseudoVLE32_V_M8 %50:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !12 :: (load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17); test_addarray.c:9:10
768B	  %42:vrm8 = PseudoVLE32_V_M8 %51:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !20 :: (load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21); test_addarray.c:9:17
784B	  %43:vrm8 = PseudoVADD_VV_M8 killed %42:vrm8, killed %41:vrm8, $noreg, 5, implicit $vl, implicit $vtype, debug-location !23; test_addarray.c:9:15
800B	  PseudoVSE32_V_M8 killed %43:vrm8, %52:gpr, $noreg, 5, implicit $vl, implicit $vtype, debug-location !24 :: (store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27); test_addarray.c:9:8
816B	  %53:gpr = nsw ADDI killed %53:gpr, -64, debug-location !11; test_addarray.c:7:20
832B	  %52:gpr = ADDI killed %52:gpr, 256, debug-location !11; test_addarray.c:7:20
848B	  %51:gpr = ADDI killed %51:gpr, 256, debug-location !11; test_addarray.c:7:20
864B	  %50:gpr = ADDI killed %50:gpr, 256, debug-location !11; test_addarray.c:7:20
960B	  BNE %53:gpr, $x0, %bb.3, debug-location !11; test_addarray.c:7:20
> dead $x0 = PseudoVSETVLI renamable $x17, 83, implicit-def $vl, implicit-def $vtype, debug-location !12; test_addarray.c:9:10
> renamable $v8m8 = PseudoVLE32_V_M8 renamable $x5, $noreg, 5, implicit $vl, implicit $vtype, debug-location !12 :: (load (s2048) from %ir.lsr.iv1820, align 4, !tbaa !13, !alias.scope !17); test_addarray.c:9:10
> renamable $v16m8 = PseudoVLE32_V_M8 renamable $x13, $noreg, 5, implicit $vl, implicit $vtype, debug-location !20 :: (load (s2048) from %ir.lsr.iv1517, align 4, !tbaa !13, !alias.scope !21); test_addarray.c:9:17
> renamable $v8m8 = PseudoVADD_VV_M8 killed renamable $v16m8, killed renamable $v8m8, $noreg, 5, implicit $vl, implicit $vtype, debug-location !23; test_addarray.c:9:15
> PseudoVSE32_V_M8 killed renamable $v8m8, renamable $x14, $noreg, 5, implicit $vl, implicit $vtype, debug-location !24 :: (store (s2048) into %ir.lsr.iv1214, align 4, !tbaa !13, !alias.scope !25, !noalias !27); test_addarray.c:9:8
> renamable $x15 = nsw ADDI killed renamable $x15, -64, debug-location !11; test_addarray.c:7:20
> renamable $x14 = ADDI killed renamable $x14, 256, debug-location !11; test_addarray.c:7:20
> renamable $x13 = ADDI killed renamable $x13, 256, debug-location !11; test_addarray.c:7:20
> renamable $x5 = ADDI killed renamable $x5, 256, debug-location !11; test_addarray.c:7:20
> BNE renamable $x15, $x0, %bb.3, debug-location !11; test_addarray.c:7:20
976B	bb.6:
	; predecessors: %bb.3
	  successors: %bb.2(0x80000000); %bb.2(100.00%)
	  liveins: $x10, $x11, $x12, $x16
1008B	  PseudoBR %bb.2
> PseudoBR %bb.2
1024B	bb.4.for.cond.cleanup:
	; predecessors: %bb.5

1040B	  PseudoRET debug-location !32; test_addarray.c:11:1
> PseudoRET debug-location !32; test_addarray.c:11:1
1056B	bb.5.for.body:
	; predecessors: %bb.2, %bb.5
	  successors: %bb.4(0x04000000), %bb.5(0x7c000000); %bb.4(3.12%), %bb.5(96.88%)
	  liveins: $x10, $x11, $x12, $x14
1136B	  %46:gpr = LW %54:gpr, 0, debug-location !12 :: (load (s32) from %ir.lsr.iv8, !tbaa !13); test_addarray.c:9:10
1152B	  %47:gpr = LW %55:gpr, 0, debug-location !20 :: (load (s32) from %ir.lsr.iv5, !tbaa !13); test_addarray.c:9:17
1160B	  %16:gpr = COPY killed %57:gpr
1168B	  %48:gpr = ADD killed %47:gpr, killed %46:gpr, debug-location !23; test_addarray.c:9:15
1184B	  SW killed %48:gpr, %56:gpr, 0, debug-location !24 :: (store (s32) into %ir.lsr.iv2, !tbaa !13); test_addarray.c:9:8
1200B	  %57:gpr = ADDI %16:gpr, 1, debug-location !33; test_addarray.c:7:16
1216B	  %56:gpr = ADDI killed %56:gpr, 4, debug-location !33; test_addarray.c:7:16
1232B	  %55:gpr = ADDI killed %55:gpr, 4, debug-location !33; test_addarray.c:7:16
1248B	  %54:gpr = ADDI killed %54:gpr, 4, debug-location !33; test_addarray.c:7:16
1328B	  BLTU %57:gpr, killed %16:gpr, %bb.4, debug-location !10; test_addarray.c:7:2
1344B	  PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2
> renamable $x16 = LW renamable $x10, 0, debug-location !12 :: (load (s32) from %ir.lsr.iv8, !tbaa !13); test_addarray.c:9:10
> renamable $x15 = LW renamable $x11, 0, debug-location !20 :: (load (s32) from %ir.lsr.iv5, !tbaa !13); test_addarray.c:9:17
> renamable $x13 = COPY killed renamable $x14
> renamable $x14 = ADD killed renamable $x15, killed renamable $x16, debug-location !23; test_addarray.c:9:15
> SW killed renamable $x14, renamable $x12, 0, debug-location !24 :: (store (s32) into %ir.lsr.iv2, !tbaa !13); test_addarray.c:9:8
> renamable $x14 = ADDI renamable $x13, 1, debug-location !33; test_addarray.c:7:16
> renamable $x12 = ADDI killed renamable $x12, 4, debug-location !33; test_addarray.c:7:16
> renamable $x11 = ADDI killed renamable $x11, 4, debug-location !33; test_addarray.c:7:16
> renamable $x10 = ADDI killed renamable $x10, 4, debug-location !33; test_addarray.c:7:16
> BLTU renamable $x14, killed renamable $x13, %bb.4, debug-location !10; test_addarray.c:7:2
> PseudoBR %bb.5, debug-location !10; test_addarray.c:7:2
********** EMITTING LIVE DEBUG VARIABLES **********
********** EMITTING LIVE DEBUG LABELS **********
********** EMITTING DEBUG PHIS **********
********** EMITTING INSTR REFERENCES **********
********** Stack Slot Coloring **********
********** Function: add
MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
MCP: Copy is a deletion candidate:   renamable $x16 = COPY $x0
MCP: BackwardCopyPropagateBlock vector.body.preheader
MCP: ForwardCopyPropagateBlock vector.body.preheader
MCP: Copy is a deletion candidate:   renamable $x5 = COPY renamable $x10
MCP: Copy is a deletion candidate:   renamable $x13 = COPY renamable $x11
MCP: Copy is a deletion candidate:   renamable $x14 = COPY renamable $x12
MCP: BackwardCopyPropagateBlock for.body.preheader
MCP: ForwardCopyPropagateBlock for.body.preheader
MCP: BackwardCopyPropagateBlock vector.body
MCP: ForwardCopyPropagateBlock vector.body
MCP: BackwardCopyPropagateBlock 
MCP: ForwardCopyPropagateBlock 
MCP: BackwardCopyPropagateBlock for.cond.cleanup
MCP: ForwardCopyPropagateBlock for.cond.cleanup
MCP: BackwardCopyPropagateBlock for.body
MCP: ForwardCopyPropagateBlock for.body
MCP: Copy is a deletion candidate:   renamable $x13 = COPY killed renamable $x14
MCP: Copy is used - not dead:   renamable $x13 = COPY killed renamable $x14
MCP: Copy is used - not dead:   renamable $x13 = COPY killed renamable $x14
******** Post-regalloc Machine LICM: add ********

block-frequency: add
====================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[vector.body.preheader]
 - 2: BB3[vector.body]
 - 3: BB6
 - 4: BB2[for.body.preheader]
 - 5: BB5[for.body]
 - 6: BB4[for.cond.cleanup]
loop-detection
 - loop = BB5[for.body]
 - loop = BB3[vector.body]
compute-mass-in-loop: BB3[vector.body]*
 - node: BB3[vector.body]
  => [  exit  ] weight = 67108864, succ = BB6
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB3[vector.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB6
compute-loop-scale: BB3[vector.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB3[vector.body]*
 - node: BB3[vector.body]
compute-mass-in-loop: BB5[for.body]*
 - node: BB5[for.body]
  => [  exit  ] weight = 67108864, succ = BB4[for.cond.cleanup]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB5[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB4[for.cond.cleanup]
compute-loop-scale: BB5[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB5[for.body]*
 - node: BB5[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1073741824, succ = BB2[for.body.preheader]
  => [ local  ] weight = 1073741824, succ = BB1[vector.body.preheader]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB1[vector.body.preheader]
  => assign 8000000000000000 (0000000000000000) to BB2[for.body.preheader]
 - node: BB1[vector.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB3[vector.body]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB3[vector.body]
 - node: BB3[vector.body]
  => [ local  ] weight = 576460752303423488, succ = BB6
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB6
 - node: BB6
  => [ local  ] weight = 2147483648, succ = BB2[for.body.preheader]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB2[for.body.preheader]
 - node: BB2[for.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB5[for.body]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB5[for.body]
 - node: BB5[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB4[for.cond.cleanup]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB4[for.cond.cleanup]
 - node: BB4[for.cond.cleanup]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB5[for.body]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB5[for.body]: 1.0 => 32.0
unwrap-loop-package: BB3[vector.body]*: mass = 7fffffffffffffff, scale = 32.0
  => combined-scale = 16.0
 - BB3[vector.body]: 1.0 => 16.0
float-to-int: min = 0.5, max = 32.0, factor = 16.0
 - BB0[entry]: float = 1.0, scaled = 16.0, int = 16
 - BB1[vector.body.preheader]: float = 0.5, scaled = 8.0, int = 8
 - BB3[vector.body]: float = 16.0, scaled = 256.0, int = 255
 - BB6: float = 0.5, scaled = 8.0, int = 8
 - BB2[for.body.preheader]: float = 1.0, scaled = 16.0, int = 16
 - BB5[for.body]: float = 32.0, scaled = 512.0, int = 511
 - BB4[for.cond.cleanup]: float = 1.0, scaled = 16.0, int = 16
block-frequency-info: add
 - BB0[entry]: float = 1.0, int = 16
 - BB1[vector.body.preheader]: float = 0.5, int = 8
 - BB2[for.body.preheader]: float = 1.0, int = 16
 - BB3[vector.body]: float = 16.0, int = 255
 - BB6: float = 0.5, int = 8
 - BB4[for.cond.cleanup]: float = 1.0, int = 16
 - BB5[for.body]: float = 32.0, int = 511

		Looking for trivial roots
Found a new trivial root: %bb.4
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 7, Num: 8
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.4
3: %bb.5
4: %bb.2
5: %bb.6
6: %bb.3
7: %bb.1
8: %bb.0
Found roots: %bb.4 

TryTailMergeBlocks: %bb.0, %bb.6
  with successor %bb.2
  which has fall-through from %bb.1
Looking for common tails of at least 3 instructions

Removing MBB: bb.4:
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x16

TryTailMergeBlocks: %bb.0, %bb.3
  with successor %bb.2
  which has fall-through from %bb.3
Looking for common tails of at least 3 instructions

*** Tail-duplicating %bb.5
MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
MCP: Copy is a deletion candidate:   renamable $x16 = COPY $x0
MCP: BackwardCopyPropagateBlock vector.body.preheader
MCP: ForwardCopyPropagateBlock vector.body.preheader
MCP: Copy is a deletion candidate:   renamable $x5 = COPY renamable $x10
MCP: Copy is a deletion candidate:   renamable $x13 = COPY renamable $x11
MCP: Copy is a deletion candidate:   renamable $x14 = COPY renamable $x12
MCP: BackwardCopyPropagateBlock vector.body
MCP: ForwardCopyPropagateBlock vector.body
MCP: BackwardCopyPropagateBlock for.body.preheader
MCP: ForwardCopyPropagateBlock for.body.preheader
MCP: BackwardCopyPropagateBlock for.body
MCP: ForwardCopyPropagateBlock for.body
MCP: Copy is a deletion candidate:   renamable $x13 = COPY killed renamable $x14
MCP: Copy is used - not dead:   renamable $x13 = COPY killed renamable $x14
MCP: Copy is used - not dead:   renamable $x13 = COPY killed renamable $x14
MCP: BackwardCopyPropagateBlock for.cond.cleanup
MCP: ForwardCopyPropagateBlock for.cond.cleanup
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: add
real copy:   renamable $x16 = COPY $x0
replaced by: $x16 = ADDI $x0, 0
real copy:   renamable $x5 = COPY renamable $x10
replaced by: $x5 = ADDI $x10, 0
real copy:   renamable $x13 = COPY renamable $x11
replaced by: $x13 = ADDI $x11, 0
real copy:   renamable $x14 = COPY renamable $x12
replaced by: $x14 = ADDI $x12, 0
real copy:   renamable $x13 = COPY killed renamable $x14
replaced by: $x13 = ADDI killed $x14, 0

block-frequency: add
====================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[vector.body.preheader]
 - 2: BB2[vector.body]
 - 3: BB3[for.body.preheader]
 - 4: BB4[for.body]
 - 5: BB5[for.cond.cleanup]
loop-detection
 - loop = BB4[for.body]
 - loop = BB2[vector.body]
compute-mass-in-loop: BB2[vector.body]*
 - node: BB2[vector.body]
  => [  exit  ] weight = 67108864, succ = BB3[for.body.preheader]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB2[vector.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB3[for.body.preheader]
compute-loop-scale: BB2[vector.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB2[vector.body]*
 - node: BB2[vector.body]
compute-mass-in-loop: BB4[for.body]*
 - node: BB4[for.body]
  => [  exit  ] weight = 67108864, succ = BB5[for.cond.cleanup]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB4[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB5[for.cond.cleanup]
compute-loop-scale: BB4[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB4[for.body]*
 - node: BB4[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1073741824, succ = BB3[for.body.preheader]
  => [ local  ] weight = 1073741824, succ = BB1[vector.body.preheader]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB1[vector.body.preheader]
  => assign 8000000000000000 (0000000000000000) to BB3[for.body.preheader]
 - node: BB1[vector.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB2[vector.body]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB2[vector.body]
 - node: BB2[vector.body]
  => [ local  ] weight = 576460752303423488, succ = BB3[for.body.preheader]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB3[for.body.preheader]
 - node: BB3[for.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB4[for.body]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB4[for.body]
 - node: BB4[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB5[for.cond.cleanup]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB5[for.cond.cleanup]
 - node: BB5[for.cond.cleanup]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB4[for.body]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB4[for.body]: 1.0 => 32.0
unwrap-loop-package: BB2[vector.body]*: mass = 7fffffffffffffff, scale = 32.0
  => combined-scale = 16.0
 - BB2[vector.body]: 1.0 => 16.0
float-to-int: min = 0.5, max = 32.0, factor = 16.0
 - BB0[entry]: float = 1.0, scaled = 16.0, int = 16
 - BB1[vector.body.preheader]: float = 0.5, scaled = 8.0, int = 8
 - BB2[vector.body]: float = 16.0, scaled = 256.0, int = 255
 - BB3[for.body.preheader]: float = 1.0, scaled = 16.0, int = 16
 - BB4[for.body]: float = 32.0, scaled = 512.0, int = 511
 - BB5[for.cond.cleanup]: float = 1.0, scaled = 16.0, int = 16
block-frequency-info: add
 - BB0[entry]: float = 1.0, int = 16
 - BB1[vector.body.preheader]: float = 0.5, int = 8
 - BB2[vector.body]: float = 16.0, int = 255
 - BB3[for.body.preheader]: float = 1.0, int = 16
 - BB4[for.body]: float = 32.0, int = 511
 - BB5[for.cond.cleanup]: float = 1.0, int = 16

		Looking for trivial roots
Found a new trivial root: %bb.5
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 6, Num: 7
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.5
3: %bb.4
4: %bb.3
5: %bb.2
6: %bb.1
7: %bb.0
Found roots: %bb.5 
Pre-computing triangle chains.
Finding best loop top for: %bb.4 ('for.body')
    final top unchanged
Finding best loop exit for: %bb.4 ('for.body')
    exiting: %bb.4 ('for.body') -> %bb.5 ('for.cond.cleanup') [L:0] (0.9375)
    No other candidate exit blocks, using loop header
Selecting best successor for: %bb.4 ('for.body')
Finished forming chain for header block %bb.4 ('for.body')
          ... %bb.4 ('for.body')
Finding best loop top for: %bb.2 ('vector.body')
    final top unchanged
Finding best loop exit for: %bb.2 ('vector.body')
    exiting: %bb.2 ('vector.body') -> %bb.3 ('for.body.preheader') [L:0] (0.4375)
    No other candidate exit blocks, using loop header
Selecting best successor for: %bb.2 ('vector.body')
Finished forming chain for header block %bb.2 ('vector.body')
          ... %bb.2 ('vector.body')
Selecting best successor for: %bb.0 ('entry')
    Not a candidate: %bb.3 ('for.body.preheader') -> 0x40000000 / 0x80000000 = 50.00% (prob) (non-cold CFG conflict)
    Candidate: %bb.1 ('vector.body.preheader'), probability: 0x40000000 / 0x80000000 = 50.00%
    Setting it as best candidate
    Selected: %bb.1 ('vector.body.preheader')
Merging from %bb.0 ('entry') to %bb.1 ('vector.body.preheader')
Selecting best successor for: %bb.1 ('vector.body.preheader')
    Candidate: %bb.2 ('vector.body'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.2 ('vector.body')
Merging from %bb.1 ('vector.body.preheader') to %bb.2 ('vector.body')
Selecting best successor for: %bb.2 ('vector.body')
    Candidate: %bb.3 ('for.body.preheader'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.3 ('for.body.preheader')
Merging from %bb.2 ('vector.body') to %bb.3 ('for.body.preheader')
Selecting best successor for: %bb.3 ('for.body.preheader')
    Candidate: %bb.4 ('for.body'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.4 ('for.body')
Merging from %bb.3 ('for.body.preheader') to %bb.4 ('for.body')
Selecting best successor for: %bb.4 ('for.body')
    Candidate: %bb.5 ('for.cond.cleanup'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.5 ('for.cond.cleanup')
Merging from %bb.4 ('for.body') to %bb.5 ('for.cond.cleanup')
Selecting best successor for: %bb.5 ('for.cond.cleanup')
Finished forming chain for header block %bb.0 ('entry')
[MBP] Function: add
Placing chain %bb.0 ('entry')
          ... %bb.1 ('vector.body.preheader')
Updating terminators on %bb.0
          ... %bb.2 ('vector.body')
Updating terminators on %bb.1
          ... %bb.3 ('for.body.preheader')
Updating terminators on %bb.2
          ... %bb.4 ('for.body')
Updating terminators on %bb.3
          ... %bb.5 ('for.cond.cleanup')
Updating terminators on %bb.4
***** BranchRelaxation *****
  Basic blocks before relaxation
%bb.0	offset=00000000	size=0x38
%bb.1	offset=00000038	size=0x18
%bb.2	offset=00000050	size=0x28
%bb.3	offset=00000078	size=0x14
%bb.4	offset=0000008c	size=0x28
%bb.5	offset=000000b4	size=0x4
  Basic blocks after relaxation

%bb.0	offset=00000000	size=0x38
%bb.1	offset=00000038	size=0x18
%bb.2	offset=00000050	size=0x28
%bb.3	offset=00000078	size=0x14
%bb.4	offset=0000008c	size=0x28
%bb.5	offset=000000b4	size=0x4
********** COMPUTING STACKMAP LIVENESS: add **********

Debug Range Extension
MergeICmpsLegacyPass: main
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : main ----

Computing probabilities for entry

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - entry: float = 1.0, int = 8

********** Begin Constant Hoisting **********
********** Function: main
********** End Constant Hoisting **********
---- Branch Probability Info : main ----

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
Computing probabilities for entry

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - entry: float = 1.0, int = 8

[SafeStack] Function: main
[SafeStack]     safestack is not requested for this function
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : main ----

Computing probabilities for entry



=== main
Creating constant: t1: i32 = Constant<0>
Creating constant: t2: i64 = Constant<0>
Creating new node: t4: ch,glue = CopyToReg t0, Register:i64 $x10, Constant:i64<0>, test_addarray.c:24:2
Creating new node: t5: ch = RISCVISD::RET_FLAG t4, Register:i64 $x10, t4:1, test_addarray.c:24:2
Initial selection DAG: %bb.0 'main:entry'
SelectionDAG has 6 nodes:
  t1: i32 = Constant<0>
    t0: ch = EntryToken
  t4: ch,glue = CopyToReg t0, Register:i64 $x10, Constant:i64<0>, test_addarray.c:24:2
  t5: ch = RISCVISD::RET_FLAG t4, Register:i64 $x10, t4:1, test_addarray.c:24:2



Combining: t5: ch = RISCVISD::RET_FLAG t4, Register:i64 $x10, t4:1, test_addarray.c:24:2

Combining: t4: ch,glue = CopyToReg t0, Register:i64 $x10, Constant:i64<0>, test_addarray.c:24:2

Combining: t3: i64 = Register $x10

Combining: t2: i64 = Constant<0>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 'main:entry'
SelectionDAG has 5 nodes:
    t0: ch = EntryToken
  t4: ch,glue = CopyToReg t0, Register:i64 $x10, Constant:i64<0>, test_addarray.c:24:2
  t5: ch = RISCVISD::RET_FLAG t4, Register:i64 $x10, t4:1, test_addarray.c:24:2


Legalizing node: t3: i64 = Register $x10
Ignoring node results
Legally typed node: t3: i64 = Register $x10

Legalizing node: t2: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t2: i64 = Constant<0>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t4: ch,glue = CopyToReg t0, Register:i64 $x10, Constant:i64<0>, test_addarray.c:24:2
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t2: i64 = Constant<0>
Legal operand
Legally typed node: t4: ch,glue = CopyToReg t0, Register:i64 $x10, Constant:i64<0>, test_addarray.c:24:2

Legalizing node: t5: ch = RISCVISD::RET_FLAG t4, Register:i64 $x10, t4:1, test_addarray.c:24:2
Analyzing result type: ch
Legal result type
Analyzing operand: t4: ch,glue = CopyToReg t0, Register:i64 $x10, Constant:i64<0>, test_addarray.c:24:2
Legal operand
Analyzing operand: t4: ch,glue = CopyToReg t0, Register:i64 $x10, Constant:i64<0>, test_addarray.c:24:2
Legal operand
Legally typed node: t5: ch = RISCVISD::RET_FLAG t4, Register:i64 $x10, t4:1, test_addarray.c:24:2

Legalizing node: t65535: ch = handlenode t5
Analyzing result type: ch
Legal result type
Analyzing operand: t5: ch = RISCVISD::RET_FLAG t4, Register:i64 $x10, t4:1, test_addarray.c:24:2
Legal operand
Legally typed node: t65535: ch = handlenode t5

Type-legalized selection DAG: %bb.0 'main:entry'
SelectionDAG has 5 nodes:
    t0: ch = EntryToken
  t4: ch,glue = CopyToReg t0, Register:i64 $x10, Constant:i64<0>, test_addarray.c:24:2
  t5: ch = RISCVISD::RET_FLAG t4, Register:i64 $x10, t4:1, test_addarray.c:24:2



Legalizing: t5: ch = RISCVISD::RET_FLAG t4, Register:i64 $x10, t4:1, test_addarray.c:24:2
Legal node: nothing to do

Legalizing: t4: ch,glue = CopyToReg t0, Register:i64 $x10, Constant:i64<0>, test_addarray.c:24:2
Legal node: nothing to do

Legalizing: t3: i64 = Register $x10

Legalizing: t2: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.0 'main:entry'
SelectionDAG has 5 nodes:
    t0: ch = EntryToken
  t4: ch,glue = CopyToReg t0, Register:i64 $x10, Constant:i64<0>, test_addarray.c:24:2
  t5: ch = RISCVISD::RET_FLAG t4, Register:i64 $x10, t4:1, test_addarray.c:24:2



Legalizing: t5: ch = RISCVISD::RET_FLAG t4, Register:i64 $x10, t4:1, test_addarray.c:24:2
Legal node: nothing to do

Combining: t5: ch = RISCVISD::RET_FLAG t4, Register:i64 $x10, t4:1, test_addarray.c:24:2

Legalizing: t4: ch,glue = CopyToReg t0, Register:i64 $x10, Constant:i64<0>, test_addarray.c:24:2
Legal node: nothing to do

Combining: t4: ch,glue = CopyToReg t0, Register:i64 $x10, Constant:i64<0>, test_addarray.c:24:2

Legalizing: t3: i64 = Register $x10

Combining: t3: i64 = Register $x10

Legalizing: t2: i64 = Constant<0>
Legal node: nothing to do

Combining: t2: i64 = Constant<0>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 'main:entry'
SelectionDAG has 5 nodes:
    t0: ch = EntryToken
  t4: ch,glue = CopyToReg t0, Register:i64 $x10, Constant:i64<0>, test_addarray.c:24:2
  t5: ch = RISCVISD::RET_FLAG t4, Register:i64 $x10, t4:1, test_addarray.c:24:2


===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t5: ch = RISCVISD::RET_FLAG t4, Register:i64 $x10, t4:1, test_addarray.c:24:2
ISEL: Starting pattern match
  Initial Opcode index to 895194
  Morphed node: t5: ch = PseudoRET Register:i64 $x10, t4, t4:1, test_addarray.c:24:2
ISEL: Match complete!

ISEL: Starting selection on root node: t4: ch,glue = CopyToReg t0, Register:i64 $x10, Constant:i64<0>, test_addarray.c:24:2

ISEL: Starting selection on root node: t3: i64 = Register $x10

ISEL: Starting selection on root node: t2: i64 = Constant<0>
Creating new node: t7: i64,ch = CopyFromReg t0, Register:i64 $x0

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 'main:entry'
SelectionDAG has 6 nodes:
  t0: ch = EntryToken
    t7: i64,ch = CopyFromReg t0, Register:i64 $x0
  t4: ch,glue = CopyToReg t0, Register:i64 $x10, t7, test_addarray.c:24:2
  t5: ch = PseudoRET Register:i64 $x10, t4, t4:1, test_addarray.c:24:2


********** List Scheduling %bb.0 'entry' **********
SU(0): t5: ch = PseudoRET Register:i64 $x10, t4, t4:1, test_addarray.c:24:2

    t4: ch,glue = CopyToReg t0, Register:i64 $x10, t7, test_addarray.c:24:2

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
SU(1): t7: i64,ch = CopyFromReg t0, Register:i64 $x0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1

Examining Available:
Height 0: SU(0): t5: ch = PseudoRET Register:i64 $x10, t4, t4:1, test_addarray.c:24:2

    t4: ch,glue = CopyToReg t0, Register:i64 $x10, t7, test_addarray.c:24:2


*** Scheduling [0]: SU(0): t5: ch = PseudoRET Register:i64 $x10, t4, t4:1, test_addarray.c:24:2

    t4: ch,glue = CopyToReg t0, Register:i64 $x10, t7, test_addarray.c:24:2


Examining Available:
Height 1: SU(1): t7: i64,ch = CopyFromReg t0, Register:i64 $x0


*** Scheduling [1]: SU(1): t7: i64,ch = CopyFromReg t0, Register:i64 $x0

*** Final schedule ***
SU(1): t7: i64,ch = CopyFromReg t0, Register:i64 $x0

SU(0): t5: ch = PseudoRET Register:i64 $x10, t4, t4:1, test_addarray.c:24:2

    t4: ch,glue = CopyToReg t0, Register:i64 $x10, t7, test_addarray.c:24:2


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = COPY $x0
  $x10 = COPY %0:gpr, debug-location !36; test_addarray.c:24:2
  PseudoRET implicit $x10, debug-location !36; test_addarray.c:24:2

# End machine code for function main.

# Machine code for function main: IsSSA, TracksLiveness

0B	bb.0.entry:
16B	  %0:gpr = COPY $x0
32B	  $x10 = COPY %0:gpr, debug-location !36; test_addarray.c:24:2
48B	  PseudoRET implicit $x10, debug-location !36; test_addarray.c:24:2

# End machine code for function main.

********** Stack Coloring **********
********** Function: main

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 8

******** Pre-regalloc Machine LICM: main ********

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 8

Entering: entry
Exiting: entry
		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: main
MBB: entry
Skipping Detect dead lanes pass
********** PROCESS IMPLICIT DEFS **********
********** Function: main
********** REWRITING TWO-ADDR INSTRS **********
********** Function: main
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0.entry:
16B	  %0:gpr = COPY $x0
32B	  $x10 = COPY killed %0:gpr, debug-location !36; test_addarray.c:24:2
48B	  PseudoRET implicit killed $x10, debug-location !36; test_addarray.c:24:2

# End machine code for function main.

Computing live-in reg-units in ABI blocks.
Created 0 new intervals.
********** INTERVALS **********
%0 [16r,32r:0)  0@16r weight:0.000000e+00
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0.entry:
16B	  %0:gpr = COPY $x0
32B	  $x10 = COPY %0:gpr, debug-location !36; test_addarray.c:24:2
48B	  PseudoRET implicit killed $x10, debug-location !36; test_addarray.c:24:2

# End machine code for function main.

********** SIMPLE REGISTER COALESCING **********
********** Function: main
********** JOINING INTERVALS ***********
entry:
16B	%0:gpr = COPY $x0
	Considering merging %0 with $x0
		RHS = %0 [16r,32r:0)  0@16r weight:0.000000e+00
		updated: 32B	$x10 = COPY $x0, debug-location !36; test_addarray.c:24:2
	Success: %0 -> $x0
	Result = $x0
32B	$x10 = COPY $x0, debug-location !36; test_addarray.c:24:2
	Not coalescable.
Trying to inflate 0 regs.
********** INTERVALS **********
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0.entry:
32B	  $x10 = COPY $x0, debug-location !36; test_addarray.c:24:2
48B	  PseudoRET implicit killed $x10, debug-location !36; test_addarray.c:24:2

# End machine code for function main.

Before MISched:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten

bb.0.entry:
  $x10 = COPY $x0, debug-location !36; test_addarray.c:24:2
  PseudoRET implicit killed $x10, debug-location !36; test_addarray.c:24:2

# End machine code for function main.

********** INTERVALS **********
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0.entry:
32B	  $x10 = COPY $x0, debug-location !36; test_addarray.c:24:2
48B	  PseudoRET implicit killed $x10, debug-location !36; test_addarray.c:24:2

# End machine code for function main.


block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 8

********** COMPUTING LIVE DEBUG VARIABLES: main **********
********** DEBUG VARIABLES **********
********** DEBUG LABELS **********
********** GREEDY REGISTER ALLOCATION **********
********** Function: main
********** Compute Spill Weights **********
********** Function: main
********** INTERVALS **********
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0.entry:
32B	  $x10 = COPY $x0, debug-location !36; test_addarray.c:24:2
48B	  PseudoRET implicit killed $x10, debug-location !36; test_addarray.c:24:2

# End machine code for function main.

********** REWRITE VIRTUAL REGISTERS **********
********** Function: main
********** REGISTER MAP **********

0B	bb.0.entry:
32B	  $x10 = COPY $x0, debug-location !36; test_addarray.c:24:2
48B	  PseudoRET implicit killed $x10, debug-location !36; test_addarray.c:24:2
> $x10 = COPY $x0, debug-location !36; test_addarray.c:24:2
> PseudoRET implicit killed $x10, debug-location !36; test_addarray.c:24:2
********** EMITTING LIVE DEBUG VARIABLES **********
********** EMITTING LIVE DEBUG LABELS **********
********** EMITTING DEBUG PHIS **********
********** EMITTING INSTR REFERENCES **********
********** Stack Slot Coloring **********
********** Function: main
MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
MCP: Copy is a deletion candidate:   $x10 = COPY $x0, debug-location !36; test_addarray.c:24:2
MCP: Copy is used - not dead:   $x10 = COPY $x0, debug-location !36; test_addarray.c:24:2
******** Post-regalloc Machine LICM: main ********

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
MCP: Copy is a deletion candidate:   $x10 = COPY $x0, debug-location !36; test_addarray.c:24:2
MCP: Copy is used - not dead:   $x10 = COPY $x0, debug-location !36; test_addarray.c:24:2
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: main
real copy:   $x10 = COPY $x0, debug-location !36; test_addarray.c:24:2
replaced by: $x10 = ADDI $x0, 0, debug-location !36; test_addarray.c:24:2

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
***** BranchRelaxation *****
  Basic blocks before relaxation
%bb.0	offset=00000000	size=0x8
  Basic blocks after relaxation

%bb.0	offset=00000000	size=0x8
********** COMPUTING STACKMAP LIVENESS: main **********

Debug Range Extension
]0;t2000@DESKTOP-DC96FRC: ~/llvm-project/test[01;32mt2000@DESKTOP-DC96FRC[00m:[01;34m~/llvm-project/test[00m$ ../build_miqs/bin/llc test_addarray.ll -mattr=experimental-v -riscv-v-vector-bits-min=256 -debug [A]0;t2000@DESKTOP-DC96FRC: ~/llvm-project/test[01;32mt2000@DESKTOP-DC96FRC[00m:[01;34m~/llvm-project/test[00m$ [K
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cwxit[1Pxitexit
exit

Script done on 2022-01-01 16:47:32+09:00 [COMMAND_EXIT_CODE="0"]
